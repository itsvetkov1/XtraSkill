---
phase: 01-foundation-authentication
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/requirements.txt
  - backend/alembic.ini
  - backend/alembic/env.py
  - backend/app/models.py
  - backend/app/database.py
  - backend/main.py
  - backend/.env.example
autonomous: true

must_haves:
  truths:
    - "Application can store user accounts persistently"
    - "FastAPI server responds to health check requests"
    - "Database schema can be migrated forward and backward without data loss"
    - "Token usage can be tracked for cost monitoring"
  artifacts:
    - path: "backend/app/models.py"
      provides: "SQLAlchemy ORM models (User, TokenUsage)"
      min_lines: 50
    - path: "backend/alembic/versions/*.py"
      provides: "Initial migration script"
      contains: "create_table"
    - path: "backend/main.py"
      provides: "FastAPI application with health endpoint"
      exports: ["app"]
  key_links:
    - from: "backend/main.py"
      to: "backend/app/database.py"
      via: "database session dependency"
      pattern: "get_db.*Depends"
    - from: "backend/app/models.py"
      to: "sqlalchemy.orm"
      via: "ORM model definitions"
      pattern: "class.*Base"
---

<objective>
Establish the foundational data and API layers for the Business Analyst Assistant.

Purpose: Create PostgreSQL-compatible database schema and async FastAPI server that all subsequent phases depend on. This foundation enables authentication, project management, and AI integration without requiring architectural changes.

Output: Working database with migrations, FastAPI server responding to health checks, and token analytics infrastructure ready for Phase 3 AI integration.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/research/STACK.md
@.planning/research/ARCHITECTURE.md
@.planning/research/PITFALLS.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize backend project structure with PostgreSQL-compatible database schema</name>
  <files>
    backend/requirements.txt
    backend/alembic.ini
    backend/alembic/env.py
    backend/app/__init__.py
    backend/app/models.py
    backend/app/database.py
    backend/.env.example
  </files>
  <action>
    Create Python backend directory structure:

    1. **requirements.txt** - Pin exact versions:
       - fastapi[standard]>=0.115.0
       - anthropic==0.76.0
       - sqlalchemy>=2.0.35
       - alembic>=1.13.0
       - python-jose[cryptography]>=3.3.0
       - authlib>=1.3.0
       - cryptography>=43.0.0
       - pytest>=8.3.0
       - pytest-asyncio>=0.24.0

    2. **Database models** (app/models.py) - PostgreSQL-compatible types only:
       - User model: id (UUID primary key), email (unique), oauth_provider (enum: google/microsoft), oauth_id (unique), created_at, updated_at
       - TokenUsage model (CRITICAL for Pitfall #1): id (UUID), user_id (FK), request_tokens (int), response_tokens (int), total_cost (decimal), endpoint (str), created_at

       Use SQLAlchemy 2.0 syntax with mapped_column, UUID via uuid.uuid4, DateTime with timezone=True.

       WHY UUID: PostgreSQL best practice, avoids SQLite integer auto-increment issues.
       WHY TokenUsage in Phase 1: Must exist before AI service ships (Phase 3) to prevent cost explosion.

    3. **Database connection** (app/database.py):
       - Async engine with asyncio driver
       - Session factory using async_sessionmaker
       - get_db() dependency for FastAPI endpoints
       - Connection string from DATABASE_URL env var
       - Use postgresql+asyncpg:// for Postgres, sqlite+aiosqlite:/// for SQLite

    4. **Alembic setup**:
       - Initialize alembic with `alembic init alembic`
       - Configure alembic/env.py for async migrations
       - Set target_metadata = Base.metadata
       - Create initial migration: `alembic revision --autogenerate -m "Initial schema"`

    5. **.env.example** template:
       - DATABASE_URL=sqlite+aiosqlite:///./ba_assistant.db
       - SECRET_KEY=your-secret-key-here
       - GOOGLE_CLIENT_ID=your-google-client-id
       - GOOGLE_CLIENT_SECRET=your-google-client-secret
       - MICROSOFT_CLIENT_ID=your-microsoft-client-id
       - MICROSOFT_CLIENT_SECRET=your-microsoft-client-secret
       - ANTHROPIC_API_KEY=your-anthropic-key

    AVOID: SQLite-specific types (INTEGER PRIMARY KEY AUTOINCREMENT), loose typing, no foreign key constraints.
  </action>
  <verify>
    Run verification commands:
    ```bash
    cd backend
    pip install -r requirements.txt
    alembic upgrade head
    python -c "from app.models import User, TokenUsage; from app.database import engine; import asyncio; asyncio.run(engine.dispose())"
    ```

    Checks:
    - Dependencies install without errors
    - Migration applies successfully
    - Models import without errors
    - Database file created (SQLite) or connection succeeds (Postgres)
  </verify>
  <done>
    - requirements.txt contains all specified dependencies with correct versions
    - User and TokenUsage models defined with PostgreSQL-compatible types
    - Alembic configured for async migrations
    - Initial migration file exists in alembic/versions/
    - Database created with correct schema when migration applied
    - .env.example provides template for all required environment variables
  </done>
</task>

<task type="auto">
  <name>Task 2: Create FastAPI server with health check and CORS configuration</name>
  <files>
    backend/main.py
    backend/app/config.py
    backend/.env
  </files>
  <action>
    Create FastAPI application entry point:

    1. **Configuration module** (app/config.py):
       - Pydantic Settings class loading from environment
       - DATABASE_URL, SECRET_KEY, OAuth credentials, ANTHROPIC_API_KEY
       - CORS_ORIGINS list (default: ["http://localhost:3000", "http://localhost:8080"])
       - Validation: Raise clear error if required vars missing

    2. **FastAPI app** (main.py):
       - Create FastAPI instance with title="Business Analyst Assistant API", version="1.0.0"
       - Add CORS middleware with credentials=True, allow all methods/headers for configured origins
       - Add startup event: Initialize database (create tables if not exist via Alembic check)
       - Add shutdown event: Dispose database engine

    3. **Health check endpoint**:
       ```python
       @app.get("/health")
       async def health_check():
           return {
               "status": "healthy",
               "database": "connected",
               "version": "1.0.0"
           }
       ```

       WHY: PaaS platforms (Railway/Render) use health checks for deployment verification.

    4. **Root endpoint**:
       ```python
       @app.get("/")
       async def root():
           return {
               "message": "Business Analyst Assistant API",
               "docs": "/docs"
           }
       ```

    5. Create .env from .env.example with test values (SQLite database URL, dummy OAuth credentials for development).

    AVOID: Synchronous database operations (use async/await throughout), missing CORS config (will block Flutter web), hardcoded secrets.
  </action>
  <verify>
    Run verification commands:
    ```bash
    cd backend
    uvicorn main:app --reload &
    sleep 3
    curl http://localhost:8000/health
    curl http://localhost:8000/
    curl http://localhost:8000/docs
    pkill -f uvicorn
    ```

    Expected output:
    - /health returns {"status": "healthy", "database": "connected", "version": "1.0.0"}
    - / returns API info with docs link
    - /docs shows interactive API documentation (Swagger UI)
  </verify>
  <done>
    - FastAPI server starts without errors
    - Health check endpoint returns 200 with expected JSON structure
    - Root endpoint returns API information
    - CORS configured for local development origins
    - Interactive API docs accessible at /docs
    - Database connection successful on startup
    - .env file exists with test configuration
  </done>
</task>

<task type="auto">
  <name>Task 3: Initialize Flutter application with navigation and state management</name>
  <files>
    frontend/pubspec.yaml
    frontend/lib/main.dart
    frontend/lib/core/config.dart
    frontend/lib/core/theme.dart
    frontend/lib/providers/auth_provider.dart
    frontend/lib/screens/splash_screen.dart
    frontend/lib/screens/auth/login_screen.dart
    frontend/lib/screens/home_screen.dart
  </files>
  <action>
    Create Flutter application structure:

    1. **Create Flutter project**:
       ```bash
       flutter create frontend --org com.baassistant --platforms=web,android,ios
       ```

    2. **Add dependencies** (pubspec.yaml):
       - provider: ^6.1.0 (state management)
       - dio: ^5.7.0 (HTTP client)
       - flutter_secure_storage: ^9.2.2 (token storage)
       - go_router: ^14.0.0 (navigation)

       Add to pubspec.yaml dependencies section.

    3. **App configuration** (lib/core/config.dart):
       - API_BASE_URL constant (default: "http://localhost:8000")
       - Platform detection helper (web vs mobile)
       - Debug mode flag

    4. **App theme** (lib/core/theme.dart):
       - Material 3 theme with primary color
       - Responsive typography (scale based on screen size)
       - Platform-aware: Cupertino theme on iOS, Material on Android/Web

       WHY: Addresses Pitfall #3 (cross-platform consistency) from day one.

    5. **Auth provider** (lib/providers/auth_provider.dart):
       - AuthState enum: unauthenticated, loading, authenticated
       - AuthProvider class extending ChangeNotifier
       - Stub methods: login(), logout(), checkAuthStatus()
       - Token storage placeholder (implemented in Plan 02)

    6. **Screen structure**:
       - **SplashScreen**: Shows logo, checks auth status, navigates to login or home
       - **LoginScreen**: Shows "Sign in with Google" and "Sign in with Microsoft" buttons (non-functional yet)
       - **HomeScreen**: Placeholder showing "Welcome to BA Assistant"

    7. **Main app** (lib/main.dart):
       - MaterialApp with MultiProvider wrapping
       - Inject AuthProvider
       - GoRouter configuration: / → SplashScreen, /login → LoginScreen, /home → HomeScreen
       - Auth-aware routing (redirect to /login if unauthenticated)

    8. **Platform-responsive layout pattern**:
       - Use LayoutBuilder to detect screen width
       - Define breakpoints: mobile (<600px), tablet (600-900px), desktop (>900px)
       - Example in HomeScreen: Show drawer on mobile, sidebar on desktop

    AVOID: Platform-specific code without conditionals, hardcoded dimensions, synchronous operations on main thread.
  </action>
  <verify>
    Run verification commands:
    ```bash
    cd frontend
    flutter pub get
    flutter analyze
    flutter test
    flutter run -d chrome --web-port=8080
    ```

    Manual checks:
    1. App launches without errors
    2. SplashScreen appears briefly, navigates to LoginScreen
    3. LoginScreen shows two OAuth buttons (non-functional)
    4. No console errors in Flutter DevTools
    5. Material 3 theme applied correctly
  </verify>
  <done>
    - Flutter project created with web, Android, iOS support
    - Dependencies installed successfully
    - Auth provider with state management implemented
    - Three screens (Splash, Login, Home) created with navigation
    - Platform-responsive layout patterns established
    - App runs on web without errors
    - Material 3 theme applied
    - GoRouter navigation working between screens
  </done>
</task>

</tasks>

<verification>
**Foundation layer complete when:**
1. FastAPI server responds to health checks at http://localhost:8000/health
2. Database schema applied successfully (User and TokenUsage tables exist)
3. Alembic migrations work forward and backward without errors
4. Flutter app launches and shows login screen
5. No import errors, no runtime crashes on any platform
6. CORS allows requests from Flutter web origin

**Test the full stack:**
```bash
# Terminal 1: Start backend
cd backend
source venv/bin/activate  # or venv\Scripts\activate on Windows
uvicorn main:app --reload

# Terminal 2: Start Flutter web
cd frontend
flutter run -d chrome --web-port=8080

# Terminal 3: Verify health check
curl http://localhost:8000/health
```

Expected: Backend returns healthy status, Flutter shows login screen, CORS allows communication.
</verification>

<success_criteria>
**Measurable completion criteria:**
1. Database file (SQLite) or connection (Postgres) exists with User and TokenUsage tables
2. FastAPI server starts and serves health check endpoint with 200 status
3. Alembic can apply initial migration forward and rollback backward
4. Flutter app builds and runs on web platform without errors
5. Navigation flows from Splash → Login screen without crashes
6. CORS configured to allow Flutter web origin (http://localhost:8080)
7. All dependencies install successfully on both backend and frontend
8. Code passes linting (flutter analyze, flake8/black for Python)

**Goal-backward verification:**
- Truth: "Database schema supports users and token tracking" → User and TokenUsage models exist in database
- Truth: "API server is reachable" → Health check returns 200
- Truth: "Flutter app can launch" → App shows splash screen without crash
- Truth: "Cross-platform foundation ready" → Platform detection and responsive layout implemented
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-authentication/01-01-SUMMARY.md` documenting:
- Database schema created (User, TokenUsage models)
- FastAPI server configured with health check
- Flutter app shell with navigation and state management
- Files created and their purpose
- Development server startup commands
- Any deviations from plan or issues encountered
</output>
