---
phase: 04.1-agent-sdk-skill-integration
plan: 02
type: execute
wave: 2
depends_on: ["04.1-01"]
files_modified:
  - backend/app/services/agent_service.py
  - backend/app/services/ai_service.py
  - backend/app/routes/conversations.py
autonomous: true

must_haves:
  truths:
    - "AgentService uses claude-agent-sdk instead of direct anthropic client"
    - "Tools are defined using @tool decorator"
    - "Skill prompt is loaded via skill_loader and appended to system prompt"
    - "SSE events (text_delta, tool_executing, artifact_created, message_complete) still work"
    - "Existing conversation flow unchanged from user perspective"
  artifacts:
    - path: "backend/app/services/agent_service.py"
      provides: "Claude Agent SDK integration service"
      exports: ["AgentService", "search_documents_tool", "save_artifact_tool"]
    - path: "backend/app/routes/conversations.py"
      provides: "Updated chat endpoint using AgentService"
      contains: "AgentService"
  key_links:
    - from: "backend/app/services/agent_service.py"
      to: "backend/app/services/skill_loader.py"
      via: "load_skill_prompt()"
      pattern: "load_skill_prompt"
    - from: "backend/app/services/agent_service.py"
      to: "claude_agent_sdk"
      via: "query() and @tool decorator"
      pattern: "from claude_agent_sdk import"
    - from: "backend/app/routes/conversations.py"
      to: "backend/app/services/agent_service.py"
      via: "AgentService.stream_chat()"
      pattern: "agent_service\\.stream_chat"
---

<objective>
Refactor AI service to use Claude Agent SDK with skill integration.

Purpose: Replace direct anthropic.AsyncAnthropic usage with Claude Agent SDK, define tools using @tool decorator, and integrate the business-analyst skill prompt for structured discovery conversations.

Output: Working AgentService that uses SDK with skill-enhanced prompts while maintaining existing SSE streaming API contract.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.1-agent-sdk-skill-integration/04.1-RESEARCH.md

# Previous plan context
@.planning/phases/04.1-agent-sdk-skill-integration/04.1-01-PLAN.md

# Existing code to refactor
@backend/app/services/ai_service.py (current implementation to replace)
@backend/app/routes/conversations.py (endpoint to update)
@backend/app/services/document_search.py (search function to wrap)
@backend/app/models.py (Artifact model)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create AgentService with SDK tools</name>
  <files>
    backend/app/services/agent_service.py
  </files>
  <action>
Create backend/app/services/agent_service.py:

```python
"""
Agent Service using Claude Agent SDK.

Provides AI-powered conversations with business-analyst skill integration.
Uses @tool decorator for search_documents and save_artifact tools.
"""
import json
import logging
from typing import AsyncGenerator, Dict, Any, Optional
from contextvars import ContextVar

from claude_agent_sdk import (
    query,
    ClaudeAgentOptions,
    tool,
    create_sdk_mcp_server,
    AssistantMessage,
    TextBlock,
    ToolUseBlock,
    ToolResultBlock,
    ResultMessage,
)

from app.config import settings
from app.services.skill_loader import load_skill_prompt
from app.services.document_search import search_documents
from app.models import Artifact, ArtifactType

logger = logging.getLogger(__name__)

# Context variables for passing request context to tools
_db_context: ContextVar[Any] = ContextVar("db_context")
_project_id_context: ContextVar[str] = ContextVar("project_id_context")
_thread_id_context: ContextVar[str] = ContextVar("thread_id_context")


# Tool definitions using @tool decorator
@tool(
    "search_documents",
    """Search project documents for relevant information.

USE THIS TOOL WHEN:
- User mentions documents, files, or project materials
- User asks about policies, requirements, or specifications
- User references something that might be in uploaded documents
- You need context about the project to answer accurately
- Discussion involves specific features, constraints, or decisions that may be documented

DO NOT USE WHEN:
- User is asking general questions not related to project documents
- You already have sufficient context from conversation history

Returns: Document snippets with filenames and relevance scores.""",
    {"query": str}
)
async def search_documents_tool(args: Dict[str, Any]) -> Dict[str, Any]:
    """Execute document search and return results."""
    query_text = args.get("query", "")

    try:
        db = _db_context.get()
        project_id = _project_id_context.get()
    except LookupError:
        return {
            "content": [{
                "type": "text",
                "text": "Error: Search context not available"
            }]
        }

    results = await search_documents(db, project_id, query_text)

    if not results:
        return {
            "content": [{
                "type": "text",
                "text": "No relevant documents found for this query."
            }]
        }

    formatted = []
    for doc_id, filename, snippet, score in results[:5]:
        # Clean up snippet HTML markers for readability
        clean_snippet = snippet.replace("<mark>", "**").replace("</mark>", "**")
        formatted.append(f"**{filename}**:\n{clean_snippet}")

    return {
        "content": [{
            "type": "text",
            "text": "\n\n---\n\n".join(formatted)
        }]
    }


@tool(
    "save_artifact",
    """Save a business analysis artifact to the current conversation thread.

USE THIS TOOL WHEN:
- User explicitly requests "create the documentation", "generate the BRD", "build the requirements document"
- You have completed discovery and gathered sufficient business requirements
- User asks to "create", "generate", "write", or "document" requirements

BEFORE USING:
- Verify primary business objective is clearly defined
- Verify target user personas are identified
- Verify key user flows are documented
- Verify success metrics are specified
- Consider using search_documents first to gather project context

You may call this tool multiple times to create multiple artifacts.""",
    {
        "artifact_type": str,
        "title": str,
        "content_markdown": str
    }
)
async def save_artifact_tool(args: Dict[str, Any]) -> Dict[str, Any]:
    """Save artifact to database and return confirmation."""
    try:
        db = _db_context.get()
        thread_id = _thread_id_context.get()
    except LookupError:
        return {
            "content": [{
                "type": "text",
                "text": "Error: Artifact context not available"
            }],
            "event": None
        }

    try:
        artifact_type = ArtifactType(args["artifact_type"])
    except ValueError:
        # Default to requirements_doc for BRDs
        artifact_type = ArtifactType.requirements_doc

    artifact = Artifact(
        thread_id=thread_id,
        artifact_type=artifact_type,
        title=args["title"],
        content_markdown=args["content_markdown"]
    )
    db.add(artifact)
    await db.commit()
    await db.refresh(artifact)

    event_data = {
        "id": artifact.id,
        "artifact_type": artifact.artifact_type.value,
        "title": artifact.title
    }

    return {
        "content": [{
            "type": "text",
            "text": f"Artifact saved successfully: '{artifact.title}' (ID: {artifact.id}). "
                    "User can now export as PDF, Word, or Markdown from the artifacts list."
        }],
        "event": event_data  # Custom field for SSE event
    }


class AgentService:
    """
    Claude Agent SDK service for skill-enhanced conversations.

    Uses the business-analyst skill for structured discovery and BRD generation.
    """

    def __init__(self):
        """Initialize agent service with SDK tools and skill prompt."""
        # Create MCP server with tools
        self.tools_server = create_sdk_mcp_server(
            name="ba-tools",
            version="1.0.0",
            tools=[search_documents_tool, save_artifact_tool]
        )

        # Load skill prompt (cached)
        try:
            self.skill_prompt = load_skill_prompt()
            logger.info(f"Loaded skill prompt ({len(self.skill_prompt)} chars)")
        except Exception as e:
            logger.error(f"Failed to load skill prompt: {e}")
            # Fall back to basic prompt
            self.skill_prompt = self._get_fallback_prompt()

    def _get_fallback_prompt(self) -> str:
        """Fallback prompt if skill files cannot be loaded."""
        return """You are a Business Analyst AI assistant helping users explore and document software requirements.

Your role is to:
1. Ask ONE question at a time during discovery
2. Proactively identify edge cases and missing requirements
3. Clarify ambiguous terms before proceeding
4. Redirect technical implementation discussions to business focus
5. Generate comprehensive Business Requirements Documents when requested

Be conversational but thorough. Help users think through their requirements completely."""

    async def stream_chat(
        self,
        messages: list[Dict[str, Any]],
        project_id: str,
        thread_id: str,
        db
    ) -> AsyncGenerator[Dict[str, Any], None]:
        """
        Stream chat response using Claude Agent SDK.

        Yields SSE-formatted events:
        - text_delta: Incremental text from Claude
        - tool_executing: Tool is being executed
        - artifact_created: An artifact was generated and saved
        - message_complete: Final message with usage stats
        - error: Error occurred

        Args:
            messages: Conversation history in Claude format
            project_id: Project ID for document search context
            thread_id: Thread ID for artifact association
            db: Database session

        Yields:
            Dict with 'event' and 'data' keys for SSE
        """
        # Set context variables for tools
        _db_context.set(db)
        _project_id_context.set(project_id)
        _thread_id_context.set(thread_id)

        # Build the prompt from messages
        # Convert message history to single prompt for SDK
        prompt_parts = []
        for msg in messages:
            role = msg.get("role", "user")
            content = msg.get("content", "")
            if isinstance(content, str):
                prompt_parts.append(f"[{role.upper()}]: {content}")
            elif isinstance(content, list):
                # Handle tool results
                for part in content:
                    if isinstance(part, dict):
                        prompt_parts.append(f"[{role.upper()}]: {part.get('content', '')}")

        full_prompt = "\n\n".join(prompt_parts)

        # Configure SDK options
        options = ClaudeAgentOptions(
            system_prompt={
                "type": "preset",
                "preset": "claude_code",
                "append": self.skill_prompt
            },
            mcp_servers={"ba": self.tools_server},
            allowed_tools=[
                "mcp__ba__search_documents",
                "mcp__ba__save_artifact"
            ],
            permission_mode="acceptEdits",
            include_partial_messages=True,
            model="claude-sonnet-4-5-20250514"
        )

        accumulated_text = ""
        usage_data = {"input_tokens": 0, "output_tokens": 0}

        try:
            async for message in query(prompt=full_prompt, options=options):
                if isinstance(message, AssistantMessage):
                    for block in message.content:
                        if isinstance(block, TextBlock):
                            # Stream text delta
                            text = block.text
                            accumulated_text += text
                            yield {
                                "event": "text_delta",
                                "data": json.dumps({"text": text})
                            }

                        elif isinstance(block, ToolUseBlock):
                            # Tool being called
                            tool_name = block.name
                            if "save_artifact" in tool_name:
                                yield {
                                    "event": "tool_executing",
                                    "data": json.dumps({"status": "Generating artifact..."})
                                }
                            else:
                                yield {
                                    "event": "tool_executing",
                                    "data": json.dumps({"status": "Searching project documents..."})
                                }

                        elif isinstance(block, ToolResultBlock):
                            # Tool completed - check for artifact event
                            if hasattr(block, 'result') and isinstance(block.result, dict):
                                event_data = block.result.get('event')
                                if event_data:
                                    yield {
                                        "event": "artifact_created",
                                        "data": json.dumps(event_data)
                                    }

                elif isinstance(message, ResultMessage):
                    # Final result with usage stats
                    if hasattr(message, 'usage'):
                        usage_data = {
                            "input_tokens": getattr(message.usage, 'input_tokens', 0),
                            "output_tokens": getattr(message.usage, 'output_tokens', 0)
                        }

                    yield {
                        "event": "message_complete",
                        "data": json.dumps({
                            "content": accumulated_text,
                            "usage": usage_data
                        })
                    }
                    return

            # If we didn't get a ResultMessage, yield completion anyway
            yield {
                "event": "message_complete",
                "data": json.dumps({
                    "content": accumulated_text,
                    "usage": usage_data
                })
            }

        except Exception as e:
            logger.error(f"Agent SDK error: {e}")
            yield {
                "event": "error",
                "data": json.dumps({"message": f"AI service error: {str(e)}"})
            }
```

Key changes from direct API:
1. Uses @tool decorator instead of JSON schema dicts
2. Uses context variables to pass db/project_id/thread_id to tools
3. Uses query() function with ClaudeAgentOptions
4. Skill prompt appended via system_prompt.append
5. Message types handled via isinstance checks
  </action>
  <verify>
Run:
```bash
cd backend && python -c "
from app.services.agent_service import AgentService, search_documents_tool, save_artifact_tool

# Test service instantiation
service = AgentService()
print(f'Skill prompt loaded: {len(service.skill_prompt)} chars')

# Verify tools are defined
print(f'Tools: search_documents_tool, save_artifact_tool defined')

print('AgentService ready!')
"
```
  </verify>
  <done>
AgentService class uses Claude Agent SDK with @tool decorators, skill prompt integration, and SSE event yielding.
  </done>
</task>

<task type="auto">
  <name>Task 2: Update conversations endpoint to use AgentService</name>
  <files>
    backend/app/routes/conversations.py
  </files>
  <action>
Update backend/app/routes/conversations.py to use AgentService instead of AIService.

1. Update the import:
```python
# Change from:
from app.services.ai_service import AIService
# To:
from app.services.agent_service import AgentService
```

2. In the stream_chat function, update the service instantiation:
```python
# Change from:
ai_service = AIService()

async def event_generator():
    ...
    async for event in ai_service.stream_chat(
        conversation,
        thread.project_id,
        db
    ):
# To:
agent_service = AgentService()

async def event_generator():
    ...
    async for event in agent_service.stream_chat(
        conversation,
        thread.project_id,
        thread_id,  # Add thread_id parameter
        db
    ):
```

The key change is:
- Replace `AIService()` with `AgentService()`
- Add `thread_id` parameter to `stream_chat()` call (for artifact association)

Full updated function should look like:

```python
@router.post("/threads/{thread_id}/chat")
async def stream_chat(
    thread_id: str,
    request: Request,
    body: ChatRequest,
    current_user: dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Stream AI response for a chat message.

    Uses Claude Agent SDK with business-analyst skill for structured discovery.
    AI follows one-question-at-a-time protocol and can generate BRDs.

    SSE Events:
    - text_delta: Incremental text from AI
    - tool_executing: AI is executing a tool
    - artifact_created: An artifact was generated and saved
    - message_complete: Response complete with usage stats
    - error: Error occurred
    """
    # Validate thread access
    thread = await validate_thread_access(db, thread_id, current_user["user_id"])

    # Save user message to database
    await save_message(db, thread_id, "user", body.content)

    # Build conversation context from thread history
    conversation = await build_conversation_context(db, thread_id)

    # Add the new user message
    conversation.append({"role": "user", "content": body.content})

    # Initialize Agent service (uses SDK with skill)
    agent_service = AgentService()

    async def event_generator():
        """Generate SSE events from AI response."""
        accumulated_text = ""
        usage_data = None

        try:
            async for event in agent_service.stream_chat(
                conversation,
                thread.project_id,
                thread_id,
                db
            ):
                # Check for client disconnect
                if await request.is_disconnected():
                    break

                # Track accumulated text for saving
                if event["event"] == "text_delta":
                    data = json.loads(event["data"])
                    accumulated_text += data.get("text", "")

                # Track usage for token tracking
                if event["event"] == "message_complete":
                    data = json.loads(event["data"])
                    usage_data = data.get("usage", {})
                    accumulated_text = data.get("content", accumulated_text)

                yield event

            # Save assistant message after streaming completes
            if accumulated_text:
                await save_message(db, thread_id, "assistant", accumulated_text)

            # TODO: Track token usage (existing Plan 03-02)
            # TODO: Update thread summary (existing Plan 03-02)

        except Exception as e:
            yield {
                "event": "error",
                "data": json.dumps({"message": str(e)})
            }

    return EventSourceResponse(
        event_generator(),
        headers={
            "X-Accel-Buffering": "no",
            "Cache-Control": "no-cache",
        }
    )
```
  </action>
  <verify>
Run:
```bash
cd backend && python -c "
from app.routes.conversations import router, stream_chat
print('Conversations router imports successfully')
print('AgentService will be used for chat')
"
```

Then start the server and test:
```bash
cd backend && uvicorn main:app --reload --port 8002 &
sleep 3
curl -X POST http://localhost:8002/api/threads/test-id/chat \
  -H "Content-Type: application/json" \
  -d '{"content":"test"}'
# Should return 401 (unauthorized) not 500 (import error)
```
  </verify>
  <done>
Conversations endpoint uses AgentService with skill integration. SSE events unchanged from user perspective.
  </done>
</task>

<task type="auto">
  <name>Task 3: Keep AIService as fallback and add deprecation note</name>
  <files>
    backend/app/services/ai_service.py
  </files>
  <action>
Update backend/app/services/ai_service.py to add deprecation warning but keep it as fallback.

Add at the top of the file, after the docstring:

```python
"""
AI Service for Claude API integration.

DEPRECATED: This service uses direct Anthropic API.
Use AgentService instead for skill-enhanced conversations.

Kept as fallback for testing and gradual migration.
"""
import warnings
import anthropic
# ... rest of imports

# Add deprecation warning in __init__
class AIService:
    """Claude AI service for streaming chat with tool use.

    DEPRECATED: Use AgentService for skill-enhanced conversations.
    """

    def __init__(self):
        warnings.warn(
            "AIService is deprecated. Use AgentService for skill-enhanced conversations.",
            DeprecationWarning,
            stacklevel=2
        )
        self.client = anthropic.AsyncAnthropic(api_key=settings.anthropic_api_key)
        self.tools = [DOCUMENT_SEARCH_TOOL, SAVE_ARTIFACT_TOOL]
    # ... rest unchanged
```

This allows:
1. Existing tests to continue working
2. Gradual migration to AgentService
3. Clear deprecation notice for developers
  </action>
  <verify>
Run:
```bash
cd backend && python -c "
import warnings
warnings.filterwarnings('always', category=DeprecationWarning)
from app.services.ai_service import AIService
service = AIService()
print('AIService still works with deprecation warning')
"
```
Should print deprecation warning followed by "AIService still works".
  </verify>
  <done>
AIService marked as deprecated with warning, kept as fallback. AgentService is the new primary service.
  </done>
</task>

</tasks>

<verification>
1. `from app.services.agent_service import AgentService` imports without error
2. AgentService().skill_prompt contains business-analyst skill content
3. POST /threads/{id}/chat uses AgentService (check server logs)
4. SSE events (text_delta, tool_executing, artifact_created, message_complete) still work
5. AIService import shows deprecation warning
</verification>

<success_criteria>
- AgentService class using claude-agent-sdk query() function
- Tools defined with @tool decorator (search_documents_tool, save_artifact_tool)
- Skill prompt loaded from skill_loader and appended to system_prompt
- Context variables pass db/project_id/thread_id to tools
- SSE event format unchanged (text_delta, tool_executing, artifact_created, message_complete)
- Conversations endpoint updated to use AgentService
- AIService deprecated but functional as fallback
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-agent-sdk-skill-integration/04.1-02-SUMMARY.md`
</output>
