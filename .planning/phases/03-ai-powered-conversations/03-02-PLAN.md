---
phase: 03-ai-powered-conversations
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - backend/app/services/token_tracking.py
  - backend/app/services/summarization_service.py
  - backend/app/routes/conversations.py
autonomous: true

must_haves:
  truths:
    - "Token usage is recorded after each AI response"
    - "User monthly budget is checked before allowing chat"
    - "Thread title updates automatically after N messages"
    - "Cost is calculated from input/output token counts"
  artifacts:
    - path: "backend/app/services/token_tracking.py"
      provides: "Token usage tracking and budget enforcement"
      exports: ["track_token_usage", "check_user_budget", "get_monthly_usage"]
    - path: "backend/app/services/summarization_service.py"
      provides: "AI-generated thread summaries"
      exports: ["generate_thread_summary", "maybe_update_summary"]
  key_links:
    - from: "backend/app/routes/conversations.py"
      to: "backend/app/services/token_tracking.py"
      via: "track_token_usage after stream"
      pattern: "track_token_usage"
    - from: "backend/app/routes/conversations.py"
      to: "backend/app/services/summarization_service.py"
      via: "maybe_update_summary after message"
      pattern: "maybe_update_summary"
---

<objective>
Create token tracking and thread summarization services.

Purpose: Enable cost monitoring (AI-07) and automatic thread title updates (CONV-06) by tracking token usage per request and generating AI summaries as conversations progress.

Output: Token tracking service enforcing monthly budgets, summarization service updating thread titles every 5 messages.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ai-powered-conversations/03-RESEARCH.md

# Prior plan summary (conversations.py exists from 03-01)
@.planning/phases/03-ai-powered-conversations/03-01-SUMMARY.md

# Existing code to reference
@backend/app/models.py (TokenUsage model)
@backend/app/config.py (settings)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create token tracking service</name>
  <files>
    backend/app/services/token_tracking.py
  </files>
  <action>
Create backend/app/services/token_tracking.py:

```python
"""
Token usage tracking service for AI cost monitoring.

Tracks token usage per request, calculates costs, and enforces
monthly budgets to prevent cost explosion.
"""
from decimal import Decimal
from datetime import datetime
from typing import Optional
from sqlalchemy import select, func
from sqlalchemy.ext.asyncio import AsyncSession
from app.models import TokenUsage

# Claude pricing (as of Jan 2026)
# Claude Sonnet 4.5: $3/1M input, $15/1M output
PRICING = {
    "claude-sonnet-4-5-20250514": {
        "input": Decimal("3.00"),   # $3 per 1M input tokens
        "output": Decimal("15.00"),  # $15 per 1M output tokens
    },
    # Fallback pricing
    "default": {
        "input": Decimal("3.00"),
        "output": Decimal("15.00"),
    }
}

# Default monthly budget per user
DEFAULT_MONTHLY_BUDGET = Decimal("50.00")  # $50/month


def calculate_cost(
    model: str,
    input_tokens: int,
    output_tokens: int
) -> Decimal:
    """
    Calculate cost for token usage.

    Args:
        model: Model name
        input_tokens: Number of input tokens
        output_tokens: Number of output tokens

    Returns:
        Total cost in USD
    """
    pricing = PRICING.get(model, PRICING["default"])

    input_cost = (Decimal(input_tokens) / Decimal(1_000_000)) * pricing["input"]
    output_cost = (Decimal(output_tokens) / Decimal(1_000_000)) * pricing["output"]

    return input_cost + output_cost


async def track_token_usage(
    db: AsyncSession,
    user_id: str,
    model: str,
    input_tokens: int,
    output_tokens: int,
    endpoint: str
) -> TokenUsage:
    """
    Record token usage for a request.

    Args:
        db: Database session
        user_id: User ID
        model: Model name used
        input_tokens: Number of input tokens
        output_tokens: Number of output tokens
        endpoint: API endpoint that used tokens

    Returns:
        Created TokenUsage record
    """
    total_cost = calculate_cost(model, input_tokens, output_tokens)

    usage = TokenUsage(
        user_id=user_id,
        request_tokens=input_tokens,
        response_tokens=output_tokens,
        total_cost=total_cost,
        endpoint=endpoint,
        model=model
    )

    db.add(usage)
    await db.commit()
    await db.refresh(usage)

    return usage


async def get_monthly_usage(
    db: AsyncSession,
    user_id: str
) -> dict:
    """
    Get token usage statistics for current month.

    Args:
        db: Database session
        user_id: User ID

    Returns:
        Dict with total_cost, total_requests, total_input_tokens, total_output_tokens
    """
    month_start = datetime.utcnow().replace(
        day=1, hour=0, minute=0, second=0, microsecond=0
    )

    result = await db.execute(
        select(
            func.sum(TokenUsage.total_cost).label("total_cost"),
            func.count(TokenUsage.id).label("total_requests"),
            func.sum(TokenUsage.request_tokens).label("total_input_tokens"),
            func.sum(TokenUsage.response_tokens).label("total_output_tokens")
        ).where(
            TokenUsage.user_id == user_id,
            TokenUsage.created_at >= month_start
        )
    )
    row = result.first()

    return {
        "total_cost": row.total_cost or Decimal("0"),
        "total_requests": row.total_requests or 0,
        "total_input_tokens": row.total_input_tokens or 0,
        "total_output_tokens": row.total_output_tokens or 0,
        "month_start": month_start.isoformat(),
        "budget": DEFAULT_MONTHLY_BUDGET
    }


async def check_user_budget(
    db: AsyncSession,
    user_id: str,
    monthly_limit: Optional[Decimal] = None
) -> bool:
    """
    Check if user is within monthly budget.

    Args:
        db: Database session
        user_id: User ID
        monthly_limit: Optional custom limit (defaults to DEFAULT_MONTHLY_BUDGET)

    Returns:
        True if user can make requests, False if budget exceeded
    """
    limit = monthly_limit or DEFAULT_MONTHLY_BUDGET
    usage = await get_monthly_usage(db, user_id)

    return usage["total_cost"] < limit
```
  </action>
  <verify>
Import test: `python -c "from app.services.token_tracking import track_token_usage, check_user_budget, calculate_cost; print('OK')"`
Unit test: `python -c "from app.services.token_tracking import calculate_cost; assert calculate_cost('claude-sonnet-4-5-20250514', 1000, 100) > 0; print('Cost calculation OK')"`
  </verify>
  <done>
Token tracking service calculates costs from Claude pricing, tracks usage per request in TokenUsage table, enforces monthly budget limit ($50 default).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create thread summarization service</name>
  <files>
    backend/app/services/summarization_service.py
  </files>
  <action>
Create backend/app/services/summarization_service.py:

```python
"""
Thread summarization service for AI-generated titles.

Generates concise thread titles based on conversation content.
Updates automatically as conversation progresses.
"""
import anthropic
from typing import List, Dict, Any, Optional
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.models import Thread, Message
from app.config import settings
from app.services.token_tracking import track_token_usage

# Model for summarization (can use faster/cheaper model)
SUMMARY_MODEL = "claude-sonnet-4-5-20250514"

# Update summary every N messages
SUMMARY_INTERVAL = 5

# Max title length
MAX_TITLE_LENGTH = 100


def format_messages_for_summary(messages: List[Dict[str, Any]]) -> str:
    """Format messages for summary prompt."""
    formatted = []
    for msg in messages:
        role = msg.get("role", "unknown")
        content = msg.get("content", "")
        if isinstance(content, str):
            # Truncate long messages
            if len(content) > 500:
                content = content[:500] + "..."
            formatted.append(f"{role.upper()}: {content}")
    return "\n\n".join(formatted)


async def generate_thread_summary(
    client: anthropic.AsyncAnthropic,
    messages: List[Dict[str, Any]],
    current_title: Optional[str] = None
) -> tuple[str, dict]:
    """
    Generate a concise summary title for a thread.

    Args:
        client: Anthropic client
        messages: Conversation messages
        current_title: Current thread title (if any)

    Returns:
        Tuple of (new_title, usage_dict)
    """
    # Use last 10 messages for context (avoid token explosion)
    recent_messages = messages[-10:] if len(messages) > 10 else messages
    formatted = format_messages_for_summary(recent_messages)

    prompt = f"""Based on this conversation between a user and a Business Analyst AI assistant, generate a concise title (max {MAX_TITLE_LENGTH} characters) that captures the main topic being discussed.

The title should:
- Describe the feature or requirement being explored
- Be specific enough to distinguish from other conversations
- Use natural language (not technical jargon)

Current title: {current_title or "New Conversation"}

Conversation:
{formatted}

Return ONLY the title text, no quotes, no explanation, no punctuation at the end."""

    response = await client.messages.create(
        model=SUMMARY_MODEL,
        max_tokens=100,
        messages=[{"role": "user", "content": prompt}]
    )

    title = response.content[0].text.strip()

    # Ensure title fits limit
    if len(title) > MAX_TITLE_LENGTH:
        title = title[:MAX_TITLE_LENGTH - 3] + "..."

    usage = {
        "input_tokens": response.usage.input_tokens,
        "output_tokens": response.usage.output_tokens
    }

    return title, usage


async def maybe_update_summary(
    db: AsyncSession,
    thread_id: str,
    user_id: str
) -> Optional[str]:
    """
    Update thread summary if enough messages have accumulated.

    Updates title every SUMMARY_INTERVAL messages.

    Args:
        db: Database session
        thread_id: Thread ID
        user_id: User ID (for token tracking)

    Returns:
        New title if updated, None otherwise
    """
    from app.services.conversation_service import get_message_count

    message_count = await get_message_count(db, thread_id)

    # Only update at intervals (after 5, 10, 15... messages)
    if message_count < SUMMARY_INTERVAL or message_count % SUMMARY_INTERVAL != 0:
        return None

    # Get thread
    stmt = select(Thread).where(Thread.id == thread_id)
    result = await db.execute(stmt)
    thread = result.scalar_one_or_none()

    if not thread:
        return None

    # Get messages
    stmt_msgs = (
        select(Message)
        .where(Message.thread_id == thread_id)
        .order_by(Message.created_at)
    )
    result_msgs = await db.execute(stmt_msgs)
    messages = result_msgs.scalars().all()

    # Convert to dict format
    msg_dicts = [{"role": m.role, "content": m.content} for m in messages]

    # Generate summary
    client = anthropic.AsyncAnthropic(api_key=settings.anthropic_api_key)

    try:
        new_title, usage = await generate_thread_summary(
            client,
            msg_dicts,
            thread.title
        )

        # Update thread title
        thread.title = new_title
        await db.commit()

        # Track token usage for summarization
        await track_token_usage(
            db,
            user_id,
            SUMMARY_MODEL,
            usage["input_tokens"],
            usage["output_tokens"],
            f"/threads/{thread_id}/summarize"
        )

        return new_title

    except Exception as e:
        # Log error but don't fail the main request
        print(f"Summarization failed: {e}")
        return None
```
  </action>
  <verify>
Import test: `python -c "from app.services.summarization_service import maybe_update_summary, generate_thread_summary, SUMMARY_INTERVAL; print(f'Summary interval: {SUMMARY_INTERVAL}')"`
  </verify>
  <done>
Summarization service generates AI thread titles based on conversation content, updates every 5 messages, tracks token usage for summarization calls.
  </done>
</task>

<task type="auto">
  <name>Task 3: Wire token tracking and summarization into chat endpoint</name>
  <files>
    backend/app/routes/conversations.py
  </files>
  <action>
Update backend/app/routes/conversations.py to integrate token tracking and summarization.

1. Add imports at top:
```python
from app.services.token_tracking import track_token_usage, check_user_budget
from app.services.summarization_service import maybe_update_summary
from app.services.ai_service import MODEL as AI_MODEL
```

2. Add budget check at start of stream_chat function (after thread validation):
```python
    # Check user budget before allowing chat
    if not await check_user_budget(db, current_user["user_id"]):
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail="Monthly token budget exceeded. Please try again next month."
        )
```

3. Replace the TODO comments in event_generator with actual implementations:
```python
            # Save assistant message after streaming completes
            if accumulated_text:
                await save_message(db, thread_id, "assistant", accumulated_text)

            # Track token usage
            if usage_data:
                await track_token_usage(
                    db,
                    current_user["user_id"],
                    AI_MODEL,
                    usage_data.get("input_tokens", 0),
                    usage_data.get("output_tokens", 0),
                    f"/threads/{thread_id}/chat"
                )

            # Update thread summary if needed
            await maybe_update_summary(db, thread_id, current_user["user_id"])
```

The full updated event_generator should look like:
```python
    async def event_generator():
        """Generate SSE events from AI response."""
        accumulated_text = ""
        usage_data = None

        try:
            async for event in ai_service.stream_chat(
                conversation,
                thread.project_id,
                db
            ):
                # Check for client disconnect
                if await request.is_disconnected():
                    break

                # Track accumulated text for saving
                if event["event"] == "text_delta":
                    data = json.loads(event["data"])
                    accumulated_text += data.get("text", "")

                # Track usage for token tracking
                if event["event"] == "message_complete":
                    data = json.loads(event["data"])
                    usage_data = data.get("usage", {})
                    accumulated_text = data.get("content", accumulated_text)

                yield event

            # Save assistant message after streaming completes
            if accumulated_text:
                await save_message(db, thread_id, "assistant", accumulated_text)

            # Track token usage
            if usage_data:
                await track_token_usage(
                    db,
                    current_user["user_id"],
                    AI_MODEL,
                    usage_data.get("input_tokens", 0),
                    usage_data.get("output_tokens", 0),
                    f"/threads/{thread_id}/chat"
                )

            # Update thread summary if needed
            await maybe_update_summary(db, thread_id, current_user["user_id"])

        except Exception as e:
            yield {
                "event": "error",
                "data": json.dumps({"message": str(e)})
            }
```
  </action>
  <verify>
1. Backend starts without errors
2. Import check: `python -c "from app.routes.conversations import router; print('OK')"`
  </verify>
  <done>
Chat endpoint checks budget before allowing requests, tracks token usage after responses, and triggers thread summary updates every 5 messages.
  </done>
</task>

</tasks>

<verification>
1. Token tracking records are created after chat requests
2. Budget check returns 429 when exceeded
3. Thread title updates after 5 messages
4. Cost calculation matches Claude pricing
</verification>

<success_criteria>
- track_token_usage creates TokenUsage records with correct cost
- check_user_budget returns false when monthly spend exceeds $50
- maybe_update_summary updates thread.title every 5 messages
- Chat endpoint returns 429 when budget exceeded
- Token usage recorded for both chat and summarization calls
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-powered-conversations/03-02-SUMMARY.md`
</output>
