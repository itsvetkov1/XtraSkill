---
phase: 03-ai-powered-conversations
plan: 03
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - frontend/pubspec.yaml
  - frontend/lib/services/ai_service.dart
  - frontend/lib/providers/conversation_provider.dart
  - frontend/lib/screens/conversation/conversation_screen.dart
  - frontend/lib/screens/conversation/widgets/message_bubble.dart
  - frontend/lib/screens/conversation/widgets/streaming_message.dart
  - frontend/lib/screens/conversation/widgets/chat_input.dart
  - frontend/lib/screens/threads/thread_list_screen.dart
autonomous: true

must_haves:
  truths:
    - "User can type and send messages in a conversation"
    - "AI responses stream progressively on screen as they arrive"
    - "Message history displays with user and assistant messages distinguished"
    - "Streaming indicator shows while AI is generating response"
    - "Tapping a thread from the list opens the conversation screen"
  artifacts:
    - path: "frontend/lib/services/ai_service.dart"
      provides: "SSE stream consumption for AI chat"
      exports: ["AIService", "ChatEvent", "TextDeltaEvent", "MessageCompleteEvent"]
    - path: "frontend/lib/providers/conversation_provider.dart"
      provides: "Streaming state management"
      exports: ["ConversationProvider"]
    - path: "frontend/lib/screens/conversation/conversation_screen.dart"
      provides: "Main conversation UI with message list and input"
      min_lines: 100
  key_links:
    - from: "frontend/lib/screens/conversation/conversation_screen.dart"
      to: "frontend/lib/services/ai_service.dart"
      via: "streamChat method"
      pattern: "aiService\\.streamChat"
    - from: "frontend/lib/screens/threads/thread_list_screen.dart"
      to: "frontend/lib/screens/conversation/conversation_screen.dart"
      via: "Navigator.push on thread tap"
      pattern: "ConversationScreen"
---

<objective>
Create Flutter conversation UI with SSE streaming for real-time AI responses.

Purpose: Enable users to conduct AI-assisted conversations (CONV-04, AI-01, AI-06) by implementing the Flutter frontend that consumes SSE streams from the backend and displays streaming AI responses progressively.

Output: Working conversation screen where users can send messages and see AI responses stream in real-time.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-ai-powered-conversations/03-RESEARCH.md

# Prior plan summary (backend endpoints)
@.planning/phases/03-ai-powered-conversations/03-01-SUMMARY.md (if exists)

# Existing code to reference
@frontend/lib/providers/thread_provider.dart (thread state management patterns)
@frontend/lib/services/thread_service.dart (API call patterns with auth)
@frontend/lib/models/message.dart (Message and MessageRole)
@frontend/lib/models/thread.dart (Thread with messages)
@frontend/lib/core/config.dart (API_BASE_URL)
@frontend/pubspec.yaml (current dependencies)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add SSE dependency and create AI service</name>
  <files>
    frontend/pubspec.yaml
    frontend/lib/services/ai_service.dart
  </files>
  <action>
1. Add flutter_client_sse dependency to frontend/pubspec.yaml in the dependencies section:
```yaml
dependencies:
  # ... existing dependencies ...
  flutter_client_sse: ^2.0.0
```

2. Run `flutter pub get` to install

3. Create frontend/lib/services/ai_service.dart:

```dart
/// AI service for streaming chat with Claude via SSE.
library;

import 'dart:async';
import 'dart:convert';
import 'package:flutter_client_sse/flutter_client_sse.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import '../core/config.dart';

/// Base class for chat events from SSE stream
abstract class ChatEvent {}

/// Text delta event - incremental text from AI
class TextDeltaEvent extends ChatEvent {
  final String text;
  TextDeltaEvent({required this.text});
}

/// Tool executing event - AI is searching documents
class ToolExecutingEvent extends ChatEvent {
  final String status;
  ToolExecutingEvent({required this.status});
}

/// Message complete event - response finished with usage stats
class MessageCompleteEvent extends ChatEvent {
  final String content;
  final int inputTokens;
  final int outputTokens;
  MessageCompleteEvent({
    required this.content,
    required this.inputTokens,
    required this.outputTokens,
  });
}

/// Error event - something went wrong
class ErrorEvent extends ChatEvent {
  final String message;
  ErrorEvent({required this.message});
}

/// AI service for streaming chat conversations
class AIService {
  /// Secure storage for JWT tokens
  final FlutterSecureStorage _storage;

  /// Storage key for JWT token
  static const String _tokenKey = 'auth_token';

  AIService({FlutterSecureStorage? storage})
      : _storage = storage ?? const FlutterSecureStorage();

  /// Stream chat response from AI
  ///
  /// Connects to SSE endpoint and yields chat events as they arrive.
  /// [threadId] - ID of the thread to chat in
  /// [message] - User message content
  ///
  /// Yields ChatEvent subclasses:
  /// - TextDeltaEvent: Incremental text
  /// - ToolExecutingEvent: AI is using a tool
  /// - MessageCompleteEvent: Response complete
  /// - ErrorEvent: Error occurred
  Stream<ChatEvent> streamChat(String threadId, String message) async* {
    final token = await _storage.read(key: _tokenKey);
    if (token == null) {
      yield ErrorEvent(message: 'Not authenticated');
      return;
    }

    final url = '$apiBaseUrl/api/threads/$threadId/chat';

    try {
      // Use SSEClient to connect to streaming endpoint
      final stream = SSEClient.subscribeToSSE(
        method: SSERequestType.POST,
        url: url,
        header: {
          'Authorization': 'Bearer $token',
          'Content-Type': 'application/json',
          'Accept': 'text/event-stream',
          'Cache-Control': 'no-cache',
        },
        body: jsonEncode({'content': message}),
      );

      await for (final event in stream) {
        if (event.data == null || event.data!.isEmpty) continue;

        try {
          final data = jsonDecode(event.data!) as Map<String, dynamic>;

          switch (event.event) {
            case 'text_delta':
              yield TextDeltaEvent(text: data['text'] as String? ?? '');
              break;
            case 'tool_executing':
              yield ToolExecutingEvent(status: data['status'] as String? ?? 'Processing...');
              break;
            case 'message_complete':
              final usage = data['usage'] as Map<String, dynamic>?;
              yield MessageCompleteEvent(
                content: data['content'] as String? ?? '',
                inputTokens: usage?['input_tokens'] as int? ?? 0,
                outputTokens: usage?['output_tokens'] as int? ?? 0,
              );
              break;
            case 'error':
              yield ErrorEvent(message: data['message'] as String? ?? 'Unknown error');
              break;
          }
        } catch (e) {
          // Skip malformed events
          continue;
        }
      }
    } catch (e) {
      yield ErrorEvent(message: 'Connection error: $e');
    }
  }
}
```
  </action>
  <verify>
1. Run `cd frontend && flutter pub get` - should succeed with no errors
2. Check import: `flutter analyze lib/services/ai_service.dart` - should pass
  </verify>
  <done>
AIService class provides streamChat method that yields ChatEvent objects as SSE events arrive from backend.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create conversation provider for streaming state</name>
  <files>
    frontend/lib/providers/conversation_provider.dart
    frontend/lib/main.dart
  </files>
  <action>
1. Create frontend/lib/providers/conversation_provider.dart:

```dart
/// Conversation state management with streaming support.
library;

import 'package:flutter/foundation.dart';

import '../models/message.dart';
import '../models/thread.dart';
import '../services/ai_service.dart';
import '../services/thread_service.dart';

/// Conversation provider managing chat state and streaming
class ConversationProvider extends ChangeNotifier {
  /// AI service for streaming chat
  final AIService _aiService;

  /// Thread service for loading thread details
  final ThreadService _threadService;

  /// Current thread being viewed
  Thread? _thread;

  /// Messages in the current conversation
  List<Message> _messages = [];

  /// Text accumulated during streaming
  String _streamingText = '';

  /// Status message (e.g., "Searching documents...")
  String? _statusMessage;

  /// Whether AI is currently streaming a response
  bool _isStreaming = false;

  /// Loading state for initial thread load
  bool _loading = false;

  /// Error message if something failed
  String? _error;

  ConversationProvider({
    AIService? aiService,
    ThreadService? threadService,
  })  : _aiService = aiService ?? AIService(),
        _threadService = threadService ?? ThreadService();

  /// Current thread
  Thread? get thread => _thread;

  /// Messages in conversation
  List<Message> get messages => _messages;

  /// Text being streamed from AI
  String get streamingText => _streamingText;

  /// Status message during tool execution
  String? get statusMessage => _statusMessage;

  /// Whether AI is streaming
  bool get isStreaming => _isStreaming;

  /// Whether loading thread
  bool get loading => _loading;

  /// Error message
  String? get error => _error;

  /// Load a thread with its message history
  Future<void> loadThread(String threadId) async {
    _loading = true;
    _error = null;
    notifyListeners();

    try {
      _thread = await _threadService.getThread(threadId);
      _messages = _thread?.messages ?? [];
      _loading = false;
      notifyListeners();
    } catch (e) {
      _error = e.toString();
      _loading = false;
      notifyListeners();
      rethrow;
    }
  }

  /// Send a message and stream the AI response
  Future<void> sendMessage(String content) async {
    if (_thread == null || _isStreaming) return;

    _error = null;

    // Add user message optimistically (will be confirmed by refresh)
    final userMessage = Message(
      id: 'temp-${DateTime.now().millisecondsSinceEpoch}',
      role: MessageRole.user,
      content: content,
      createdAt: DateTime.now(),
    );
    _messages.add(userMessage);

    // Start streaming
    _isStreaming = true;
    _streamingText = '';
    _statusMessage = null;
    notifyListeners();

    try {
      await for (final event in _aiService.streamChat(_thread!.id, content)) {
        if (event is TextDeltaEvent) {
          _streamingText += event.text;
          notifyListeners();
        } else if (event is ToolExecutingEvent) {
          _statusMessage = event.status;
          notifyListeners();
        } else if (event is MessageCompleteEvent) {
          // Add assistant message to list
          final assistantMessage = Message(
            id: 'temp-assistant-${DateTime.now().millisecondsSinceEpoch}',
            role: MessageRole.assistant,
            content: _streamingText.isNotEmpty ? _streamingText : event.content,
            createdAt: DateTime.now(),
          );
          _messages.add(assistantMessage);

          // Clear streaming state
          _isStreaming = false;
          _streamingText = '';
          _statusMessage = null;
          notifyListeners();

          // Optionally refresh thread to get server-confirmed messages
          // await loadThread(_thread!.id);
        } else if (event is ErrorEvent) {
          _error = event.message;
          _isStreaming = false;
          _streamingText = '';
          _statusMessage = null;
          notifyListeners();
        }
      }
    } catch (e) {
      _error = e.toString();
      _isStreaming = false;
      _streamingText = '';
      _statusMessage = null;
      notifyListeners();
    }
  }

  /// Clear current conversation state
  void clearConversation() {
    _thread = null;
    _messages = [];
    _streamingText = '';
    _statusMessage = null;
    _isStreaming = false;
    _error = null;
    _loading = false;
    notifyListeners();
  }

  /// Clear error message
  void clearError() {
    _error = null;
    notifyListeners();
  }
}
```

2. Register ConversationProvider in main.dart. Find the MultiProvider widget and add:

```dart
import 'providers/conversation_provider.dart';
// ... in MultiProvider providers list:
ChangeNotifierProvider(create: (_) => ConversationProvider()),
```
  </action>
  <verify>
1. Run `flutter analyze lib/providers/conversation_provider.dart` - should pass
2. Check main.dart compiles: `flutter analyze lib/main.dart`
  </verify>
  <done>
ConversationProvider manages streaming state with loadThread, sendMessage, and exposes streamingText, isStreaming, statusMessage for UI binding.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create conversation UI with streaming messages</name>
  <files>
    frontend/lib/screens/conversation/conversation_screen.dart
    frontend/lib/screens/conversation/widgets/message_bubble.dart
    frontend/lib/screens/conversation/widgets/streaming_message.dart
    frontend/lib/screens/conversation/widgets/chat_input.dart
    frontend/lib/screens/threads/thread_list_screen.dart
  </files>
  <action>
1. Create frontend/lib/screens/conversation/widgets/message_bubble.dart:

```dart
/// Message bubble widget for displaying conversation messages.
library;

import 'package:flutter/material.dart';

import '../../../models/message.dart';

/// Message bubble displaying user or assistant message
class MessageBubble extends StatelessWidget {
  /// The message to display
  final Message message;

  const MessageBubble({super.key, required this.message});

  @override
  Widget build(BuildContext context) {
    final isUser = message.role == MessageRole.user;
    final theme = Theme.of(context);

    return Align(
      alignment: isUser ? Alignment.centerRight : Alignment.centerLeft,
      child: Container(
        constraints: BoxConstraints(
          maxWidth: MediaQuery.of(context).size.width * 0.8,
        ),
        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: isUser
              ? theme.colorScheme.primary
              : theme.colorScheme.surfaceContainerHighest,
          borderRadius: BorderRadius.only(
            topLeft: const Radius.circular(16),
            topRight: const Radius.circular(16),
            bottomLeft: Radius.circular(isUser ? 16 : 4),
            bottomRight: Radius.circular(isUser ? 4 : 16),
          ),
        ),
        child: SelectableText(
          message.content,
          style: TextStyle(
            color: isUser
                ? theme.colorScheme.onPrimary
                : theme.colorScheme.onSurface,
          ),
        ),
      ),
    );
  }
}
```

2. Create frontend/lib/screens/conversation/widgets/streaming_message.dart:

```dart
/// Streaming message widget showing AI response in progress.
library;

import 'package:flutter/material.dart';

/// Widget displaying streaming AI response with typing indicator
class StreamingMessage extends StatelessWidget {
  /// Text accumulated so far
  final String text;

  /// Optional status message (e.g., "Searching documents...")
  final String? statusMessage;

  const StreamingMessage({
    super.key,
    required this.text,
    this.statusMessage,
  });

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Align(
      alignment: Alignment.centerLeft,
      child: Container(
        constraints: BoxConstraints(
          maxWidth: MediaQuery.of(context).size.width * 0.8,
        ),
        margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 4),
        padding: const EdgeInsets.all(12),
        decoration: BoxDecoration(
          color: theme.colorScheme.surfaceContainerHighest,
          borderRadius: const BorderRadius.only(
            topLeft: Radius.circular(16),
            topRight: Radius.circular(16),
            bottomLeft: Radius.circular(4),
            bottomRight: Radius.circular(16),
          ),
        ),
        child: Column(
          crossAxisAlignment: CrossAxisAlignment.start,
          mainAxisSize: MainAxisSize.min,
          children: [
            if (statusMessage != null) ...[
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  SizedBox(
                    width: 12,
                    height: 12,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      color: theme.colorScheme.primary,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    statusMessage!,
                    style: TextStyle(
                      fontStyle: FontStyle.italic,
                      color: theme.colorScheme.onSurfaceVariant,
                      fontSize: 12,
                    ),
                  ),
                ],
              ),
              if (text.isNotEmpty) const SizedBox(height: 8),
            ],
            if (text.isNotEmpty)
              SelectableText(
                text,
                style: TextStyle(color: theme.colorScheme.onSurface),
              )
            else if (statusMessage == null)
              Row(
                mainAxisSize: MainAxisSize.min,
                children: [
                  SizedBox(
                    width: 16,
                    height: 16,
                    child: CircularProgressIndicator(
                      strokeWidth: 2,
                      color: theme.colorScheme.primary,
                    ),
                  ),
                  const SizedBox(width: 8),
                  Text(
                    'Thinking...',
                    style: TextStyle(
                      fontStyle: FontStyle.italic,
                      color: theme.colorScheme.onSurfaceVariant,
                    ),
                  ),
                ],
              ),
          ],
        ),
      ),
    );
  }
}
```

3. Create frontend/lib/screens/conversation/widgets/chat_input.dart:

```dart
/// Chat input widget for sending messages.
library;

import 'package:flutter/material.dart';

/// Text input bar for sending chat messages
class ChatInput extends StatefulWidget {
  /// Callback when message is sent
  final void Function(String message) onSend;

  /// Whether input is enabled
  final bool enabled;

  const ChatInput({
    super.key,
    required this.onSend,
    this.enabled = true,
  });

  @override
  State<ChatInput> createState() => _ChatInputState();
}

class _ChatInputState extends State<ChatInput> {
  final TextEditingController _controller = TextEditingController();
  final FocusNode _focusNode = FocusNode();

  void _handleSend() {
    final text = _controller.text.trim();
    if (text.isEmpty || !widget.enabled) return;

    widget.onSend(text);
    _controller.clear();
    _focusNode.requestFocus();
  }

  @override
  void dispose() {
    _controller.dispose();
    _focusNode.dispose();
    super.dispose();
  }

  @override
  Widget build(BuildContext context) {
    final theme = Theme.of(context);

    return Container(
      padding: const EdgeInsets.all(8),
      decoration: BoxDecoration(
        color: theme.colorScheme.surface,
        border: Border(
          top: BorderSide(color: theme.colorScheme.outlineVariant),
        ),
      ),
      child: SafeArea(
        child: Row(
          crossAxisAlignment: CrossAxisAlignment.end,
          children: [
            Expanded(
              child: TextField(
                controller: _controller,
                focusNode: _focusNode,
                enabled: widget.enabled,
                maxLines: 5,
                minLines: 1,
                textCapitalization: TextCapitalization.sentences,
                decoration: InputDecoration(
                  hintText: widget.enabled
                      ? 'Type a message...'
                      : 'Waiting for response...',
                  border: OutlineInputBorder(
                    borderRadius: BorderRadius.circular(24),
                    borderSide: BorderSide.none,
                  ),
                  filled: true,
                  fillColor: theme.colorScheme.surfaceContainerHighest,
                  contentPadding: const EdgeInsets.symmetric(
                    horizontal: 16,
                    vertical: 10,
                  ),
                ),
                onSubmitted: (_) => _handleSend(),
              ),
            ),
            const SizedBox(width: 8),
            IconButton.filled(
              onPressed: widget.enabled ? _handleSend : null,
              icon: const Icon(Icons.send),
              tooltip: 'Send message',
            ),
          ],
        ),
      ),
    );
  }
}
```

4. Create frontend/lib/screens/conversation/conversation_screen.dart:

```dart
/// Conversation screen for AI-powered chat.
library;

import 'package:flutter/material.dart';
import 'package:provider/provider.dart';

import '../../providers/conversation_provider.dart';
import 'widgets/chat_input.dart';
import 'widgets/message_bubble.dart';
import 'widgets/streaming_message.dart';

/// Main conversation screen with message list and input
class ConversationScreen extends StatefulWidget {
  /// Thread ID to display
  final String threadId;

  const ConversationScreen({super.key, required this.threadId});

  @override
  State<ConversationScreen> createState() => _ConversationScreenState();
}

class _ConversationScreenState extends State<ConversationScreen> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    // Load thread on mount
    WidgetsBinding.instance.addPostFrameCallback((_) {
      context.read<ConversationProvider>().loadThread(widget.threadId);
    });
  }

  @override
  void dispose() {
    _scrollController.dispose();
    // Clear conversation state when leaving
    context.read<ConversationProvider>().clearConversation();
    super.dispose();
  }

  void _scrollToBottom() {
    if (_scrollController.hasClients) {
      _scrollController.animateTo(
        _scrollController.position.maxScrollExtent,
        duration: const Duration(milliseconds: 300),
        curve: Curves.easeOut,
      );
    }
  }

  @override
  Widget build(BuildContext context) {
    return Consumer<ConversationProvider>(
      builder: (context, provider, child) {
        // Scroll to bottom when messages change
        WidgetsBinding.instance.addPostFrameCallback((_) {
          if (provider.messages.isNotEmpty || provider.isStreaming) {
            _scrollToBottom();
          }
        });

        return Scaffold(
          appBar: AppBar(
            title: Text(provider.thread?.title ?? 'New Conversation'),
          ),
          body: Column(
            children: [
              // Error banner
              if (provider.error != null)
                MaterialBanner(
                  content: Text(provider.error!),
                  backgroundColor: Theme.of(context).colorScheme.errorContainer,
                  actions: [
                    TextButton(
                      onPressed: provider.clearError,
                      child: const Text('Dismiss'),
                    ),
                  ],
                ),

              // Message list
              Expanded(
                child: provider.loading
                    ? const Center(child: CircularProgressIndicator())
                    : _buildMessageList(provider),
              ),

              // Chat input
              ChatInput(
                onSend: provider.sendMessage,
                enabled: !provider.isStreaming,
              ),
            ],
          ),
        );
      },
    );
  }

  Widget _buildMessageList(ConversationProvider provider) {
    final messages = provider.messages;

    if (messages.isEmpty && !provider.isStreaming) {
      return Center(
        child: Padding(
          padding: const EdgeInsets.all(32),
          child: Column(
            mainAxisAlignment: MainAxisAlignment.center,
            children: [
              Icon(
                Icons.chat_bubble_outline,
                size: 64,
                color: Theme.of(context).colorScheme.outline,
              ),
              const SizedBox(height: 16),
              Text(
                'Start a conversation',
                style: Theme.of(context).textTheme.titleMedium,
              ),
              const SizedBox(height: 8),
              Text(
                'Ask about your requirements and I\'ll help identify edge cases, suggest clarifications, and reference your project documents.',
                textAlign: TextAlign.center,
                style: TextStyle(
                  color: Theme.of(context).colorScheme.onSurfaceVariant,
                ),
              ),
            ],
          ),
        ),
      );
    }

    return ListView.builder(
      controller: _scrollController,
      padding: const EdgeInsets.symmetric(vertical: 16),
      itemCount: messages.length + (provider.isStreaming ? 1 : 0),
      itemBuilder: (context, index) {
        // Streaming message at the end
        if (provider.isStreaming && index == messages.length) {
          return StreamingMessage(
            text: provider.streamingText,
            statusMessage: provider.statusMessage,
          );
        }

        return MessageBubble(message: messages[index]);
      },
    );
  }
}
```

5. Update frontend/lib/screens/threads/thread_list_screen.dart to navigate to ConversationScreen.

Find the thread card's onTap handler and update it to navigate:

```dart
import '../conversation/conversation_screen.dart';

// In the thread card onTap:
onTap: () {
  Navigator.push(
    context,
    MaterialPageRoute(
      builder: (context) => ConversationScreen(threadId: thread.id),
    ),
  );
},
```
  </action>
  <verify>
1. Run `flutter analyze lib/screens/conversation/` - should pass with no errors
2. Run `flutter build web --no-tree-shake-icons` - should complete successfully
3. Manual test: Navigate to a project, tap a thread, should open ConversationScreen
  </verify>
  <done>
ConversationScreen displays message history, shows streaming AI responses progressively, has chat input for sending messages, and navigates from thread list.
  </done>
</task>

</tasks>

<verification>
1. flutter pub get succeeds with flutter_client_sse
2. All Dart files pass flutter analyze
3. App builds without errors
4. Thread tap navigates to ConversationScreen
5. Typing message and sending triggers SSE connection (network tab shows request)
6. AI response text streams progressively on screen
7. Message history shows user and assistant messages
</verification>

<success_criteria>
- flutter_client_sse added to pubspec.yaml
- AIService.streamChat yields ChatEvent objects from SSE
- ConversationProvider manages streaming state with isStreaming, streamingText
- ConversationScreen shows message list with MessageBubble widgets
- StreamingMessage shows typing indicator and progressive text
- ChatInput enables/disables during streaming
- Thread tap from list opens conversation screen
- Messages display correctly (user right-aligned, assistant left-aligned)
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-powered-conversations/03-03-SUMMARY.md`
</output>
