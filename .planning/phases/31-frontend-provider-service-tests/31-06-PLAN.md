---
phase: 31-frontend-provider-service-tests
plan: 06
type: execute
wave: 2
depends_on: []
files_modified:
  - frontend/test/unit/services/document_service_test.dart
  - frontend/test/unit/services/document_service_test.mocks.dart
  - frontend/test/unit/services/thread_service_test.dart
  - frontend/test/unit/services/thread_service_test.mocks.dart
  - frontend/test/unit/services/ai_service_test.dart
  - frontend/test/unit/services/ai_service_test.mocks.dart
autonomous: true

must_haves:
  truths:
    - "DocumentService tests verify upload with progress tracking"
    - "ThreadService tests verify thread CRUD and global thread operations"
    - "AIService tests verify stream setup (basic coverage without full SSE testing)"
  artifacts:
    - path: "frontend/test/unit/services/document_service_test.dart"
      provides: "DocumentService unit tests"
      min_lines: 150
    - path: "frontend/test/unit/services/thread_service_test.dart"
      provides: "ThreadService unit tests"
      min_lines: 150
    - path: "frontend/test/unit/services/ai_service_test.dart"
      provides: "AIService unit tests"
      min_lines: 80
  key_links:
    - from: "document_service_test.dart"
      to: "DocumentService"
      via: "MockDio with multipart and progress callback"
      pattern: "MockDio"
---

<objective>
Create unit tests for DocumentService, ThreadService, and AIService.

Purpose: Complete service test coverage (FSVC-01 partial - HTTP patterns, FSVC-02 companion services). DocumentService has upload progress, ThreadService has pagination, AIService has SSE streaming.

Output: Three service test files completing the service test suite.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-frontend-provider-service-tests/31-RESEARCH.md

# Source files under test
@frontend/lib/services/document_service.dart
@frontend/lib/services/thread_service.dart
@frontend/lib/services/ai_service.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: DocumentService unit tests</name>
  <files>
    frontend/test/unit/services/document_service_test.dart
  </files>
  <action>
Create comprehensive unit tests for DocumentService.

First, read document_service.dart to understand its exact API.

Use @GenerateNiceMocks([MockSpec<Dio>(), MockSpec<FlutterSecureStorage>()]) annotation.

Test groups to implement:

1. **getDocuments()**:
   - Makes GET request to /projects/{projectId}/documents
   - Returns list of Document objects
   - Handles empty list

2. **uploadDocument()**:
   - Creates FormData with file bytes and filename
   - Makes POST request to /projects/{projectId}/documents
   - Invokes onSendProgress callback during upload
   - Returns created Document object

3. **getDocumentContent()**:
   - Makes GET request to /documents/{id}/content
   - Returns Document with content field populated

4. **searchDocuments()**:
   - Makes GET request to /projects/{projectId}/documents/search?q={query}
   - Returns list of DocumentSearchResult objects
   - Handles empty results

5. **deleteDocument()**:
   - Makes DELETE request to /documents/{id}
   - Returns void on success

Test upload progress callback:
```dart
test('uploadDocument invokes progress callback', () async {
  when(mockStorage.read(key: 'auth_token'))
      .thenAnswer((_) async => 'test-token');

  ProgressCallback? capturedProgress;
  when(mockDio.post(
    any,
    data: anyNamed('data'),
    options: anyNamed('options'),
    onSendProgress: anyNamed('onSendProgress'),
  )).thenAnswer((invocation) async {
    capturedProgress = invocation.namedArguments[#onSendProgress] as ProgressCallback?;
    // Simulate progress
    capturedProgress?.call(50, 100);
    capturedProgress?.call(100, 100);
    return Response(
      data: {
        'id': 'doc-1',
        'filename': 'test.txt',
        'project_id': 'proj-1',
        'created_at': DateTime.now().toIso8601String(),
      },
      statusCode: 201,
      requestOptions: RequestOptions(path: ''),
    );
  });

  var progressValues = <double>[];
  await service.uploadDocument(
    'proj-1',
    [1, 2, 3],
    'test.txt',
    onSendProgress: (sent, total) => progressValues.add(sent / total),
  );

  expect(progressValues, contains(0.5));
  expect(progressValues, contains(1.0));
});
```

Note: uploadDocument likely creates MultipartFile, so verify FormData is used in the request.
  </action>
  <verify>
Run: `cd frontend && flutter test test/unit/services/document_service_test.dart -v`
All tests pass.
  </verify>
  <done>
DocumentService has unit test coverage including upload progress callback.
  </done>
</task>

<task type="auto">
  <name>Task 2: ThreadService unit tests</name>
  <files>
    frontend/test/unit/services/thread_service_test.dart
  </files>
  <action>
Create comprehensive unit tests for ThreadService.

First, read thread_service.dart to understand its exact API (including PaginatedThreads).

Use @GenerateNiceMocks([MockSpec<Dio>(), MockSpec<FlutterSecureStorage>()]) annotation.

Test groups to implement:

1. **getThreads(projectId)**:
   - Makes GET request to /projects/{projectId}/threads
   - Returns list of Thread objects

2. **createThread(projectId, title, provider)**:
   - Makes POST request to /projects/{projectId}/threads
   - Sends optional title and modelProvider in body
   - Returns created Thread object

3. **getThread(threadId)**:
   - Makes GET request to /threads/{threadId}
   - Returns Thread object with messages array
   - Throws "not found" on 404

4. **deleteThread(threadId)**:
   - Makes DELETE request to /threads/{threadId}

5. **renameThread(threadId, title)**:
   - Makes PUT request to /threads/{threadId}
   - Returns updated Thread object

6. **getGlobalThreads(page)**:
   - Makes GET request to /threads?page={page}
   - Returns PaginatedThreads object with threads, total, page, pageSize, hasMore

7. **createGlobalThread(title, projectId, modelProvider)**:
   - Makes POST request to /threads
   - Sends optional parameters in body
   - Returns created Thread object

8. **associateWithProject(threadId, projectId)**:
   - Makes POST request to /threads/{threadId}/associate
   - Sends projectId in body

Test PaginatedThreads parsing:
```dart
test('getGlobalThreads returns PaginatedThreads', () async {
  when(mockStorage.read(key: 'auth_token'))
      .thenAnswer((_) async => 'test-token');
  when(mockDio.get(
    contains('/threads'),
    queryParameters: anyNamed('queryParameters'),
    options: anyNamed('options'),
  )).thenAnswer((_) async => Response(
    data: {
      'threads': [
        {'id': 't1', 'title': 'Thread 1', 'created_at': '2024-01-01T00:00:00Z', 'updated_at': '2024-01-01T00:00:00Z'},
      ],
      'total': 25,
      'page': 1,
      'page_size': 25,
      'has_more': false,
    },
    statusCode: 200,
    requestOptions: RequestOptions(path: ''),
  ));

  final result = await service.getGlobalThreads(page: 1);

  expect(result.threads.length, equals(1));
  expect(result.total, equals(25));
  expect(result.hasMore, isFalse);
});
```
  </action>
  <verify>
Run: `cd frontend && flutter test test/unit/services/thread_service_test.dart -v`
All tests pass.
  </verify>
  <done>
ThreadService has unit test coverage including pagination and global thread operations.
  </done>
</task>

<task type="auto">
  <name>Task 3: AIService unit tests and generate all service mocks</name>
  <files>
    frontend/test/unit/services/ai_service_test.dart
    frontend/test/unit/services/document_service_test.mocks.dart
    frontend/test/unit/services/thread_service_test.mocks.dart
    frontend/test/unit/services/ai_service_test.mocks.dart
  </files>
  <action>
Create unit tests for AIService (limited scope due to SSE complexity).

First, read ai_service.dart to understand its structure.

Use @GenerateNiceMocks([MockSpec<Dio>(), MockSpec<FlutterSecureStorage>()]) annotation.

AIService has SSE streaming which is difficult to unit test without real infrastructure. Focus on:

1. **Constructor injection**:
   - Service accepts optional Dio, FlutterSecureStorage, baseUrl parameters

2. **deleteMessage()**:
   - Makes DELETE request to /threads/{threadId}/messages/{messageId}
   - Returns void on success
   - Throws exception on error

3. **streamChat() setup** (partial):
   - Verify the method exists and accepts threadId and message parameters
   - Note: Full SSE testing requires integration tests or complex mocking of flutter_client_sse
   - Document that SSE streaming is better tested at integration level

Test deleteMessage:
```dart
test('deleteMessage sends DELETE request', () async {
  when(mockStorage.read(key: 'auth_token'))
      .thenAnswer((_) async => 'test-token');
  when(mockDio.delete(
    'http://test.api/threads/t1/messages/m1',
    options: anyNamed('options'),
  )).thenAnswer((_) async => Response(
    statusCode: 204,
    requestOptions: RequestOptions(path: ''),
  ));

  await service.deleteMessage('t1', 'm1');

  verify(mockDio.delete(
    'http://test.api/threads/t1/messages/m1',
    options: anyNamed('options'),
  )).called(1);
});
```

**SSE Testing Limitation Note:**
The streamChat method uses flutter_client_sse's SSEClient which cannot be easily mocked without significant infrastructure. The SSE streaming behavior is effectively tested through:
1. ConversationProvider tests (which mock AIService.streamChat)
2. Integration tests (manual testing)

Add a comment in the test file documenting this limitation.

**Generate all service mocks:**
```bash
cd frontend
flutter pub run build_runner build --delete-conflicting-outputs
```

Run all unit tests to verify everything works together.
  </action>
  <verify>
Run: `cd frontend && flutter test test/unit/services/ -v`
Run: `cd frontend && flutter test test/unit/ -v`
All unit tests pass.
  </verify>
  <done>
AIService has basic coverage, SSE limitation documented, all service mocks generated, all unit tests pass.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && flutter test test/unit/services/document_service_test.dart` - DocumentService tests pass
2. `cd frontend && flutter test test/unit/services/thread_service_test.dart` - ThreadService tests pass
3. `cd frontend && flutter test test/unit/services/ai_service_test.dart` - AIService tests pass
4. Upload progress callback tested
5. Pagination (PaginatedThreads) tested
6. All unit tests pass: `cd frontend && flutter test test/unit/`
</verification>

<success_criteria>
- DocumentService has 10+ test cases including upload progress
- ThreadService has 12+ test cases including pagination
- AIService has 3+ test cases for non-SSE methods
- SSE streaming limitation is documented in code comments
- All unit tests pass with `flutter test test/unit/`
</success_criteria>

<output>
After completion, create `.planning/phases/31-frontend-provider-service-tests/31-06-SUMMARY.md`
</output>
