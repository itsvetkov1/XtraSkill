---
phase: 48-frontend-to-backend-flush
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/lib/services/logging_service.dart
  - frontend/lib/providers/auth_provider.dart
autonomous: true

must_haves:
  truths:
    - "Frontend logs are sent to backend via POST /api/logs/ingest"
    - "Logs flush every 5 minutes while app is active"
    - "Logs flush when app goes to background (pause event)"
    - "Logs flush when app terminates (detach event)"
    - "Buffer remains intact if flush fails (network down, not authenticated)"
    - "Logs flush before logout to capture final session events"
  artifacts:
    - path: "frontend/lib/services/logging_service.dart"
      provides: "flush() method, AppLifecycleListener, Timer.periodic"
      exports: ["flush"]
    - path: "frontend/lib/providers/auth_provider.dart"
      provides: "flush-before-logout call"
  key_links:
    - from: "frontend/lib/services/logging_service.dart"
      to: "/api/logs/ingest"
      via: "ApiClient().dio.post with Bearer token"
      pattern: "dio\\.post.*logs/ingest"
    - from: "frontend/lib/services/logging_service.dart"
      to: "AppLifecycleListener"
      via: "onPause and onDetach callbacks"
      pattern: "AppLifecycleListener"
    - from: "frontend/lib/providers/auth_provider.dart"
      to: "LoggingService().flush()"
      via: "await before token deletion"
      pattern: "flush.*logout"
---

<objective>
Implement log flushing mechanism that sends buffered frontend logs to backend for centralized storage.

Purpose: Complete the logging pipeline by connecting frontend log buffer to backend ingest endpoint, enabling AI-powered debugging during pilot testing.

Output: LoggingService with flush() method, lifecycle-triggered flush, periodic flush, and logout flush integration.
</objective>

<execution_context>
@C:\Users\ibcve\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ibcve\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/48-frontend-to-backend-flush/48-RESEARCH.md
@frontend/lib/services/logging_service.dart
@frontend/lib/services/api_client.dart
@frontend/lib/providers/auth_provider.dart
@backend/app/routes/logs.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add flush() method and lifecycle integration to LoggingService</name>
  <files>frontend/lib/services/logging_service.dart</files>
  <action>
Update LoggingService to add flush capability with lifecycle integration:

1. Add imports:
   - `import 'package:dio/dio.dart';`
   - `import 'package:flutter/widgets.dart';` (for AppLifecycleListener)
   - `import 'package:flutter_secure_storage/flutter_secure_storage.dart';`
   - `import 'api_client.dart';`

2. Add fields:
   - `AppLifecycleListener? _lifecycleListener;`
   - `final FlutterSecureStorage _storage = const FlutterSecureStorage();`
   - `static const String _tokenKey = 'auth_token';`
   - `static const int _defaultFlushIntervalMinutes = 5;`
   - `bool _isFlushInProgress = false;`

3. Update init() method:
   - Uncomment and activate `_flushTimer` with 5-minute interval
   - Create `AppLifecycleListener` with `onPause` and `onDetach` callbacks that call `flush()`

4. Add flush() method:
   ```dart
   /// Flush buffered logs to backend
   ///
   /// Sends all buffered logs to POST /api/logs/ingest endpoint.
   /// On success, clears sent logs from buffer.
   /// On failure, keeps logs for retry (in-memory persistence).
   Future<void> flush() async {
     // Skip if empty, disabled, or already flushing
     if (_buffer.isEmpty) return;
     if (!_isEnabled) return;
     if (_isFlushInProgress) return;

     // Check network connectivity (already monitoring in init)
     final connectivity = await Connectivity().checkConnectivity();
     if (connectivity.contains(ConnectivityResult.none)) {
       debugPrint('[LoggingService] Skipping flush - no network');
       return;
     }

     // Check authentication
     final token = await _storage.read(key: _tokenKey);
     if (token == null) {
       debugPrint('[LoggingService] Skipping flush - not authenticated');
       return;
     }

     _isFlushInProgress = true;

     try {
       // Copy buffer to avoid mutation during async POST
       final logsToSend = List<Map<String, dynamic>>.from(_buffer);

       await ApiClient().dio.post(
         '/api/logs/ingest',
         data: {'logs': logsToSend},
         options: Options(
           headers: {'Authorization': 'Bearer $token'},
           sendTimeout: const Duration(seconds: 10),
           receiveTimeout: const Duration(seconds: 10),
         ),
       );

       // Success - remove sent logs from buffer
       _buffer.removeRange(0, logsToSend.length);
       debugPrint('[LoggingService] Flushed ${logsToSend.length} logs');

     } catch (e) {
       // Silent fail - logs remain in buffer for retry
       // Use debugPrint to avoid infinite loop (not logError)
       debugPrint('[LoggingService] Flush failed: $e');
     } finally {
       _isFlushInProgress = false;
     }
   }
   ```

5. Update dispose() method:
   - Add `_lifecycleListener?.dispose();`
   - Keep existing `_flushTimer?.cancel()` and `_connectivitySubscription?.cancel()`

CRITICAL ANTI-PATTERNS (from research):
- DO NOT use logError() for flush failures (causes infinite loop)
- DO NOT clear entire buffer on failure (lose logs)
- DO NOT attempt flush without token check (401 spam)
- DO copy buffer before POST (prevents mutation during async)
  </action>
  <verify>
Run `flutter analyze frontend` - no errors.
Check that logging_service.dart contains:
- `AppLifecycleListener` instantiation in init()
- `flush()` method with token check and POST call
- Timer.periodic with 5-minute interval
  </verify>
  <done>
LoggingService has flush() method that:
- POSTs buffer to /api/logs/ingest with Bearer token
- Triggers on 5-minute interval via Timer.periodic
- Triggers on app pause/detach via AppLifecycleListener
- Preserves buffer on flush failure
- Uses debugPrint for flush errors (not logError)
  </done>
</task>

<task type="auto">
  <name>Task 2: Add flush-before-logout to AuthProvider</name>
  <files>frontend/lib/providers/auth_provider.dart</files>
  <action>
Update AuthProvider.logout() to flush logs before clearing authentication:

1. Add import:
   - `import '../services/logging_service.dart';`

2. Modify logout() method to call flush() before clearing token:
   ```dart
   Future<void> logout() async {
     _state = AuthState.loading;
     notifyListeners();

     try {
       // Flush logs before logout to capture final session events
       await LoggingService().flush();
     } catch (e) {
       // Ignore flush errors - proceed with logout
       debugPrint('Flush before logout failed: $e');
     }

     try {
       await _authService.logout();
       // ... rest of existing logout logic
     } catch (e) {
       // ... existing error handling
     }
     // ... rest of existing code
   }
   ```

The key changes:
- Add try/catch around flush() call BEFORE _authService.logout()
- Use debugPrint for errors (not logError - avoid infinite loop)
- Don't block logout if flush fails

Why: Captures final session logs (logout action, any pending logs) before user session ends.
  </action>
  <verify>
Run `flutter analyze frontend` - no errors.
Check that auth_provider.dart contains LoggingService import and flush() call in logout().
  </verify>
  <done>
AuthProvider.logout() calls LoggingService().flush() before clearing auth token, ensuring final session logs are captured.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify flush integration with manual test</name>
  <files></files>
  <action>
Verify the flush mechanism works end-to-end:

1. Build and run the app:
   ```bash
   cd frontend && flutter run -d chrome
   ```

2. Login to the app (authenticate)

3. Navigate around (generates navigation logs) - visit Home, Projects, Settings

4. Check browser console for "[LoggingService] Flushed X logs" message:
   - Wait 5 minutes for timer flush, OR
   - Switch browser tab (triggers pause event on some browsers), OR
   - Close browser tab (triggers detach)

5. Check backend logs for ingested frontend logs:
   ```bash
   # In another terminal
   cat backend/logs/app.log | grep "[FRONTEND]" | tail -20
   ```

If logs appear in backend with [FRONTEND] prefix, flush is working.

Alternative quick test (optional):
- Add temporary button to Settings screen that calls LoggingService().flush()
- Click button after navigating around
- Check backend logs immediately

Note: This is a verification step, not a code change. Document observations.
  </action>
  <verify>
Backend logs contain [FRONTEND] prefixed entries with navigation/action/error categories.
Browser console shows "[LoggingService] Flushed N logs" debug message.
  </verify>
  <done>
Flush mechanism verified working:
- Timer flush triggers every 5 minutes
- Lifecycle flush triggers on app pause/detach
- Logout flush captures final session logs
- Backend receives and stores frontend logs with [FRONTEND] prefix
  </done>
</task>

</tasks>

<verification>
Phase verification:
1. `flutter analyze frontend` passes with no errors
2. LoggingService.flush() exists and POSTs to /api/logs/ingest
3. AppLifecycleListener created in init() with onPause/onDetach
4. Timer.periodic set to 5 minutes in init()
5. AuthProvider.logout() calls flush() before token deletion
6. Backend logs show [FRONTEND] entries after app usage

Regression check:
- App still starts without errors
- Login/logout still works
- Navigation logging still works (console output)
- Settings toggle still enables/disables logging
</verification>

<success_criteria>
FLOG-08: Frontend logs are sent to backend for centralized storage
- [x] POST /api/logs/ingest called with buffered logs
- [x] Bearer token included in request
- [x] Buffer cleared only on successful POST

SLOG-05: Frontend flush interval is configurable (default: 5 minutes)
- [x] Timer.periodic uses 5-minute default interval
- [x] Interval defined as constant (code-configurable)

Roadmap success criteria:
1. [x] Frontend logs sent to backend via POST /api/logs/ingest
2. [x] Logs flush on configurable interval (default: 5 minutes)
3. [x] Logs flush on app lifecycle events (pause, terminate)
4. [x] Buffered logs persist until successfully delivered
</success_criteria>

<output>
After completion, create `.planning/phases/48-frontend-to-backend-flush/48-01-SUMMARY.md`
</output>
