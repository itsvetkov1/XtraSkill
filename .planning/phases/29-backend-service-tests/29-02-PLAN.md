---
phase: 29-backend-service-tests
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/tests/unit/services/test_conversation_service_db.py
  - backend/tests/unit/services/test_token_tracking_db.py
  - backend/tests/unit/services/test_document_search.py
  - backend/tests/unit/services/test_encryption.py
autonomous: true

must_haves:
  truths:
    - "Database operations can be tested with in-memory SQLite"
    - "Message saving updates thread timestamp"
    - "Token usage is persisted and aggregated correctly"
    - "Document search returns relevant results"
    - "Encryption roundtrip preserves content"
  artifacts:
    - path: "backend/tests/unit/services/test_conversation_service_db.py"
      provides: "Database function tests for conversation_service"
      min_lines: 80
    - path: "backend/tests/unit/services/test_token_tracking_db.py"
      provides: "Database function tests for token_tracking"
      min_lines: 60
    - path: "backend/tests/unit/services/test_document_search.py"
      provides: "FTS5 document search tests"
      min_lines: 60
    - path: "backend/tests/unit/services/test_encryption.py"
      provides: "Encryption service tests"
      min_lines: 40
  key_links:
    - from: "test files"
      to: "db_session fixture"
      via: "pytest fixture injection"
      pattern: "async def test_.*db_session"
    - from: "test files"
      to: "factories.py"
      via: "factory fixtures"
      pattern: "user|thread|project"
---

<objective>
Create unit tests for database-dependent functions in conversation_service, token_tracking, document_search, and encryption modules.

Purpose: Cover all database operations in backend services using the Phase 28 fixtures (db_session, factories). This fulfills BSVC-03 (document_service), BSVC-04 (thread_service), BSVC-05 (message_service) requirements.

Output: Test files achieving 80%+ coverage on database functions for these service modules.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-backend-service-tests/29-RESEARCH.md
@backend/app/services/conversation_service.py
@backend/app/services/token_tracking.py
@backend/app/services/document_search.py
@backend/app/services/encryption.py
@backend/tests/fixtures/db_fixtures.py
@backend/tests/fixtures/factories.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create conversation_service database tests</name>
  <files>backend/tests/unit/services/test_conversation_service_db.py</files>
  <action>
Create test file for conversation_service database functions:

```python
"""Unit tests for conversation_service database functions."""

import pytest
from datetime import datetime, timedelta
from app.services.conversation_service import (
    save_message,
    build_conversation_context,
    get_message_count,
)
from app.models import Thread, Message, User, Project


class TestSaveMessage:
    """Tests for save_message function."""

    @pytest.mark.asyncio
    async def test_creates_message_with_correct_attributes(self, db_session, user):
        """Message is created with provided role and content."""
        # Create user and thread in DB
        db_session.add(user)
        await db_session.commit()

        thread = Thread(id="test-thread-1", user_id=user.id, title="Test")
        db_session.add(thread)
        await db_session.commit()

        message = await save_message(db_session, thread.id, "user", "Hello world")

        assert message.thread_id == thread.id
        assert message.role == "user"
        assert message.content == "Hello world"
        assert message.id is not None

    @pytest.mark.asyncio
    async def test_updates_thread_timestamp(self, db_session, user):
        """Saving message updates thread's updated_at timestamp."""
        db_session.add(user)
        await db_session.commit()

        thread = Thread(id="test-thread-2", user_id=user.id, title="Test")
        db_session.add(thread)
        await db_session.commit()

        original_updated_at = thread.updated_at

        # Small delay to ensure timestamp difference
        import asyncio
        await asyncio.sleep(0.1)

        await save_message(db_session, thread.id, "user", "New message")
        await db_session.refresh(thread)

        assert thread.updated_at >= original_updated_at

    @pytest.mark.asyncio
    async def test_assistant_role_saved(self, db_session, user):
        """Assistant messages are saved correctly."""
        db_session.add(user)
        await db_session.commit()

        thread = Thread(id="test-thread-3", user_id=user.id, title="Test")
        db_session.add(thread)
        await db_session.commit()

        message = await save_message(db_session, thread.id, "assistant", "Response")

        assert message.role == "assistant"


class TestBuildConversationContext:
    """Tests for build_conversation_context function."""

    @pytest.mark.asyncio
    async def test_returns_empty_list_for_new_thread(self, db_session, user):
        """New thread with no messages returns empty list."""
        db_session.add(user)
        await db_session.commit()

        thread = Thread(id="test-thread-4", user_id=user.id, title="Empty")
        db_session.add(thread)
        await db_session.commit()

        context = await build_conversation_context(db_session, thread.id)

        assert context == []

    @pytest.mark.asyncio
    async def test_returns_messages_in_chronological_order(self, db_session, user):
        """Messages are returned in chronological order."""
        db_session.add(user)
        await db_session.commit()

        thread = Thread(id="test-thread-5", user_id=user.id, title="Ordered")
        db_session.add(thread)
        await db_session.commit()

        # Create messages with explicit ordering
        msg1 = Message(
            thread_id=thread.id,
            role="user",
            content="First",
            created_at=datetime.utcnow() - timedelta(minutes=2)
        )
        msg2 = Message(
            thread_id=thread.id,
            role="assistant",
            content="Second",
            created_at=datetime.utcnow() - timedelta(minutes=1)
        )
        msg3 = Message(
            thread_id=thread.id,
            role="user",
            content="Third",
            created_at=datetime.utcnow()
        )
        db_session.add_all([msg1, msg2, msg3])
        await db_session.commit()

        context = await build_conversation_context(db_session, thread.id)

        assert len(context) == 3
        assert context[0]["content"] == "First"
        assert context[1]["content"] == "Second"
        assert context[2]["content"] == "Third"

    @pytest.mark.asyncio
    async def test_returns_claude_message_format(self, db_session, user):
        """Messages are converted to Claude API format."""
        db_session.add(user)
        await db_session.commit()

        thread = Thread(id="test-thread-6", user_id=user.id, title="Format")
        db_session.add(thread)
        await db_session.commit()

        msg = Message(thread_id=thread.id, role="user", content="Hello")
        db_session.add(msg)
        await db_session.commit()

        context = await build_conversation_context(db_session, thread.id)

        assert context[0] == {"role": "user", "content": "Hello"}


class TestGetMessageCount:
    """Tests for get_message_count function."""

    @pytest.mark.asyncio
    async def test_returns_zero_for_empty_thread(self, db_session, user):
        """Empty thread returns count of 0."""
        db_session.add(user)
        await db_session.commit()

        thread = Thread(id="test-thread-7", user_id=user.id, title="Empty")
        db_session.add(thread)
        await db_session.commit()

        count = await get_message_count(db_session, thread.id)

        assert count == 0

    @pytest.mark.asyncio
    async def test_returns_correct_count(self, db_session, user):
        """Returns correct message count for thread."""
        db_session.add(user)
        await db_session.commit()

        thread = Thread(id="test-thread-8", user_id=user.id, title="Count")
        db_session.add(thread)
        await db_session.commit()

        for i in range(5):
            msg = Message(thread_id=thread.id, role="user", content=f"Msg {i}")
            db_session.add(msg)
        await db_session.commit()

        count = await get_message_count(db_session, thread.id)

        assert count == 5

    @pytest.mark.asyncio
    async def test_counts_only_thread_messages(self, db_session, user):
        """Only counts messages in specified thread."""
        db_session.add(user)
        await db_session.commit()

        thread1 = Thread(id="test-thread-9a", user_id=user.id, title="Thread 1")
        thread2 = Thread(id="test-thread-9b", user_id=user.id, title="Thread 2")
        db_session.add_all([thread1, thread2])
        await db_session.commit()

        # Add messages to both threads
        for _ in range(3):
            db_session.add(Message(thread_id=thread1.id, role="user", content="T1"))
        for _ in range(7):
            db_session.add(Message(thread_id=thread2.id, role="user", content="T2"))
        await db_session.commit()

        assert await get_message_count(db_session, thread1.id) == 3
        assert await get_message_count(db_session, thread2.id) == 7
```
  </action>
  <verify>
```bash
cd backend && python -m pytest tests/unit/services/test_conversation_service_db.py -v
```
All tests pass.
  </verify>
  <done>11 database tests pass for conversation_service</done>
</task>

<task type="auto">
  <name>Task 2: Create token_tracking database tests</name>
  <files>backend/tests/unit/services/test_token_tracking_db.py</files>
  <action>
Create test file for token_tracking database functions:

```python
"""Unit tests for token_tracking database functions."""

import pytest
from decimal import Decimal
from datetime import datetime, timedelta
from app.services.token_tracking import (
    track_token_usage,
    get_monthly_usage,
    check_user_budget,
    DEFAULT_MONTHLY_BUDGET,
)
from app.models import TokenUsage


class TestTrackTokenUsage:
    """Tests for track_token_usage function."""

    @pytest.mark.asyncio
    async def test_creates_usage_record(self, db_session, user):
        """Creates TokenUsage record with correct attributes."""
        db_session.add(user)
        await db_session.commit()

        usage = await track_token_usage(
            db_session,
            user.id,
            "claude-sonnet-4-5-20250929",
            100,
            50,
            "/api/chat"
        )

        assert usage.user_id == user.id
        assert usage.request_tokens == 100
        assert usage.response_tokens == 50
        assert usage.endpoint == "/api/chat"
        assert usage.model == "claude-sonnet-4-5-20250929"

    @pytest.mark.asyncio
    async def test_calculates_cost_correctly(self, db_session, user):
        """Cost is calculated based on model pricing."""
        db_session.add(user)
        await db_session.commit()

        usage = await track_token_usage(
            db_session,
            user.id,
            "claude-sonnet-4-5-20250929",
            1_000_000,  # $3
            1_000_000,  # $15
            "/api/chat"
        )

        assert usage.total_cost == Decimal("18.00")

    @pytest.mark.asyncio
    async def test_persists_to_database(self, db_session, user):
        """Usage record is persisted and can be queried."""
        db_session.add(user)
        await db_session.commit()

        usage = await track_token_usage(
            db_session,
            user.id,
            "claude-sonnet",
            100,
            50,
            "/api/chat"
        )

        # Query back from DB
        from sqlalchemy import select
        result = await db_session.execute(
            select(TokenUsage).where(TokenUsage.id == usage.id)
        )
        persisted = result.scalar_one()

        assert persisted.request_tokens == 100


class TestGetMonthlyUsage:
    """Tests for get_monthly_usage function."""

    @pytest.mark.asyncio
    async def test_returns_zero_for_new_user(self, db_session, user):
        """New user with no usage returns zeros."""
        db_session.add(user)
        await db_session.commit()

        usage = await get_monthly_usage(db_session, user.id)

        assert usage["total_cost"] == Decimal("0")
        assert usage["total_requests"] == 0
        assert usage["total_input_tokens"] == 0
        assert usage["total_output_tokens"] == 0

    @pytest.mark.asyncio
    async def test_aggregates_multiple_requests(self, db_session, user):
        """Aggregates usage across multiple requests."""
        db_session.add(user)
        await db_session.commit()

        await track_token_usage(db_session, user.id, "claude", 100, 50, "/chat")
        await track_token_usage(db_session, user.id, "claude", 200, 100, "/chat")
        await track_token_usage(db_session, user.id, "claude", 300, 150, "/chat")

        usage = await get_monthly_usage(db_session, user.id)

        assert usage["total_requests"] == 3
        assert usage["total_input_tokens"] == 600
        assert usage["total_output_tokens"] == 300

    @pytest.mark.asyncio
    async def test_includes_budget_info(self, db_session, user):
        """Response includes budget and month_start."""
        db_session.add(user)
        await db_session.commit()

        usage = await get_monthly_usage(db_session, user.id)

        assert "budget" in usage
        assert usage["budget"] == DEFAULT_MONTHLY_BUDGET
        assert "month_start" in usage

    @pytest.mark.asyncio
    async def test_only_includes_current_month(self, db_session, user):
        """Only includes usage from current month."""
        db_session.add(user)
        await db_session.commit()

        # Create usage record for current month
        await track_token_usage(db_session, user.id, "claude", 100, 50, "/chat")

        # Manually create old usage record (last month)
        old_usage = TokenUsage(
            user_id=user.id,
            request_tokens=999,
            response_tokens=999,
            total_cost=Decimal("10.00"),
            endpoint="/old",
            model="claude",
            created_at=datetime.utcnow() - timedelta(days=35)
        )
        db_session.add(old_usage)
        await db_session.commit()

        usage = await get_monthly_usage(db_session, user.id)

        # Should only count current month's 100 tokens
        assert usage["total_input_tokens"] == 100
        assert usage["total_requests"] == 1


class TestCheckUserBudget:
    """Tests for check_user_budget function."""

    @pytest.mark.asyncio
    async def test_returns_true_for_new_user(self, db_session, user):
        """New user is under budget."""
        db_session.add(user)
        await db_session.commit()

        result = await check_user_budget(db_session, user.id)

        assert result is True

    @pytest.mark.asyncio
    async def test_returns_false_when_over_budget(self, db_session, user):
        """Returns False when user exceeds monthly budget."""
        db_session.add(user)
        await db_session.commit()

        # Create large usage that exceeds $50 budget
        # $51 worth of tokens
        usage = TokenUsage(
            user_id=user.id,
            request_tokens=17_000_000,  # ~$51 at $3/1M
            response_tokens=0,
            total_cost=Decimal("51.00"),
            endpoint="/chat",
            model="claude"
        )
        db_session.add(usage)
        await db_session.commit()

        result = await check_user_budget(db_session, user.id)

        assert result is False

    @pytest.mark.asyncio
    async def test_custom_budget_limit(self, db_session, user):
        """Respects custom monthly limit."""
        db_session.add(user)
        await db_session.commit()

        # Add $5 worth of usage
        usage = TokenUsage(
            user_id=user.id,
            request_tokens=1_000_000,
            response_tokens=0,
            total_cost=Decimal("5.00"),
            endpoint="/chat",
            model="claude"
        )
        db_session.add(usage)
        await db_session.commit()

        # With $10 limit, should be under
        assert await check_user_budget(db_session, user.id, Decimal("10.00")) is True

        # With $3 limit, should be over
        assert await check_user_budget(db_session, user.id, Decimal("3.00")) is False
```
  </action>
  <verify>
```bash
cd backend && python -m pytest tests/unit/services/test_token_tracking_db.py -v
```
All tests pass.
  </verify>
  <done>11 database tests pass for token_tracking</done>
</task>

<task type="auto">
  <name>Task 3: Create document_search and encryption tests</name>
  <files>
    backend/tests/unit/services/test_document_search.py
    backend/tests/unit/services/test_encryption.py
  </files>
  <action>
Create test file for document_search (FTS5):

```python
"""Unit tests for document_search service."""

import pytest
from app.services.document_search import index_document, search_documents
from app.models import Document, Project


class TestIndexDocument:
    """Tests for index_document function."""

    @pytest.mark.asyncio
    async def test_indexes_document_content(self, db_session, user):
        """Document content is indexed in FTS5."""
        db_session.add(user)
        await db_session.commit()

        project = Project(user_id=user.id, name="Test Project")
        db_session.add(project)
        await db_session.commit()

        doc = Document(
            project_id=project.id,
            filename="test.md",
            content_encrypted=b"encrypted"
        )
        db_session.add(doc)
        await db_session.commit()

        # Index the document
        await index_document(
            db_session,
            doc.id,
            doc.filename,
            "This is the searchable content"
        )
        await db_session.commit()

        # Verify by searching
        results = await search_documents(db_session, project.id, "searchable")

        assert len(results) > 0
        assert results[0][0] == doc.id


class TestSearchDocuments:
    """Tests for search_documents function."""

    @pytest.mark.asyncio
    async def test_returns_empty_for_no_project(self, db_session):
        """Returns empty list when project_id is None."""
        results = await search_documents(db_session, None, "anything")
        assert results == []

    @pytest.mark.asyncio
    async def test_returns_empty_for_empty_query(self, db_session, user):
        """Returns empty list when query is empty."""
        db_session.add(user)
        await db_session.commit()

        project = Project(user_id=user.id, name="Test")
        db_session.add(project)
        await db_session.commit()

        results = await search_documents(db_session, project.id, "")
        assert results == []

        results = await search_documents(db_session, project.id, "   ")
        assert results == []

    @pytest.mark.asyncio
    async def test_returns_matching_documents(self, db_session, user):
        """Returns documents matching search query."""
        db_session.add(user)
        await db_session.commit()

        project = Project(user_id=user.id, name="Test")
        db_session.add(project)
        await db_session.commit()

        # Create and index document
        doc = Document(
            project_id=project.id,
            filename="requirements.md",
            content_encrypted=b"encrypted"
        )
        db_session.add(doc)
        await db_session.commit()

        await index_document(
            db_session,
            doc.id,
            doc.filename,
            "User authentication requirements and login flow"
        )
        await db_session.commit()

        results = await search_documents(db_session, project.id, "authentication")

        assert len(results) == 1
        doc_id, filename, snippet, score = results[0]
        assert doc_id == doc.id
        assert filename == "requirements.md"
        assert "authentication" in snippet.lower() or "<mark>" in snippet

    @pytest.mark.asyncio
    async def test_project_isolation(self, db_session, user):
        """Only returns documents from specified project."""
        db_session.add(user)
        await db_session.commit()

        project1 = Project(user_id=user.id, name="Project 1")
        project2 = Project(user_id=user.id, name="Project 2")
        db_session.add_all([project1, project2])
        await db_session.commit()

        doc1 = Document(project_id=project1.id, filename="p1.md", content_encrypted=b"x")
        doc2 = Document(project_id=project2.id, filename="p2.md", content_encrypted=b"x")
        db_session.add_all([doc1, doc2])
        await db_session.commit()

        await index_document(db_session, doc1.id, doc1.filename, "unique content alpha")
        await index_document(db_session, doc2.id, doc2.filename, "unique content beta")
        await db_session.commit()

        # Search in project1 should not find project2's document
        results = await search_documents(db_session, project1.id, "beta")
        assert len(results) == 0

        results = await search_documents(db_session, project1.id, "alpha")
        assert len(results) == 1

    @pytest.mark.asyncio
    async def test_returns_snippets_with_highlights(self, db_session, user):
        """Results include highlighted snippets."""
        db_session.add(user)
        await db_session.commit()

        project = Project(user_id=user.id, name="Test")
        db_session.add(project)
        await db_session.commit()

        doc = Document(project_id=project.id, filename="test.md", content_encrypted=b"x")
        db_session.add(doc)
        await db_session.commit()

        await index_document(
            db_session,
            doc.id,
            doc.filename,
            "The quick brown fox jumps over the lazy dog"
        )
        await db_session.commit()

        results = await search_documents(db_session, project.id, "fox")

        assert len(results) == 1
        _, _, snippet, _ = results[0]
        # FTS5 snippet should have <mark> tags
        assert "<mark>" in snippet or "fox" in snippet
```

Create test file for encryption service:

```python
"""Unit tests for encryption service."""

import pytest
from app.services.encryption import EncryptionService, get_encryption_service


class TestEncryptionService:
    """Tests for EncryptionService class."""

    def test_encrypt_decrypt_roundtrip(self):
        """Encrypted content can be decrypted back to original."""
        service = EncryptionService()
        original = "Hello, World! This is a test document."

        encrypted = service.encrypt_document(original)
        decrypted = service.decrypt_document(encrypted)

        assert decrypted == original

    def test_encrypt_returns_bytes(self):
        """Encryption returns bytes."""
        service = EncryptionService()
        result = service.encrypt_document("test")

        assert isinstance(result, bytes)

    def test_decrypt_returns_string(self):
        """Decryption returns string."""
        service = EncryptionService()
        encrypted = service.encrypt_document("test")
        decrypted = service.decrypt_document(encrypted)

        assert isinstance(decrypted, str)

    def test_handles_unicode_content(self):
        """Handles Unicode characters correctly."""
        service = EncryptionService()
        original = "Hello \u4e16\u754c \U0001f600"  # Chinese + emoji

        encrypted = service.encrypt_document(original)
        decrypted = service.decrypt_document(encrypted)

        assert decrypted == original

    def test_handles_empty_content(self):
        """Handles empty string."""
        service = EncryptionService()

        encrypted = service.encrypt_document("")
        decrypted = service.decrypt_document(encrypted)

        assert decrypted == ""

    def test_handles_large_content(self):
        """Handles large documents."""
        service = EncryptionService()
        original = "x" * 100_000  # 100KB

        encrypted = service.encrypt_document(original)
        decrypted = service.decrypt_document(encrypted)

        assert decrypted == original

    def test_different_encryptions_produce_different_ciphertext(self):
        """Same plaintext produces different ciphertext each time."""
        service = EncryptionService()
        plaintext = "test content"

        encrypted1 = service.encrypt_document(plaintext)
        encrypted2 = service.encrypt_document(plaintext)

        # Fernet uses random IV, so ciphertexts differ
        assert encrypted1 != encrypted2

    def test_invalid_ciphertext_raises_error(self):
        """Invalid ciphertext raises exception."""
        service = EncryptionService()

        with pytest.raises(Exception):  # InvalidToken from cryptography
            service.decrypt_document(b"not-valid-ciphertext")


class TestGetEncryptionService:
    """Tests for singleton get_encryption_service function."""

    def test_returns_encryption_service(self):
        """Returns an EncryptionService instance."""
        service = get_encryption_service()
        assert isinstance(service, EncryptionService)

    def test_returns_same_instance(self):
        """Returns the same singleton instance."""
        service1 = get_encryption_service()
        service2 = get_encryption_service()
        assert service1 is service2
```
  </action>
  <verify>
```bash
cd backend && python -m pytest tests/unit/services/test_document_search.py tests/unit/services/test_encryption.py -v
```
All tests pass.
  </verify>
  <done>15 tests pass for document_search and encryption services</done>
</task>

</tasks>

<verification>
Run all database service tests:
```bash
cd backend && python -m pytest tests/unit/services/test_*_db.py tests/unit/services/test_document_search.py tests/unit/services/test_encryption.py -v
```
All 37 tests should pass.

Check coverage:
```bash
cd backend && python -m pytest tests/unit/services/ --cov=app.services.conversation_service --cov=app.services.token_tracking --cov=app.services.document_search --cov=app.services.encryption --cov-report=term-missing
```
</verification>

<success_criteria>
1. test_conversation_service_db.py has 11 passing tests
2. test_token_tracking_db.py has 11 passing tests
3. test_document_search.py has 6 passing tests
4. test_encryption.py has 10 passing tests
5. All tests use db_session fixture properly
6. FTS5 tests verify document indexing and search
7. `pytest tests/unit/services/ -v` passes all tests
</success_criteria>

<output>
After completion, create `.planning/phases/29-backend-service-tests/29-02-SUMMARY.md`
</output>
