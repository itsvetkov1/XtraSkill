---
phase: 54-backend-foundation-document-parsing-security
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/requirements.txt
  - backend/app/services/document_parser/__init__.py
  - backend/app/services/document_parser/base.py
  - backend/app/services/document_parser/excel_parser.py
  - backend/app/services/document_parser/csv_parser.py
  - backend/app/services/document_parser/pdf_parser.py
  - backend/app/services/document_parser/word_parser.py
  - backend/app/services/document_parser/text_parser.py
  - backend/app/services/file_validator.py
autonomous: true

must_haves:
  truths:
    - "ExcelParser extracts text from .xlsx files preserving data types (leading zeros, dates, large numbers as strings)"
    - "CsvParser auto-detects encoding (UTF-8, Windows-1252, UTF-8-BOM) and extracts text without mojibake"
    - "PdfParser extracts text with page markers ([Page N]) for reference"
    - "WordParser extracts text preserving paragraph structure"
    - "ParserFactory routes content types to correct parser implementations"
    - "file_validator rejects files with mismatched magic numbers (spoofed extensions)"
    - "file_validator rejects zip bombs (XLSX/DOCX with >100:1 compression ratio)"
    - "file_validator rejects files >10MB"
    - "defusedxml monkey-patch is applied before openpyxl import for XXE protection"
  artifacts:
    - path: "backend/app/services/document_parser/__init__.py"
      provides: "ParserFactory with content-type routing and defusedxml monkey-patch"
      contains: "ParserFactory"
    - path: "backend/app/services/document_parser/base.py"
      provides: "DocumentParser abstract base class with parse() and validate_security() methods"
      contains: "class DocumentParser"
    - path: "backend/app/services/document_parser/excel_parser.py"
      provides: "Excel parser with type-preserving text extraction"
      contains: "class ExcelParser"
    - path: "backend/app/services/document_parser/csv_parser.py"
      provides: "CSV parser with chardet encoding detection"
      contains: "class CsvParser"
    - path: "backend/app/services/document_parser/pdf_parser.py"
      provides: "PDF parser with page-level text extraction"
      contains: "class PdfParser"
    - path: "backend/app/services/document_parser/word_parser.py"
      provides: "Word parser with paragraph structure preservation"
      contains: "class WordParser"
    - path: "backend/app/services/document_parser/text_parser.py"
      provides: "Legacy text parser wrapping existing plain text handling"
      contains: "class TextParser"
    - path: "backend/app/services/file_validator.py"
      provides: "Security validation (magic numbers, size, zip bombs, malformed files)"
      contains: "validate_file_security"
  key_links:
    - from: "backend/app/services/document_parser/__init__.py"
      to: "all parser classes"
      via: "ParserFactory._parsers dict mapping content_type to parser class"
      pattern: "_parsers.*ExcelParser|CsvParser|PdfParser|WordParser|TextParser"
    - from: "backend/app/services/document_parser/__init__.py"
      to: "defusedxml"
      via: "sys.modules monkey-patch before openpyxl import"
      pattern: "sys\\.modules.*xml\\.etree\\.ElementTree.*defusedxml"
---

<objective>
Create the document parser infrastructure with format-specific parsers and security validation.

Purpose: Build the parser adapter pattern (base class + factory + 5 format implementations) and file validation service that will be consumed by the upload route in Plan 54-03. This is all new code with no existing file conflicts, enabling parallel development.

Output: `backend/app/services/document_parser/` module with factory-routed parsers for Excel, CSV, PDF, Word, and plain text. `backend/app/services/file_validator.py` for security validation. Updated `requirements.txt` with new dependencies.
</objective>

<execution_context>
@/Users/a1testingmac/.claude/get-shit-done/workflows/execute-plan.md
@/Users/a1testingmac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/54-backend-foundation-document-parsing-security/54-RESEARCH.md

# Key existing files for interface understanding
@backend/app/services/encryption.py
@backend/app/services/document_search.py
@backend/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install dependencies and create parser module with base class, factory, and defusedxml protection</name>
  <files>
    backend/requirements.txt
    backend/app/services/document_parser/__init__.py
    backend/app/services/document_parser/base.py
  </files>
  <action>
**1. Update requirements.txt** — Add these lines after the existing `python-docx==1.2.0` line:

```
openpyxl>=3.1.4
pdfplumber>=0.11.0
chardet>=5.0.0
defusedxml>=0.7.1
filetype>=1.2.0
```

Then run `pip install -r requirements.txt` from the backend venv.

**2. Create `backend/app/services/document_parser/base.py`** — Abstract base class:

```python
from abc import ABC, abstractmethod
from typing import Dict, Any

class DocumentParser(ABC):
    """Base parser for all document formats."""

    @abstractmethod
    def parse(self, file_bytes: bytes) -> Dict[str, Any]:
        """
        Extract text and metadata from document.

        Returns:
            {
                "text": str,        # Full extracted text for FTS5 indexing
                "summary": str,     # First 5000 chars for AI context
                "metadata": dict    # Format-specific metadata
            }
        """
        pass

    @abstractmethod
    def validate_security(self, file_bytes: bytes) -> None:
        """
        Validate file against security threats.
        Raises HTTPException(400) for malformed, HTTPException(413) for oversized/zip bombs.
        """
        pass

    @staticmethod
    def create_ai_summary(full_text: str, max_chars: int = 5000) -> str:
        """Create truncated summary for AI context to prevent token explosion."""
        if len(full_text) <= max_chars:
            return full_text
        return full_text[:max_chars] + "\n\n[Document truncated for AI context. Full text indexed for search.]"
```

**3. Create `backend/app/services/document_parser/__init__.py`** — Factory + defusedxml monkey-patch:

CRITICAL: The defusedxml monkey-patch MUST happen before any openpyxl or python-docx import to protect against XXE attacks in XLSX/DOCX XML content.

```python
import sys
import defusedxml.ElementTree
# Monkey-patch xml.etree.ElementTree BEFORE importing openpyxl or python-docx
sys.modules['xml.etree.ElementTree'] = defusedxml.ElementTree

from .base import DocumentParser
from .excel_parser import ExcelParser
from .csv_parser import CsvParser
from .pdf_parser import PdfParser
from .word_parser import WordParser
from .text_parser import TextParser

class ParserFactory:
    """Route content types to appropriate parser implementations."""

    _parsers = {
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ExcelParser,
        "text/csv": CsvParser,
        "application/pdf": PdfParser,
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document": WordParser,
        "text/plain": TextParser,
        "text/markdown": TextParser,
    }

    # Content types that are considered "rich" (binary) documents vs plain text
    RICH_CONTENT_TYPES = [
        "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
        "text/csv",
        "application/pdf",
        "application/vnd.openxmlformats-officedocument.wordprocessingml.document",
    ]

    # All supported content types (rich + text)
    ALL_CONTENT_TYPES = RICH_CONTENT_TYPES + ["text/plain", "text/markdown"]

    @classmethod
    def get_parser(cls, content_type: str) -> DocumentParser:
        parser_class = cls._parsers.get(content_type)
        if not parser_class:
            raise ValueError(f"Unsupported content type: {content_type}")
        return parser_class()

    @classmethod
    def is_supported(cls, content_type: str) -> bool:
        return content_type in cls._parsers

    @classmethod
    def is_rich_format(cls, content_type: str) -> bool:
        return content_type in cls.RICH_CONTENT_TYPES
```

Expose `ParserFactory`, `DocumentParser`, and the `ALL_CONTENT_TYPES` list from the `__init__.py` via `__all__`.
  </action>
  <verify>
Run from backend directory:
```bash
cd backend && source venv/bin/activate
python -c "from app.services.document_parser import ParserFactory; print(ParserFactory.ALL_CONTENT_TYPES)"
python -c "import defusedxml; print('defusedxml:', defusedxml.__version__)"
python -c "import openpyxl; print('openpyxl:', openpyxl.__version__)"
python -c "import pdfplumber; print('pdfplumber:', pdfplumber.__version__)"
python -c "import chardet; print('chardet:', chardet.__version__)"
python -c "import filetype; print('filetype:', filetype.__version__)"
```
All imports succeed, versions print without error.
  </verify>
  <done>
    - ParserFactory correctly maps 6 content types to parser classes
    - defusedxml monkey-patch applied before openpyxl/docx imports (confirmed by import order in __init__.py)
    - All 5 new dependencies install successfully
    - DocumentParser base class has parse(), validate_security(), and create_ai_summary() methods
  </done>
</task>

<task type="auto">
  <name>Task 2: Create format-specific parsers (Excel, CSV, PDF, Word, Text) and file validator</name>
  <files>
    backend/app/services/document_parser/excel_parser.py
    backend/app/services/document_parser/csv_parser.py
    backend/app/services/document_parser/pdf_parser.py
    backend/app/services/document_parser/word_parser.py
    backend/app/services/document_parser/text_parser.py
    backend/app/services/file_validator.py
  </files>
  <action>
**1. Create `excel_parser.py`** — ExcelParser with data type preservation (PARSE-01, PARSE-05):

- Use `openpyxl.load_workbook(BytesIO(file_bytes), read_only=True, data_only=True, keep_links=False)`
- For each worksheet: iterate rows, convert each cell.value to `str(cell.value)` if not None else "" — this preserves leading zeros, dates, large numbers as their string representation
- Join cell values with tab, rows with newline
- Skip completely empty rows (where all cell values are empty strings)
- Prepend sheet name header: `"[Sheet: {sheet.title}]\n"` before each sheet's content
- Metadata: `{"sheet_names": [...], "row_counts": {sheet: count}, "total_sheets": N, "total_rows": N, "column_headers": {sheet: [first_row_values]}}`
- Column headers: extract first non-empty row of each sheet as column header list
- validate_security: call `validate_zip_bomb()` from file_validator, then try opening with openpyxl (catches malformed XLSX)

**2. Create `csv_parser.py`** — CsvParser with encoding detection (PARSE-02, PARSE-06):

- Use `chardet.detect(file_bytes[:10240])` for encoding detection
- Decode with detected encoding, `errors='replace'` fallback
- If chardet returns None encoding, fall back to 'utf-8'
- Parse with `csv.reader(io.StringIO(text))`
- Join values with tab, rows with newline
- Metadata: `{"row_count": N, "encoding": detected_encoding, "encoding_confidence": float, "column_headers": [first_row_values], "format": "CSV"}`
- validate_security: minimal (size already checked by file_validator, encoding detection is safe)

**3. Create `pdf_parser.py`** — PdfParser with page info (PARSE-03):

- Use `pdfplumber.open(BytesIO(file_bytes))`
- For each page: extract text with `page.extract_text() or ""`
- Add page marker: `"[Page {page.page_number}]\n{text}"`
- Join pages with double newline
- Metadata: `{"page_count": N, "format": "PDF"}`
- validate_security: try opening PDF and checking page access

**4. Create `word_parser.py`** — WordParser with paragraph structure (PARSE-04):

- Use `docx.Document(BytesIO(file_bytes))`
- Extract paragraphs: `[para.text.strip() for para in doc.paragraphs if para.text.strip()]`
- Join paragraphs with double newline (preserves document structure)
- Also extract table text: iterate `doc.tables`, for each table iterate rows/cells, join with tab/newline
- If tables exist, append after paragraphs with `"\n\n[Tables]\n"` header
- Metadata: `{"paragraph_count": N, "table_count": N, "format": "Word"}`
- validate_security: call `validate_zip_bomb()` from file_validator, then try opening with python-docx

**5. Create `text_parser.py`** — TextParser wrapping existing plain text logic:

- Decode file_bytes as UTF-8 with `errors='replace'`
- No special structure — return text as-is
- Metadata: `{"format": "Text", "encoding": "utf-8"}`
- validate_security: check UTF-8 decode succeeds (raise HTTPException(400) if not)

**6. Create `backend/app/services/file_validator.py`** — Centralized security validation (SEC-01 through SEC-05):

```python
import io
import zipfile
import logging
import filetype
from fastapi import HTTPException

logger = logging.getLogger(__name__)

MAX_FILE_SIZE = 10 * 1024 * 1024  # 10MB (SEC-02)
MAX_UNCOMPRESSED_RATIO = 100      # Zip bomb detection threshold (SEC-04)

# Mapping from expected content_type to filetype library MIME types
# filetype may return slightly different MIME types than the client sends
MAGIC_TYPE_MAP = {
    "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": ["application/zip", "application/x-zip-compressed"],
    "application/vnd.openxmlformats-officedocument.wordprocessingml.document": ["application/zip", "application/x-zip-compressed"],
    "application/pdf": ["application/pdf"],
    # CSV and plain text don't have magic numbers — validated by extension + parsing
    "text/csv": None,
    "text/plain": None,
    "text/markdown": None,
}
```

Functions:
- `validate_file_security(file_bytes: bytes, content_type: str) -> None` — Orchestrator: checks size, then magic number (for binary types), then zip bomb (for XLSX/DOCX). Raises HTTPException.
- `validate_file_size(file_bytes: bytes) -> None` — Checks `len(file_bytes) > MAX_FILE_SIZE`, raises 413.
- `validate_magic_number(file_bytes: bytes, expected_content_type: str) -> None` — Uses `filetype.guess()` to verify actual file type matches expected. For text types (CSV, plain, markdown), skip magic check (no reliable magic bytes). For XLSX/DOCX, the magic bytes will be ZIP (since they're zip archives) — accept both "application/zip" and the specific OOXML type.
- `validate_zip_bomb(file_bytes: bytes) -> None` — Opens as `zipfile.ZipFile`, sums `info.file_size` for all entries, checks ratio. Also validates `zipfile.BadZipFile` for malformed archives.

IMPORTANT: For CSV files, `filetype.guess()` returns `None` (text files have no magic bytes). The validator must handle this by skipping magic number validation for text-based content types (`text/*`).
  </action>
  <verify>
Create a quick test script and run it (then delete the test file):
```bash
cd backend && source venv/bin/activate
python -c "
from app.services.document_parser import ParserFactory

# Test factory returns correct parser types
for ct in ParserFactory.ALL_CONTENT_TYPES:
    parser = ParserFactory.get_parser(ct)
    print(f'{ct} -> {type(parser).__name__}')

# Test text parser with sample bytes
from app.services.document_parser.text_parser import TextParser
tp = TextParser()
result = tp.parse(b'Hello world')
print(f'TextParser result: text={result[\"text\"][:20]}, metadata={result[\"metadata\"]}')

# Test file validator size check
from app.services.file_validator import validate_file_size
try:
    validate_file_size(b'x' * (11 * 1024 * 1024))
    print('ERROR: Should have rejected oversized file')
except Exception as e:
    print(f'Size validation works: {e.detail}')

# Test file validator accepts small file
validate_file_size(b'small file')
print('Small file accepted')
print('All basic checks passed')
"
```
  </verify>
  <done>
    - ExcelParser extracts text preserving data types via str(cell.value), includes sheet headers and column header metadata
    - CsvParser auto-detects encoding via chardet, falls back to UTF-8 on None
    - PdfParser extracts text with [Page N] markers using pdfplumber
    - WordParser extracts paragraphs and table text with structure headers
    - TextParser wraps legacy UTF-8 text handling
    - file_validator enforces 10MB limit, magic number check for binary formats, zip bomb detection for XLSX/DOCX
    - All parsers return consistent {text, summary, metadata} dict
    - validate_security() works on each parser for format-specific checks
  </done>
</task>

</tasks>

<verification>
1. All 5 new dependencies installed and importable: openpyxl, pdfplumber, chardet, defusedxml, filetype
2. ParserFactory routes all 6 content types to correct parser classes
3. defusedxml monkey-patch applied before openpyxl import (verify import order in __init__.py)
4. Each parser's parse() returns dict with "text", "summary", "metadata" keys
5. file_validator rejects files >10MB with 413 status
6. file_validator rejects ZIP archives with >100:1 compression ratio
7. file_validator validates magic numbers for binary formats (PDF, XLSX, DOCX)
8. file_validator skips magic check for text formats (CSV, plain text, markdown)
</verification>

<success_criteria>
- `from app.services.document_parser import ParserFactory` works without import errors
- `ParserFactory.get_parser("application/pdf")` returns PdfParser instance
- `from app.services.file_validator import validate_file_security` works
- All parser classes have parse() and validate_security() methods
- File size validation rejects >10MB files
- No XXE vulnerability (defusedxml patched before openpyxl)
</success_criteria>

<output>
After completion, create `.planning/phases/54-backend-foundation-document-parsing-security/54-01-SUMMARY.md`
</output>
