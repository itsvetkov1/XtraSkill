---
phase: 62-backend-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models.py
  - backend/alembic/versions/XXXXXX_add_thread_type_and_document_thread_id.py
autonomous: true
requirements: [DATA-01, DATA-02, DATA-03]

must_haves:
  truths:
    - "Thread model has a thread_type field with values 'ba_assistant' and 'assistant'"
    - "Existing threads in the database have thread_type='ba_assistant' after migration (no NULLs)"
    - "Document model has a nullable thread_id field for thread-scoped documents"
    - "Document model project_id is nullable (was required, now optional for Assistant threads)"
  artifacts:
    - path: "backend/app/models.py"
      provides: "ThreadType enum and thread_type field on Thread, thread_id field on Document"
      contains: "class ThreadType"
    - path: "backend/alembic/versions/XXXXXX_add_thread_type_and_document_thread_id.py"
      provides: "Migration adding thread_type to threads with backfill, thread_id to documents, project_id nullable"
  key_links:
    - from: "backend/app/models.py"
      to: "backend/alembic/versions/XXXXXX_add_thread_type_and_document_thread_id.py"
      via: "Migration reflects model changes"
      pattern: "thread_type|thread_id"
---

<objective>
Add ThreadType enum and thread_type field to Thread model, add thread_id to Document model, and create backward-compatible migration with backfill.

Purpose: Establish the data foundation that all other plans depend on -- the thread_type discriminator for BA vs Assistant threads and thread-scoped document support.
Output: Updated models.py with ThreadType enum, Thread.thread_type field, Document.thread_id field, and Alembic migration.
</objective>

<execution_context>
@/Users/a1testingmac/.claude/get-shit-done/workflows/execute-plan.md
@/Users/a1testingmac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/62-backend-foundation/62-RESEARCH.md
@backend/app/models.py
@backend/alembic/versions/b4ef9fb543d5_add_conversation_mode_to_threads.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add ThreadType enum and thread_type field to Thread model, add thread_id to Document model</name>
  <files>backend/app/models.py</files>
  <action>
1. Add ThreadType enum class following the existing OAuthProvider pattern (str, PyEnum):
   ```python
   class ThreadType(str, PyEnum):
       """Thread type discriminator for BA vs Assistant modes."""
       BA_ASSISTANT = "ba_assistant"
       ASSISTANT = "assistant"
   ```
   Place it after the OAuthProvider enum definition (before the User class).

2. Add thread_type field to the Thread model:
   ```python
   thread_type: Mapped[str] = mapped_column(
       String(20),
       nullable=False,
       server_default="ba_assistant"
   )
   ```
   NOTE: Use String(20) not Enum() in the mapped_column -- the existing model_provider field uses String(20) and validates at API level, not DB level. Follow the same pattern for consistency. Place it after the conversation_mode field.

3. Update Document model:
   - Change project_id from `nullable=False` to `nullable=True` (now Optional for Assistant thread docs)
   - Update type annotation from `Mapped[str]` to `Mapped[Optional[str]]`
   - Add thread_id field:
     ```python
     thread_id: Mapped[Optional[str]] = mapped_column(
         String(36),
         ForeignKey("threads.id", ondelete="CASCADE"),
         nullable=True,
         index=True
     )
     ```
   - Add relationship to Thread:
     ```python
     thread: Mapped[Optional["Thread"]] = relationship(foreign_keys=[thread_id])
     ```

4. On the Thread model, add a documents relationship for thread-scoped docs:
   ```python
   documents: Mapped[List["Document"]] = relationship(
       back_populates="thread",
       cascade="all, delete-orphan",
       passive_deletes=True,
       foreign_keys="[Document.thread_id]"
   )
   ```
   Update the Document.thread relationship to include `back_populates="documents"`.

IMPORTANT: The ThreadType enum is defined for use in validation logic in other files, but the Thread.thread_type column itself uses String(20) to match the model_provider pattern. This is simpler and avoids SQLAlchemy Enum type complications with SQLite.
  </action>
  <verify>
Run: `cd /Users/a1testingmac/projects/XtraSkill/backend && python -c "from app.models import Thread, Document, ThreadType; print('ThreadType:', [e.value for e in ThreadType]); print('OK')"` -- should print enum values and OK.
  </verify>
  <done>
- ThreadType enum exists with BA_ASSISTANT and ASSISTANT values
- Thread model has thread_type field with server_default="ba_assistant"
- Document.project_id is nullable=True
- Document has thread_id field with ForeignKey to threads.id
- Document has thread relationship, Thread has documents relationship
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Alembic migration with 3-step pattern (nullable, backfill, NOT NULL)</name>
  <files>backend/alembic/versions/XXXXXX_add_thread_type_and_document_thread_id.py</files>
  <action>
Generate a new Alembic migration:
```bash
cd /Users/a1testingmac/projects/XtraSkill/backend
source venv/bin/activate
alembic revision --autogenerate -m "add thread_type to threads and thread_id to documents"
```

Then edit the generated migration to implement the 3-step pattern for thread_type:

```python
def upgrade() -> None:
    # Step 1: Add thread_type as nullable with server_default
    with op.batch_alter_table('threads', schema=None) as batch_op:
        batch_op.add_column(
            sa.Column('thread_type', sa.String(length=20),
                      nullable=True,
                      server_default='ba_assistant')
        )

    # Step 2: Backfill existing threads
    connection = op.get_bind()
    connection.execute(
        sa.text("UPDATE threads SET thread_type = 'ba_assistant' WHERE thread_type IS NULL")
    )

    # Step 3: Make NOT NULL after backfill
    with op.batch_alter_table('threads', schema=None) as batch_op:
        batch_op.alter_column('thread_type', nullable=False)

    # Document model changes: make project_id nullable and add thread_id
    with op.batch_alter_table('documents', schema=None) as batch_op:
        batch_op.alter_column('project_id', nullable=True)
        batch_op.add_column(
            sa.Column('thread_id', sa.String(36),
                      sa.ForeignKey('threads.id', ondelete='CASCADE'),
                      nullable=True)
        )
        batch_op.create_index('ix_documents_thread_id', ['thread_id'])


def downgrade() -> None:
    with op.batch_alter_table('documents', schema=None) as batch_op:
        batch_op.drop_index('ix_documents_thread_id')
        batch_op.drop_column('thread_id')
        batch_op.alter_column('project_id', nullable=False)

    with op.batch_alter_table('threads', schema=None) as batch_op:
        batch_op.drop_column('thread_type')
```

After creating the migration, run it:
```bash
alembic upgrade head
```

Verify the migration succeeded by checking the database schema.

IMPORTANT: Use batch_alter_table for ALL operations -- SQLite requires this for ALTER TABLE operations. The down_revision should chain from the latest existing migration.
  </action>
  <verify>
Run: `cd /Users/a1testingmac/projects/XtraSkill/backend && source venv/bin/activate && alembic upgrade head && python -c "
import sqlite3
conn = sqlite3.connect('ba_assistant.db')
# Check threads table has thread_type
cursor = conn.execute('PRAGMA table_info(threads)')
cols = {row[1]: row for row in cursor.fetchall()}
assert 'thread_type' in cols, 'thread_type column missing'
assert cols['thread_type'][3] == 1, 'thread_type should be NOT NULL'
# Check no NULL thread_types
cursor = conn.execute('SELECT COUNT(*) FROM threads WHERE thread_type IS NULL')
null_count = cursor.fetchone()[0]
assert null_count == 0, f'Found {null_count} NULL thread_types'
# Check documents table has thread_id
cursor = conn.execute('PRAGMA table_info(documents)')
doc_cols = {row[1]: row for row in cursor.fetchall()}
assert 'thread_id' in doc_cols, 'thread_id column missing on documents'
# Check project_id is nullable
assert doc_cols['project_id'][3] == 0, 'project_id should be nullable'
print('Migration verified: thread_type NOT NULL, no NULLs, document thread_id exists, project_id nullable')
conn.close()
"` -- should print verification message.
  </verify>
  <done>
- Migration file exists and chains from latest existing migration
- Running migration adds thread_type to threads (NOT NULL, default 'ba_assistant')
- All existing threads have thread_type='ba_assistant' (backfilled)
- Documents table has thread_id column (nullable, indexed, FK to threads)
- Documents.project_id is now nullable
- Downgrade reverses all changes cleanly
  </done>
</task>

</tasks>

<verification>
1. `python -c "from app.models import ThreadType; print(ThreadType.BA_ASSISTANT.value, ThreadType.ASSISTANT.value)"` prints "ba_assistant assistant"
2. `alembic upgrade head` succeeds without errors
3. SQLite schema inspection shows thread_type NOT NULL on threads, thread_id nullable on documents
4. No existing threads have NULL thread_type
5. `alembic downgrade -1` then `alembic upgrade head` both succeed (roundtrip)
</verification>

<success_criteria>
- ThreadType enum importable from app.models
- Thread.thread_type field exists with server_default
- Document.thread_id field exists for thread-scoped documents
- Document.project_id now nullable
- Migration runs cleanly on existing database with data
- All existing threads backfilled to ba_assistant
</success_criteria>

<output>
After completion, create `.planning/phases/62-backend-foundation/62-01-SUMMARY.md`
</output>
