---
phase: 46-frontend-http-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/lib/services/api_client.dart
  - frontend/lib/services/logging_service.dart
  - frontend/lib/services/auth_service.dart
  - frontend/lib/services/project_service.dart
  - frontend/lib/services/thread_service.dart
  - frontend/lib/services/document_service.dart
  - frontend/lib/services/ai_service.dart
  - frontend/lib/services/artifact_service.dart
autonomous: true
user_setup: []

must_haves:
  truths:
    - "All HTTP requests include X-Correlation-ID header"
    - "API calls are logged with endpoint, method, status, and duration"
    - "Correlation ID links frontend requests to backend logs"
  artifacts:
    - path: "frontend/lib/services/api_client.dart"
      provides: "Singleton Dio wrapper with interceptors"
      exports: ["ApiClient"]
      min_lines: 60
    - path: "frontend/lib/services/logging_service.dart"
      provides: "API logging method"
      contains: "logApi"
  key_links:
    - from: "frontend/lib/services/api_client.dart"
      to: "frontend/lib/services/logging_service.dart"
      via: "LoggingService().logApi() call in interceptor"
      pattern: "logApi\\("
    - from: "frontend/lib/services/project_service.dart"
      to: "frontend/lib/services/api_client.dart"
      via: "ApiClient().dio usage"
      pattern: "ApiClient\\(\\)\\.dio"
---

<objective>
Integrate correlation ID tracking and HTTP logging into all frontend API requests.

Purpose: Enable tracing of user requests from frontend through backend logs using X-Correlation-ID header, and capture API performance metrics (endpoint, method, status, duration) for debugging during pilot testing.

Output: ApiClient singleton with Dio interceptor, updated LoggingService with logApi() method, all services refactored to use shared Dio instance.
</objective>

<execution_context>
@C:\Users\ibcve\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ibcve\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/45-frontend-logging-foundation/45-01-SUMMARY.md
@.planning/phases/46-frontend-http-integration/46-RESEARCH.md

# Existing services to refactor
@frontend/lib/services/logging_service.dart
@frontend/lib/services/auth_service.dart
@frontend/lib/services/project_service.dart
@frontend/lib/services/thread_service.dart
@frontend/lib/services/document_service.dart
@frontend/lib/services/ai_service.dart
@frontend/lib/services/artifact_service.dart
@frontend/lib/core/config.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ApiClient singleton with correlation ID interceptor</name>
  <files>
    frontend/lib/services/api_client.dart
    frontend/lib/services/logging_service.dart
  </files>
  <action>
Create ApiClient singleton class in `frontend/lib/services/api_client.dart`:

1. **Singleton pattern:**
   - Private constructor `ApiClient._internal()`
   - Static final `_instance` field
   - Factory constructor returns `_instance`

2. **Dio configuration:**
   - `late final Dio dio` initialized in private constructor
   - BaseOptions with:
     - `baseUrl: ApiConfig.baseUrl` (import from core/config.dart)
     - `connectTimeout: Duration(seconds: 30)`
     - `receiveTimeout: Duration(seconds: 30)`
     - `headers: {'Content-Type': 'application/json'}`

3. **InterceptorsWrapper (add FIRST, before any LogInterceptor):**
   - `onRequest`:
     - Generate correlation ID: `final correlationId = const Uuid().v4()`
     - Add header: `options.headers['X-Correlation-ID'] = correlationId`
     - Store in extra for response: `options.extra['correlation_id'] = correlationId`
     - Store start time: `options.extra['start_time'] = DateTime.now().millisecondsSinceEpoch`
     - Call `handler.next(options)`

   - `onResponse`:
     - Calculate duration from extra['start_time']
     - Call `_logApiCall()` helper with success data
     - Call `handler.next(response)`

   - `onError`:
     - Calculate duration from extra['start_time']
     - Call `_logApiCall()` helper with error data
     - Call `handler.reject(error)` (NOT handler.next)

4. **_logApiCall helper method:**
   ```dart
   void _logApiCall(RequestOptions options, int? statusCode, DioException? error) {
     final startTime = options.extra['start_time'] as int?;
     final durationMs = startTime != null
         ? DateTime.now().millisecondsSinceEpoch - startTime
         : null;
     final correlationId = options.extra['correlation_id'] as String?;

     LoggingService().logApi(
       endpoint: options.path,
       method: options.method,
       statusCode: statusCode,
       durationMs: durationMs,
       correlationId: correlationId,
       error: error?.message,
     );
   }
   ```

5. **Debug LogInterceptor (add LAST, only in debug mode):**
   ```dart
   if (kDebugMode) {
     dio.interceptors.add(LogInterceptor(
       responseBody: false,
       requestBody: false,
       logPrint: (o) => debugPrint(o.toString()),
     ));
   }
   ```

**Add logApi method to LoggingService** (`frontend/lib/services/logging_service.dart`):

Add new public method after `logNetworkStateChange`:
```dart
/// Log API request/response (HTTP calls via Dio interceptor)
void logApi({
  required String endpoint,
  required String method,
  int? statusCode,
  int? durationMs,
  String? correlationId,
  String? error,
}) {
  final level = _getLogLevelForStatus(statusCode);
  final message = error != null
      ? '$method $endpoint -> ${statusCode ?? 'ERROR'} ($error)'
      : '$method $endpoint -> $statusCode';

  _log(
    level: level,
    message: message,
    category: 'api',
    metadata: {
      'endpoint': endpoint,
      'method': method,
      if (statusCode != null) 'status_code': statusCode,
      if (durationMs != null) 'duration_ms': durationMs,
      if (correlationId != null) 'correlation_id': correlationId,
      if (error != null) 'error': error,
    },
  );
}

/// Determine log level based on HTTP status code (per LOG-006)
String _getLogLevelForStatus(int? statusCode) {
  if (statusCode == null) return 'ERROR';
  if (statusCode >= 500) return 'ERROR';
  if (statusCode >= 400) return 'WARNING';
  return 'INFO';
}
```

**Imports needed in api_client.dart:**
- `package:dio/dio.dart`
- `package:flutter/foundation.dart` (for kDebugMode, debugPrint)
- `package:uuid/uuid.dart`
- `../core/config.dart`
- `logging_service.dart`
  </action>
  <verify>
1. Run `flutter analyze frontend/lib/services/api_client.dart frontend/lib/services/logging_service.dart` - no errors
2. Grep for `X-Correlation-ID` in api_client.dart
3. Grep for `logApi` in logging_service.dart
  </verify>
  <done>
ApiClient singleton exists with Dio + interceptor that adds X-Correlation-ID header and logs all requests. LoggingService has logApi method that logs with category 'api' and includes endpoint, method, status, duration, correlation_id.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor services to use ApiClient.dio</name>
  <files>
    frontend/lib/services/auth_service.dart
    frontend/lib/services/project_service.dart
    frontend/lib/services/thread_service.dart
    frontend/lib/services/document_service.dart
    frontend/lib/services/ai_service.dart
    frontend/lib/services/artifact_service.dart
  </files>
  <action>
Refactor each service to use the shared ApiClient.dio instance instead of creating its own Dio():

**Pattern for each service:**

1. Add import: `import 'api_client.dart';`

2. Change Dio field initialization:
   - Before: `final Dio _dio; ... _dio = dio ?? Dio()`
   - After: `final Dio _dio; ... _dio = dio ?? ApiClient().dio`

3. Remove `_baseUrl` field and usage:
   - Delete: `final String _baseUrl;` and its initialization
   - In API calls, use just the path since ApiClient.dio has baseUrl configured
   - Before: `'$_baseUrl/api/projects'`
   - After: `'/api/projects'`

**Service-specific changes:**

**auth_service.dart:**
- Replace `_baseUrl = baseUrl ?? 'http://localhost:8000'` with using ApiClient().dio
- Update all endpoint strings: `'$_baseUrl/auth/$provider/initiate'` -> `'/auth/$provider/initiate'`
- Note: Keep FlutterSecureStorage for token management
- Note: Keep debug prints for token debugging (temporary)

**project_service.dart:**
- Replace `_baseUrl = baseUrl ?? 'http://localhost:8000'` with ApiClient().dio
- Update all endpoint strings to relative paths: `'/api/projects'`, `'/api/projects/$id'`

**thread_service.dart:**
- Replace `_baseUrl = baseUrl ?? 'http://localhost:8000'` with ApiClient().dio
- Update all endpoint strings to relative paths

**document_service.dart:**
- Replace `_baseUrl = baseUrl ?? 'http://localhost:8000'` with ApiClient().dio
- Update all endpoint strings to relative paths
- Note: Some endpoints already use relative paths (like `/projects/$projectId/documents`), normalize all to have `/api/` prefix where backend expects it

**ai_service.dart:**
- Replace `_dio = dio ?? Dio()` with `_dio = dio ?? ApiClient().dio`
- Note: Keep `apiBaseUrl` usage for SSE endpoint (SSEClient uses full URL, not Dio)
- Only Dio-based methods (like deleteMessage) need refactoring

**artifact_service.dart:**
- Replace `_dio = dio ?? Dio()` with `_dio = dio ?? ApiClient().dio`
- Keep `apiBaseUrl` import for endpoint paths (artifact service uses full URLs)
- Update to use relative paths with ApiClient

**Testing compatibility:**
- Keep optional `dio` parameter in constructors for unit test injection
- When dio is provided (test mode), use provided instance
- When dio is null (production), use ApiClient().dio
  </action>
  <verify>
1. Run `flutter analyze frontend/lib/services/` - no errors
2. Grep for `ApiClient().dio` in all service files
3. Confirm no `Dio()` calls remain (except in ApiClient itself)
4. Run existing tests if any: `flutter test` from frontend directory
  </verify>
  <done>
All 6 services refactored to use ApiClient().dio. Each service maintains test compatibility via optional dio parameter. All API calls route through shared interceptor.
  </done>
</task>

<task type="auto">
  <name>Task 3: Integration verification</name>
  <files>
    frontend/lib/services/api_client.dart
  </files>
  <action>
Verify the complete integration:

1. **Static analysis check:**
   ```bash
   cd frontend && flutter analyze lib/services/
   ```
   All files must pass with no errors or warnings.

2. **Dependency check:**
   ```bash
   cd frontend && flutter pub get
   ```
   Ensure all imports resolve correctly.

3. **Build verification:**
   ```bash
   cd frontend && flutter build web --release --no-tree-shake-icons 2>&1 | head -50
   ```
   Build should complete without errors.

4. **Pattern verification via grep:**
   - Verify all services import ApiClient
   - Verify no direct Dio() instantiation (except ApiClient)
   - Verify X-Correlation-ID header is added

5. **Manual test guidance (for user):**
   After running the app:
   - Open DevTools Network tab
   - Perform any API action (login, view projects, etc.)
   - Verify X-Correlation-ID header appears in request headers
   - Verify console shows API log entries with category 'api'
  </action>
  <verify>
1. `flutter analyze lib/services/` returns 0 issues
2. `flutter build web` succeeds
3. Grep confirms:
   - `X-Correlation-ID` in api_client.dart
   - `ApiClient().dio` in all service files
   - No standalone `Dio()` calls except in api_client.dart
  </verify>
  <done>
Integration complete: all services route through ApiClient, correlation IDs attached to all requests, API calls logged with endpoint/method/status/duration.
  </done>
</task>

</tasks>

<verification>
Run these commands to verify phase completion:

```bash
# 1. Analyze all service files
cd frontend && flutter analyze lib/services/

# 2. Verify ApiClient exists with interceptor
grep -l "X-Correlation-ID" lib/services/api_client.dart

# 3. Verify logApi method exists
grep -l "logApi" lib/services/logging_service.dart

# 4. Verify all services use ApiClient
grep -l "ApiClient().dio" lib/services/*.dart | wc -l
# Expected: 6 (auth, project, thread, document, ai, artifact)

# 5. Verify no direct Dio() calls
grep -rn "Dio()" lib/services/*.dart | grep -v api_client.dart | grep -v "/// "
# Expected: 0 matches (only in api_client.dart)

# 6. Build web
flutter build web --release --no-tree-shake-icons
```
</verification>

<success_criteria>
1. ApiClient singleton exists with Dio instance and InterceptorsWrapper
2. All outgoing HTTP requests include X-Correlation-ID header (UUID v4)
3. LoggingService.logApi() logs endpoint, method, statusCode, durationMs, correlationId
4. All 6 services use ApiClient().dio instead of standalone Dio()
5. Log level varies by status: INFO for 2xx, WARNING for 4xx, ERROR for 5xx/null
6. flutter analyze passes with no issues
7. flutter build web succeeds
</success_criteria>

<output>
After completion, create `.planning/phases/46-frontend-http-integration/46-01-SUMMARY.md`

Use frontmatter template:
```yaml
---
phase: 46-frontend-http-integration
plan: 01
subsystem: frontend-http
tags: [dio, interceptor, correlation-id, api-logging]
requires: [45-frontend-logging-foundation]
provides:
  - ApiClient singleton with shared Dio instance
  - Correlation ID header injection
  - API call logging with duration
affects: [48-frontend-backend-flush]
tech-stack:
  added: []
  patterns:
    - Singleton ApiClient pattern
    - Dio InterceptorsWrapper for cross-cutting concerns
    - Extra map for request-scoped data
decisions: []
key-files:
  created:
    - frontend/lib/services/api_client.dart
  modified:
    - frontend/lib/services/logging_service.dart
    - frontend/lib/services/auth_service.dart
    - frontend/lib/services/project_service.dart
    - frontend/lib/services/thread_service.dart
    - frontend/lib/services/document_service.dart
    - frontend/lib/services/ai_service.dart
    - frontend/lib/services/artifact_service.dart
---
```
</output>
