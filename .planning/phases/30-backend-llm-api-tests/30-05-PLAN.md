---
phase: 30-backend-llm-api-tests
plan: 05
type: execute
wave: 2
depends_on: [30-01, 30-02, 30-03, 30-04]
files_modified:
  - backend/tests/api/test_conversation_routes.py
  - backend/tests/api/test_artifact_routes.py
  - backend/tests/api/test_error_consistency.py
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Conversations route returns SSE stream with text_delta and message_complete events"
    - "Conversations route returns 429 when budget exceeded"
    - "Artifacts routes return correct status codes for list, get, export"
    - "All API routes return errors in consistent {detail: string} format"
    - "Error consistency tests verify format across all major endpoints"
  artifacts:
    - path: "backend/tests/api/test_conversation_routes.py"
      provides: "Conversations router contract tests"
      min_lines: 80
    - path: "backend/tests/api/test_artifact_routes.py"
      provides: "Artifacts router contract tests"
      min_lines: 60
    - path: "backend/tests/api/test_error_consistency.py"
      provides: "Cross-route error format verification"
      min_lines: 60
  key_links:
    - from: "backend/tests/api/test_conversation_routes.py"
      to: "/api/threads/{id}/chat"
      via: "client.stream"
      pattern: "client\\.stream.*\"/api/threads"
    - from: "backend/tests/api/test_error_consistency.py"
      to: "response.json()['detail']"
      via: "assertion"
      pattern: "response\\.json\\(\\)\\[.detail.\\]"
---

<objective>
Create API contract tests for Conversations, Artifacts, and error consistency verification

Purpose: Verify chat streaming, artifact endpoints, and consistent error format across all routes (BAPI-05, BAPI-06, BAPI-07)

Output: Test files for conversations, artifacts, and cross-route error format verification
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/30-backend-llm-api-tests/30-RESEARCH.md
@backend/app/routes/conversations.py
@backend/app/routes/artifacts.py
@backend/tests/fixtures/sse_helpers.py
@backend/tests/api/conftest.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Conversations router contract tests</name>
  <files>backend/tests/api/test_conversation_routes.py</files>
  <action>
Create `backend/tests/api/test_conversation_routes.py` with contract tests for chat streaming and message deletion.

**Class: TestStreamChat**
- `test_200_returns_sse_stream`: POST /api/threads/{id}/chat returns EventSource response
- `test_403_without_auth`: POST without token returns 403
- `test_404_thread_not_found`: POST to non-existent thread returns 404
- `test_404_thread_not_owned`: POST to other user's thread returns 404
- `test_429_budget_exceeded`: POST when budget exceeded returns 429
- `test_422_empty_content`: POST with empty content returns 422
- `test_stream_has_expected_events`: Stream contains text_delta and message_complete events

**Class: TestDeleteMessage**
- `test_204_deletes_message`: DELETE /api/threads/{id}/messages/{msg_id} returns 204
- `test_403_without_auth`: DELETE without token returns 403
- `test_404_thread_not_found`: DELETE from non-existent thread returns 404
- `test_404_message_not_found`: DELETE non-existent message returns 404
- `test_404_message_wrong_thread`: DELETE message from different thread returns 404

Note: For SSE streaming tests, mock the AIService to avoid real LLM calls. Use the SSE helpers from Plan 02.

Example tests:
```python
import json
import pytest
from unittest.mock import patch, AsyncMock
from datetime import datetime
from app.models import Project, Thread, Message

class TestStreamChat:
    """Contract tests for POST /api/threads/{id}/chat."""

    @pytest.mark.asyncio
    async def test_200_returns_sse_stream(self, authenticated_client, db_session):
        """Returns EventSource response for chat."""
        # Create project and thread
        project = Project(
            user_id=authenticated_client.test_user.id,
            name="Test Project"
        )
        db_session.add(project)
        await db_session.commit()

        thread = Thread(
            project_id=project.id,
            title="Test Thread",
            model_provider="anthropic",
            last_activity_at=datetime.utcnow()
        )
        db_session.add(thread)
        await db_session.commit()

        # Mock AIService to return simple stream
        async def mock_stream(*args, **kwargs):
            yield {"event": "text_delta", "data": json.dumps({"text": "Hello"})}
            yield {"event": "message_complete", "data": json.dumps({"content": "Hello", "usage": {"input_tokens": 10, "output_tokens": 5}})}

        with patch('app.routes.conversations.AIService') as MockAI:
            mock_service = MockAI.return_value
            mock_service.stream_chat = mock_stream

            # Mock budget check
            with patch('app.routes.conversations.check_user_budget', return_value=True):
                async with authenticated_client.stream(
                    "POST",
                    f"/api/threads/{thread.id}/chat",
                    json={"content": "Hi"}
                ) as response:
                    assert response.status_code == 200
                    assert "text/event-stream" in response.headers.get("content-type", "")

    @pytest.mark.asyncio
    async def test_403_without_auth(self, client, db_session):
        """Returns 403 without authentication."""
        response = await client.post(
            f"/api/threads/{uuid4()}/chat",
            json={"content": "Hi"}
        )
        assert response.status_code == 403

    @pytest.mark.asyncio
    async def test_429_budget_exceeded(self, authenticated_client, db_session):
        """Returns 429 when budget is exceeded."""
        # Create thread
        thread = Thread(
            user_id=authenticated_client.test_user.id,
            title="Test Thread",
            model_provider="anthropic",
            last_activity_at=datetime.utcnow()
        )
        db_session.add(thread)
        await db_session.commit()

        # Mock budget check to return False
        with patch('app.routes.conversations.check_user_budget', return_value=False):
            response = await authenticated_client.post(
                f"/api/threads/{thread.id}/chat",
                json={"content": "Hi"}
            )

            assert response.status_code == 429
            assert "budget exceeded" in response.json()["detail"].lower()


class TestDeleteMessage:
    """Contract tests for DELETE /api/threads/{id}/messages/{msg_id}."""

    @pytest.mark.asyncio
    async def test_204_deletes_message(self, authenticated_client, db_session):
        """Returns 204 on successful message delete."""
        # Create thread and message
        thread = Thread(
            user_id=authenticated_client.test_user.id,
            title="Test Thread",
            model_provider="anthropic",
            last_activity_at=datetime.utcnow()
        )
        db_session.add(thread)
        await db_session.commit()

        msg = Message(thread_id=thread.id, role="user", content="Hello")
        db_session.add(msg)
        await db_session.commit()

        response = await authenticated_client.delete(
            f"/api/threads/{thread.id}/messages/{msg.id}"
        )

        assert response.status_code == 204

    @pytest.mark.asyncio
    async def test_404_message_not_found(self, authenticated_client, db_session):
        """Returns 404 for non-existent message."""
        thread = Thread(
            user_id=authenticated_client.test_user.id,
            title="Test Thread",
            model_provider="anthropic",
            last_activity_at=datetime.utcnow()
        )
        db_session.add(thread)
        await db_session.commit()

        response = await authenticated_client.delete(
            f"/api/threads/{thread.id}/messages/{uuid4()}"
        )

        assert response.status_code == 404
```

Remember to import uuid4 at the top of the file.
  </action>
  <verify>
```bash
cd G:\git_repos\BA_assistant\backend
pytest tests/api/test_conversation_routes.py -v
```
All tests pass.
  </verify>
  <done>Conversations router has contract tests for chat streaming, budget check, message deletion</done>
</task>

<task type="auto">
  <name>Task 2: Create Artifacts router contract tests</name>
  <files>backend/tests/api/test_artifact_routes.py</files>
  <action>
Create `backend/tests/api/test_artifact_routes.py` with contract tests for artifact endpoints.

**Class: TestListThreadArtifacts**
- `test_200_returns_array`: GET /api/threads/{id}/artifacts returns array
- `test_403_without_auth`: GET without token returns 403
- `test_404_thread_not_found`: GET for non-existent thread returns 404
- `test_404_thread_not_owned`: GET for other user's thread returns 404
- `test_empty_list_no_artifacts`: GET returns [] when no artifacts

**Class: TestGetArtifact**
- `test_200_with_content`: GET /api/artifacts/{id} returns artifact with content
- `test_403_without_auth`: GET without token returns 403
- `test_404_not_found`: GET for non-existent artifact returns 404
- `test_404_not_owned`: GET for other user's artifact returns 404
- `test_response_schema`: Response has id, thread_id, artifact_type, title, content_markdown

**Class: TestExportArtifact**
- `test_200_export_markdown`: GET /api/artifacts/{id}/export/md returns markdown file
- `test_200_export_docx`: GET /api/artifacts/{id}/export/docx returns docx file
- `test_403_without_auth`: GET without token returns 403
- `test_404_not_found`: GET for non-existent artifact returns 404
- `test_content_disposition_header`: Response has Content-Disposition with filename

Note: PDF export test is skipped on Windows due to GTK dependency.

Example tests:
```python
import pytest
from uuid import uuid4
from datetime import datetime
from app.models import Project, Thread, Artifact, ArtifactType

class TestListThreadArtifacts:
    """Contract tests for GET /api/threads/{id}/artifacts."""

    @pytest.mark.asyncio
    async def test_200_returns_array(self, authenticated_client, db_session):
        """Returns array of artifacts."""
        # Create project, thread, and artifact
        project = Project(
            user_id=authenticated_client.test_user.id,
            name="Test Project"
        )
        db_session.add(project)
        await db_session.commit()

        thread = Thread(
            project_id=project.id,
            title="Test Thread",
            model_provider="anthropic",
            last_activity_at=datetime.utcnow()
        )
        db_session.add(thread)
        await db_session.commit()

        artifact = Artifact(
            thread_id=thread.id,
            artifact_type=ArtifactType.BRD,
            title="Test BRD",
            content_markdown="# Test\n\nContent"
        )
        db_session.add(artifact)
        await db_session.commit()

        response = await authenticated_client.get(f"/api/threads/{thread.id}/artifacts")

        assert response.status_code == 200
        data = response.json()
        assert isinstance(data, list)
        assert len(data) == 1
        assert data[0]["title"] == "Test BRD"


class TestGetArtifact:
    """Contract tests for GET /api/artifacts/{id}."""

    @pytest.mark.asyncio
    async def test_200_with_content(self, authenticated_client, db_session):
        """Returns artifact with full content."""
        project = Project(
            user_id=authenticated_client.test_user.id,
            name="Test Project"
        )
        db_session.add(project)
        await db_session.commit()

        thread = Thread(
            project_id=project.id,
            title="Test Thread",
            model_provider="anthropic",
            last_activity_at=datetime.utcnow()
        )
        db_session.add(thread)
        await db_session.commit()

        artifact = Artifact(
            thread_id=thread.id,
            artifact_type=ArtifactType.BRD,
            title="Test BRD",
            content_markdown="# Business Requirements\n\n## Overview\n\nTest content"
        )
        db_session.add(artifact)
        await db_session.commit()

        response = await authenticated_client.get(f"/api/artifacts/{artifact.id}")

        assert response.status_code == 200
        data = response.json()
        assert data["title"] == "Test BRD"
        assert "# Business Requirements" in data["content_markdown"]
        assert data["artifact_type"] == "brd"


class TestExportArtifact:
    """Contract tests for GET /api/artifacts/{id}/export/{format}."""

    @pytest.mark.asyncio
    async def test_200_export_markdown(self, authenticated_client, db_session):
        """Returns markdown file with Content-Disposition."""
        project = Project(
            user_id=authenticated_client.test_user.id,
            name="Test Project"
        )
        db_session.add(project)
        await db_session.commit()

        thread = Thread(
            project_id=project.id,
            title="Test Thread",
            model_provider="anthropic",
            last_activity_at=datetime.utcnow()
        )
        db_session.add(thread)
        await db_session.commit()

        artifact = Artifact(
            thread_id=thread.id,
            artifact_type=ArtifactType.BRD,
            title="Test BRD",
            content_markdown="# Test"
        )
        db_session.add(artifact)
        await db_session.commit()

        response = await authenticated_client.get(f"/api/artifacts/{artifact.id}/export/md")

        assert response.status_code == 200
        assert "Content-Disposition" in response.headers
        assert "attachment" in response.headers["Content-Disposition"]
        assert ".md" in response.headers["Content-Disposition"]
```
  </action>
  <verify>
```bash
cd G:\git_repos\BA_assistant\backend
pytest tests/api/test_artifact_routes.py -v
```
All tests pass.
  </verify>
  <done>Artifacts router has contract tests for list, get, export with auth and error cases</done>
</task>

<task type="auto">
  <name>Task 3: Create error consistency verification tests</name>
  <files>backend/tests/api/test_error_consistency.py</files>
  <action>
Create `backend/tests/api/test_error_consistency.py` to verify all API routes use consistent error format.

This test file verifies BAPI-07: all error responses follow the {"detail": "message"} format.

**Class: TestErrorResponseFormat**
Test that various error conditions across different routers return consistent format.

- `test_auth_401_format`: Auth 401 errors have {"detail": str}
- `test_auth_403_format`: Auth 403 errors have {"detail": str}
- `test_projects_404_format`: Project 404 errors have {"detail": str}
- `test_projects_422_format`: Project 422 validation errors have {"detail": list}
- `test_documents_400_format`: Document 400 errors have {"detail": str}
- `test_threads_400_format`: Thread 400 errors have {"detail": str}
- `test_threads_404_format`: Thread 404 errors have {"detail": str}
- `test_conversations_429_format`: Conversation 429 budget error has {"detail": str}
- `test_artifacts_404_format`: Artifact 404 errors have {"detail": str}

**Class: TestErrorMessageClarity**
Test that error messages are user-friendly and consistent.

- `test_not_found_message_consistent`: All 404s say "not found" (not "does not exist")
- `test_unauthorized_message_consistent`: All 403s reference authentication
- `test_validation_provides_field_info`: 422 errors include field name in details

Example tests:
```python
import pytest
from uuid import uuid4
from datetime import datetime
from unittest.mock import patch
from app.models import Thread

class TestErrorResponseFormat:
    """Verify all error responses use consistent format."""

    @pytest.mark.asyncio
    async def test_auth_403_format(self, client):
        """403 errors have {"detail": str} format."""
        response = await client.get("/auth/me")
        assert response.status_code == 403
        data = response.json()
        assert "detail" in data
        assert isinstance(data["detail"], str)

    @pytest.mark.asyncio
    async def test_projects_404_format(self, authenticated_client):
        """Project 404 errors have {"detail": str} format."""
        response = await authenticated_client.get(f"/api/projects/{uuid4()}")
        assert response.status_code == 404
        data = response.json()
        assert "detail" in data
        assert isinstance(data["detail"], str)
        assert "not found" in data["detail"].lower()

    @pytest.mark.asyncio
    async def test_projects_422_format(self, authenticated_client):
        """Project 422 validation errors have proper format."""
        response = await authenticated_client.post(
            "/api/projects",
            json={"description": "Missing name field"}
        )
        assert response.status_code == 422
        data = response.json()
        assert "detail" in data
        # FastAPI validation errors return list of issues
        assert isinstance(data["detail"], list)

    @pytest.mark.asyncio
    async def test_documents_400_format(self, authenticated_client, db_session):
        """Document 400 errors have {"detail": str} format."""
        from io import BytesIO
        from app.models import Project

        project = Project(
            user_id=authenticated_client.test_user.id,
            name="Test"
        )
        db_session.add(project)
        await db_session.commit()

        files = {"file": ("test.pdf", BytesIO(b"fake pdf"), "application/pdf")}
        response = await authenticated_client.post(
            f"/api/projects/{project.id}/documents",
            files=files
        )

        assert response.status_code == 400
        data = response.json()
        assert "detail" in data
        assert isinstance(data["detail"], str)

    @pytest.mark.asyncio
    async def test_threads_400_format(self, authenticated_client):
        """Thread 400 errors have {"detail": str} format."""
        response = await authenticated_client.post(
            "/api/threads",
            json={"title": "Test", "model_provider": "invalid"}
        )

        assert response.status_code == 400
        data = response.json()
        assert "detail" in data
        assert isinstance(data["detail"], str)

    @pytest.mark.asyncio
    async def test_conversations_429_format(self, authenticated_client, db_session):
        """Conversation 429 budget error has {"detail": str} format."""
        thread = Thread(
            user_id=authenticated_client.test_user.id,
            title="Test",
            model_provider="anthropic",
            last_activity_at=datetime.utcnow()
        )
        db_session.add(thread)
        await db_session.commit()

        with patch('app.routes.conversations.check_user_budget', return_value=False):
            response = await authenticated_client.post(
                f"/api/threads/{thread.id}/chat",
                json={"content": "Hi"}
            )

        assert response.status_code == 429
        data = response.json()
        assert "detail" in data
        assert isinstance(data["detail"], str)


class TestErrorMessageClarity:
    """Verify error messages are clear and consistent."""

    @pytest.mark.asyncio
    async def test_not_found_uses_consistent_phrasing(self, authenticated_client):
        """All 404 errors use 'not found' phrasing."""
        endpoints = [
            f"/api/projects/{uuid4()}",
            f"/api/threads/{uuid4()}",
            f"/api/documents/{uuid4()}",
            f"/api/artifacts/{uuid4()}",
        ]

        for endpoint in endpoints:
            response = await authenticated_client.get(endpoint)
            if response.status_code == 404:
                data = response.json()
                assert "not found" in data["detail"].lower(), f"Endpoint {endpoint} doesn't use 'not found' phrasing"
```
  </action>
  <verify>
```bash
cd G:\git_repos\BA_assistant\backend
pytest tests/api/test_error_consistency.py -v
```
All tests pass.
  </verify>
  <done>Error consistency tests verify {"detail": string} format across all major endpoints</done>
</task>

</tasks>

<verification>
Run all API tests including the new files:
```bash
cd G:\git_repos\BA_assistant\backend
pytest tests/api/ -v --tb=short
```

Expected: All API tests pass (60+ tests total)

Run full test suite:
```bash
cd G:\git_repos\BA_assistant\backend
pytest tests/api/ tests/unit/llm/ tests/unit/services/test_sse_streaming.py tests/unit/services/test_document_search.py -v
```
</verification>

<success_criteria>
- test_conversation_routes.py has tests for chat streaming, budget check, message delete
- test_artifact_routes.py has tests for list, get, export
- test_error_consistency.py verifies {"detail": str} format across all routes
- All error messages use consistent phrasing ("not found" vs "does not exist")
- All tests pass with `pytest tests/api/ -v`
- BAPI-05, BAPI-06, BAPI-07 requirements verified
</success_criteria>

<output>
After completion, create `.planning/phases/30-backend-llm-api-tests/30-05-SUMMARY.md`
</output>
