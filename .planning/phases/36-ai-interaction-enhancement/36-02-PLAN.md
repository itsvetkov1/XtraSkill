---
phase: 36-ai-interaction-enhancement
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/pubspec.yaml
  - frontend/lib/models/artifact.dart
  - frontend/lib/services/artifact_service.dart
  - frontend/lib/services/ai_service.dart
autonomous: true

must_haves:
  truths:
    - "Artifact model exists with type enum matching backend values"
    - "ArtifactService can fetch artifact by ID and export to file"
    - "AIService yields ArtifactCreatedEvent when backend emits artifact_created SSE"
    - "file_saver dependency added to pubspec.yaml"
  artifacts:
    - path: "frontend/lib/models/artifact.dart"
      provides: "Artifact model with ArtifactType enum"
      exports: ["Artifact", "ArtifactType"]
    - path: "frontend/lib/services/artifact_service.dart"
      provides: "Artifact API service with export functionality"
      exports: ["ArtifactService"]
    - path: "frontend/lib/services/ai_service.dart"
      provides: "ArtifactCreatedEvent and DocumentsUsedEvent handling"
      contains: "ArtifactCreatedEvent"
  key_links:
    - from: "frontend/lib/services/artifact_service.dart"
      to: "/api/artifacts/{id}/export/{format}"
      via: "dio HTTP request"
      pattern: "exportArtifact.*format"
    - from: "frontend/lib/services/ai_service.dart"
      to: "artifact_created SSE event"
      via: "switch case in streamChat"
      pattern: "case 'artifact_created'"
---

<objective>
Create frontend foundation for artifact handling

Purpose: Establish models, services, and SSE event handling needed for artifact UI (ART-01 through ART-04)
Output: Artifact model, ArtifactService with export, AIService extended with artifact/source events
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/36-ai-interaction-enhancement/36-RESEARCH.md

@frontend/pubspec.yaml
@frontend/lib/services/ai_service.dart
@frontend/lib/models/document.dart
@backend/app/routes/artifacts.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add file_saver dependency and create Artifact model</name>
  <files>frontend/pubspec.yaml, frontend/lib/models/artifact.dart</files>
  <action>
1. Add file_saver to pubspec.yaml dependencies:
   ```yaml
   file_saver: ^0.2.14
   ```

2. Run `flutter pub get` after updating pubspec.yaml.

3. Create `frontend/lib/models/artifact.dart`:

```dart
/// Artifact model for generated business analysis documents.
library;

import 'package:flutter/material.dart';

/// Types of business analysis artifacts (matches backend ArtifactType enum)
enum ArtifactType {
  userStories('user_stories'),
  acceptanceCriteria('acceptance_criteria'),
  requirementsDoc('requirements_doc'),
  brd('brd');

  final String value;
  const ArtifactType(this.value);

  static ArtifactType fromJson(String json) {
    return ArtifactType.values.firstWhere(
      (t) => t.value == json,
      orElse: () => ArtifactType.requirementsDoc,
    );
  }

  String get displayName {
    switch (this) {
      case ArtifactType.userStories:
        return 'User Stories';
      case ArtifactType.acceptanceCriteria:
        return 'Acceptance Criteria';
      case ArtifactType.requirementsDoc:
        return 'Requirements Doc';
      case ArtifactType.brd:
        return 'BRD';
    }
  }

  IconData get icon {
    switch (this) {
      case ArtifactType.userStories:
        return Icons.list_alt;
      case ArtifactType.acceptanceCriteria:
        return Icons.checklist;
      case ArtifactType.requirementsDoc:
        return Icons.description;
      case ArtifactType.brd:
        return Icons.article;
    }
  }

  String get description {
    switch (this) {
      case ArtifactType.userStories:
        return 'Generate user stories from requirements';
      case ArtifactType.acceptanceCriteria:
        return 'Create acceptance criteria for features';
      case ArtifactType.requirementsDoc:
        return 'Generate requirements documentation';
      case ArtifactType.brd:
        return 'Create Business Requirements Document';
    }
  }
}

/// Artifact model representing a generated document
class Artifact {
  final String id;
  final String threadId;
  final ArtifactType artifactType;
  final String title;
  final String? contentMarkdown; // Only loaded on expand (lazy)
  final DateTime createdAt;

  Artifact({
    required this.id,
    required this.threadId,
    required this.artifactType,
    required this.title,
    this.contentMarkdown,
    required this.createdAt,
  });

  factory Artifact.fromJson(Map<String, dynamic> json) {
    return Artifact(
      id: json['id'],
      threadId: json['thread_id'],
      artifactType: ArtifactType.fromJson(json['artifact_type']),
      title: json['title'],
      contentMarkdown: json['content_markdown'],
      createdAt: DateTime.parse(json['created_at']),
    );
  }

  /// Create artifact from SSE event (minimal data, no content)
  factory Artifact.fromEvent({
    required String id,
    required String artifactType,
    required String title,
    required String threadId,
  }) {
    return Artifact(
      id: id,
      threadId: threadId,
      artifactType: ArtifactType.fromJson(artifactType),
      title: title,
      contentMarkdown: null, // Content loaded on demand
      createdAt: DateTime.now(),
    );
  }

  /// Copy with updated content (for lazy loading)
  Artifact copyWithContent(String content) {
    return Artifact(
      id: id,
      threadId: threadId,
      artifactType: artifactType,
      title: title,
      contentMarkdown: content,
      createdAt: createdAt,
    );
  }
}
```

Use exact backend enum values: `user_stories`, `acceptance_criteria`, `requirements_doc`, `brd`.
  </action>
  <verify>
```bash
cd frontend && flutter pub get && flutter analyze lib/models/artifact.dart
```
  </verify>
  <done>
- file_saver dependency added to pubspec.yaml
- Artifact model exists with ArtifactType enum matching backend values
- Model supports lazy content loading via fromEvent and copyWithContent
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ArtifactService with export functionality</name>
  <files>frontend/lib/services/artifact_service.dart</files>
  <action>
Create `frontend/lib/services/artifact_service.dart`:

```dart
/// Artifact service for fetching and exporting artifacts.
library;

import 'dart:typed_data';

import 'package:dio/dio.dart';
import 'package:file_saver/file_saver.dart';
import 'package:flutter_secure_storage/flutter_secure_storage.dart';

import '../core/config.dart';
import '../models/artifact.dart';

/// Service for artifact API operations
class ArtifactService {
  final Dio _dio;
  final FlutterSecureStorage _storage;
  static const String _tokenKey = 'auth_token';

  ArtifactService({Dio? dio, FlutterSecureStorage? storage})
      : _dio = dio ?? Dio(),
        _storage = storage ?? const FlutterSecureStorage();

  Future<Map<String, String>> _getHeaders() async {
    final token = await _storage.read(key: _tokenKey);
    if (token == null) {
      throw Exception('Not authenticated');
    }
    return {
      'Authorization': 'Bearer $token',
      'Content-Type': 'application/json',
    };
  }

  /// Fetch artifact with full content
  Future<Artifact> getArtifact(String artifactId) async {
    try {
      final headers = await _getHeaders();
      final response = await _dio.get(
        '$apiBaseUrl/api/artifacts/$artifactId',
        options: Options(headers: headers),
      );
      return Artifact.fromJson(response.data);
    } on DioException catch (e) {
      if (e.response?.statusCode == 404) {
        throw Exception('Artifact not found');
      }
      throw Exception('Failed to load artifact: ${e.message}');
    }
  }

  /// List artifacts for a thread (without content)
  Future<List<Artifact>> listThreadArtifacts(String threadId) async {
    try {
      final headers = await _getHeaders();
      final response = await _dio.get(
        '$apiBaseUrl/api/threads/$threadId/artifacts',
        options: Options(headers: headers),
      );
      return (response.data as List)
          .map((json) => Artifact.fromJson(json))
          .toList();
    } on DioException catch (e) {
      if (e.response?.statusCode == 404) {
        throw Exception('Thread not found');
      }
      throw Exception('Failed to load artifacts: ${e.message}');
    }
  }

  /// Export artifact and trigger download
  ///
  /// [format] must be one of: 'md', 'pdf', 'docx'
  /// Returns the filename that was downloaded.
  Future<String> exportArtifact({
    required String artifactId,
    required String format,
    required String title,
  }) async {
    try {
      final headers = await _getHeaders();
      final response = await _dio.get<List<int>>(
        '$apiBaseUrl/api/artifacts/$artifactId/export/$format',
        options: Options(
          responseType: ResponseType.bytes,
          headers: headers,
        ),
      );

      // Generate meaningful filename per PITFALL-12
      final safeName = title
          .replaceAll(RegExp(r'[^\w\s-]'), '')
          .replaceAll(RegExp(r'\s+'), '_')
          .toLowerCase();
      final date = DateTime.now().toIso8601String().split('T')[0];
      final filename = '${safeName}_$date';

      await FileSaver.instance.saveFile(
        name: filename,
        bytes: Uint8List.fromList(response.data!),
        ext: format,
        mimeType: _getMimeType(format),
      );

      return '$filename.$format';
    } on DioException catch (e) {
      if (e.response?.statusCode == 404) {
        throw Exception('Artifact not found');
      } else if (e.response?.statusCode == 500) {
        // PDF export may fail without GTK
        throw Exception('Export failed - PDF may require additional setup');
      }
      throw Exception('Export failed: ${e.message}');
    }
  }

  MimeType _getMimeType(String format) {
    switch (format) {
      case 'md':
        return MimeType.text;
      case 'pdf':
        return MimeType.pdf;
      case 'docx':
        return MimeType.microsoftWord;
      default:
        return MimeType.other;
    }
  }
}
```

Key points:
- Uses backend export endpoints (don't hand-roll PDF/DOCX generation)
- Generates meaningful filenames with date per PITFALL-12
- Handles error cases gracefully
  </action>
  <verify>
```bash
cd frontend && flutter analyze lib/services/artifact_service.dart
```
  </verify>
  <done>
- ArtifactService created with getArtifact, listThreadArtifacts, exportArtifact methods
- Export uses backend endpoints and file_saver for cross-platform download
- Meaningful filenames generated per PITFALL-12
  </done>
</task>

<task type="auto">
  <name>Task 3: Extend AIService with ArtifactCreatedEvent and DocumentsUsedEvent</name>
  <files>frontend/lib/services/ai_service.dart</files>
  <action>
Update `frontend/lib/services/ai_service.dart` to handle new SSE events:

1. Add new event classes after existing ones (around line 43):

```dart
/// Artifact created event - generated artifact saved
class ArtifactCreatedEvent extends ChatEvent {
  final String id;
  final String artifactType;
  final String title;
  ArtifactCreatedEvent({
    required this.id,
    required this.artifactType,
    required this.title,
  });
}

/// Documents used data - attached to MessageCompleteEvent
class DocumentSource {
  final String id;
  final String filename;
  DocumentSource({required this.id, required this.filename});

  factory DocumentSource.fromJson(Map<String, dynamic> json) {
    return DocumentSource(
      id: json['id'] as String,
      filename: json['filename'] as String,
    );
  }
}
```

2. Update MessageCompleteEvent to include documents used (replace existing class):

```dart
/// Message complete event - response finished with usage stats
class MessageCompleteEvent extends ChatEvent {
  final String content;
  final int inputTokens;
  final int outputTokens;
  final List<DocumentSource> documentsUsed;
  MessageCompleteEvent({
    required this.content,
    required this.inputTokens,
    required this.outputTokens,
    this.documentsUsed = const [],
  });
}
```

3. In streamChat switch statement (around line 112), add case for artifact_created:

```dart
case 'artifact_created':
  yield ArtifactCreatedEvent(
    id: data['id'] as String? ?? '',
    artifactType: data['artifact_type'] as String? ?? 'requirements_doc',
    title: data['title'] as String? ?? 'Untitled',
  );
  break;
```

4. Update the message_complete case to parse documents_used:

```dart
case 'message_complete':
  final usage = data['usage'] as Map<String, dynamic>?;
  final docsUsedJson = data['documents_used'] as List<dynamic>?;
  final docsUsed = docsUsedJson
      ?.map((d) => DocumentSource.fromJson(d as Map<String, dynamic>))
      .toList() ?? [];
  yield MessageCompleteEvent(
    content: data['content'] as String? ?? '',
    inputTokens: usage?['input_tokens'] as int? ?? 0,
    outputTokens: usage?['output_tokens'] as int? ?? 0,
    documentsUsed: docsUsed,
  );
  break;
```
  </action>
  <verify>
```bash
cd frontend && flutter analyze lib/services/ai_service.dart
```
  </verify>
  <done>
- ArtifactCreatedEvent class added for artifact_created SSE event
- DocumentSource class added for source attribution
- MessageCompleteEvent extended with documentsUsed list
- streamChat yields ArtifactCreatedEvent when backend emits it
  </done>
</task>

</tasks>

<verification>
1. `flutter pub get` succeeds with file_saver dependency
2. `flutter analyze` passes for all modified files
3. Models match backend API schema (ArtifactType values, Artifact fields)
</verification>

<success_criteria>
- file_saver ^0.2.14 in pubspec.yaml
- Artifact model with ArtifactType enum matching backend values
- ArtifactService with getArtifact, listThreadArtifacts, exportArtifact methods
- AIService yields ArtifactCreatedEvent and DocumentsUsedEvent from SSE stream
</success_criteria>

<output>
After completion, create `.planning/phases/36-ai-interaction-enhancement/36-02-SUMMARY.md`
</output>
