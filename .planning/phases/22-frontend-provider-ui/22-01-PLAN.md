---
phase: 22-frontend-provider-ui
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/lib/providers/provider_provider.dart
  - frontend/lib/main.dart
  - frontend/lib/models/thread.dart
  - frontend/lib/services/thread_service.dart
autonomous: true

must_haves:
  truths:
    - "ProviderProvider loads saved provider preference at app startup"
    - "Provider selection persists across app restarts"
    - "Thread model includes modelProvider field from backend response"
    - "Thread creation API call includes model_provider parameter"
  artifacts:
    - path: "frontend/lib/providers/provider_provider.dart"
      provides: "LLM provider state management with persistence"
      exports: ["ProviderProvider"]
    - path: "frontend/lib/main.dart"
      provides: "ProviderProvider registration in MultiProvider"
      contains: "ProviderProvider"
    - path: "frontend/lib/models/thread.dart"
      provides: "Thread model with modelProvider field"
      contains: "modelProvider"
    - path: "frontend/lib/services/thread_service.dart"
      provides: "Thread creation with provider parameter"
      contains: "model_provider"
  key_links:
    - from: "frontend/lib/main.dart"
      to: "frontend/lib/providers/provider_provider.dart"
      via: "ChangeNotifierProvider.value"
      pattern: "ProviderProvider\\.load"
    - from: "frontend/lib/services/thread_service.dart"
      to: "backend API"
      via: "POST body with model_provider"
      pattern: "model_provider.*provider"
---

<objective>
Create core provider infrastructure for LLM provider selection.

Purpose: Establish state management and persistence for provider preference, update Thread model and service to support provider binding. This foundation enables Plan 02 to add UI components.

Output: ProviderProvider class modeled on ThemeProvider, Thread model with modelProvider field, ThreadService accepting provider parameter on create.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/22-frontend-provider-ui/22-RESEARCH.md
@.planning/phases/22-frontend-provider-ui/22-CONTEXT.md

# Reference implementation for persistence pattern
@frontend/lib/providers/theme_provider.dart

# Files to modify
@frontend/lib/main.dart
@frontend/lib/models/thread.dart
@frontend/lib/services/thread_service.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create ProviderProvider with SharedPreferences persistence</name>
  <files>frontend/lib/providers/provider_provider.dart</files>
  <action>
Create ProviderProvider modeled exactly on ThemeProvider pattern:

1. Create `frontend/lib/providers/provider_provider.dart`:
   - Import flutter/material.dart and shared_preferences
   - Class extends ChangeNotifier with SharedPreferences field
   - Private `_selectedProvider` field (String, default: 'anthropic')
   - Static const `_providerKey = 'defaultLlmProvider'`
   - Private constructor accepting SharedPreferences and optional initialProvider
   - Static async `load(SharedPreferences prefs)` factory:
     - Read saved string from prefs, default to 'anthropic' if null
     - Return ProviderProvider instance with loaded value
     - Wrap in try/catch, default to 'anthropic' on error
   - Getter `selectedProvider` returns current value
   - Getter `providers` returns list: `['anthropic', 'google', 'deepseek']`
   - Async `setProvider(String provider)` method:
     - Validate provider is in allowed list (throw if not)
     - Update _selectedProvider
     - Persist to prefs via setString
     - Call notifyListeners()

Add doc comments matching ThemeProvider style.
  </action>
  <verify>
File exists at frontend/lib/providers/provider_provider.dart with:
- ProviderProvider class extending ChangeNotifier
- load() static factory method
- setProvider() async method
- selectedProvider getter
  </verify>
  <done>
ProviderProvider created with load/setProvider/selectedProvider matching ThemeProvider pattern.
  </done>
</task>

<task type="auto">
  <name>Task 2: Register ProviderProvider in main.dart</name>
  <files>frontend/lib/main.dart</files>
  <action>
Update main.dart to load and register ProviderProvider:

1. Add import: `import 'providers/provider_provider.dart';`

2. In main() after themeProvider load (~line 40), add:
   ```dart
   final providerProvider = await ProviderProvider.load(prefs);
   ```

3. Update runApp call to pass providerProvider:
   ```dart
   runApp(MyApp(
     themeProvider: themeProvider,
     navigationProvider: navigationProvider,
     providerProvider: providerProvider,
   ));
   ```

4. Update MyApp class:
   - Add `final ProviderProvider providerProvider;` field
   - Update constructor to require providerProvider
   - Add ChangeNotifierProvider.value for providerProvider in MultiProvider:
     ```dart
     ChangeNotifierProvider.value(value: widget.providerProvider),
     ```

Place ProviderProvider registration after ThemeProvider and NavigationProvider in the providers list.
  </action>
  <verify>
Run `flutter analyze` - no errors related to ProviderProvider.
Check main.dart contains:
- import for provider_provider.dart
- ProviderProvider.load() call in main()
- providerProvider passed to MyApp
- ChangeNotifierProvider.value for providerProvider in MultiProvider
  </verify>
  <done>
ProviderProvider loaded at app startup and registered in MultiProvider, available via context.read/watch/Consumer.
  </done>
</task>

<task type="auto">
  <name>Task 3: Add modelProvider field to Thread model and service</name>
  <files>frontend/lib/models/thread.dart, frontend/lib/services/thread_service.dart</files>
  <action>
Update Thread model:

1. In Thread class, add nullable field:
   ```dart
   final String? modelProvider;
   ```

2. Update constructor to accept modelProvider parameter:
   ```dart
   Thread({
     // ... existing params
     this.modelProvider,
   });
   ```

3. Update fromJson factory:
   ```dart
   modelProvider: json['model_provider'] as String?,
   ```

4. Update toJson method:
   ```dart
   if (modelProvider != null) 'model_provider': modelProvider,
   ```

Update ThreadService:

1. Modify createThread signature to accept optional provider:
   ```dart
   Future<Thread> createThread(String projectId, String? title, {String? provider}) async {
   ```

2. Update data body in createThread:
   ```dart
   data: {
     if (title != null && title.isNotEmpty) 'title': title,
     if (provider != null) 'model_provider': provider,
   },
   ```

Note: Using named parameter `{String? provider}` keeps backward compatibility with existing callers.
  </action>
  <verify>
Run `flutter analyze` - no errors.
Check thread.dart contains `modelProvider` field and fromJson/toJson handling.
Check thread_service.dart createThread accepts provider parameter and includes model_provider in request body.
  </verify>
  <done>
Thread model parses model_provider from backend, ThreadService passes model_provider on create.
  </done>
</task>

</tasks>

<verification>
1. Run `flutter analyze` from frontend directory - no errors
2. Verify ProviderProvider follows ThemeProvider pattern (compare structure)
3. Verify main.dart loads ProviderProvider before runApp
4. Verify Thread model includes modelProvider field
5. Verify ThreadService createThread accepts provider parameter
</verification>

<success_criteria>
- ProviderProvider loads from SharedPreferences at startup (default: anthropic)
- ProviderProvider.setProvider persists to SharedPreferences immediately
- Thread.fromJson parses model_provider field
- ThreadService.createThread accepts optional provider parameter
- All code passes flutter analyze
</success_criteria>

<output>
After completion, create `.planning/phases/22-frontend-provider-ui/22-01-SUMMARY.md`
</output>
