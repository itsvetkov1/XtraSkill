---
phase: 43-backend-logging-foundation
plan: 02
type: execute
wave: 2
depends_on: ["43-01"]
files_modified:
  - backend/app/middleware/__init__.py
  - backend/app/middleware/logging_middleware.py
  - backend/main.py
autonomous: true

must_haves:
  truths:
    - "HTTP requests are logged with method, path, status, duration, and correlation ID"
    - "HTTP responses are logged with status code and duration"
    - "Correlation ID is generated for each request and propagated via contextvars"
  artifacts:
    - path: "backend/app/middleware/logging_middleware.py"
      provides: "LoggingMiddleware ASGI middleware"
      min_lines: 60
    - path: "backend/app/middleware/__init__.py"
      provides: "Middleware package exports"
  key_links:
    - from: "backend/main.py"
      to: "backend/app/middleware/logging_middleware.py"
      via: "add_middleware call"
      pattern: "app.add_middleware.*LoggingMiddleware"
    - from: "backend/app/middleware/logging_middleware.py"
      to: "backend/app/services/logging_service.py"
      via: "get_logging_service import"
      pattern: "from app.services.logging_service import"
---

<objective>
Create LoggingMiddleware for HTTP request/response logging with correlation ID propagation.

Purpose: Every HTTP request/response produces structured log entries with timing and correlation IDs, enabling request tracing across the stack.

Output: LoggingMiddleware, middleware package, main.py integration
</objective>

<execution_context>
@C:\Users\ibcve\.claude/get-shit-done/workflows/execute-plan.md
@C:\Users\ibcve\.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/43-backend-logging-foundation/43-01-SUMMARY.md
@.planning/research/SUMMARY_v1.9.5.md
@backend/main.py
@backend/app/services/logging_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create middleware package with __init__.py</name>
  <files>backend/app/middleware/__init__.py</files>
  <action>
Create the middleware package directory and __init__.py file:

1. Create directory: backend/app/middleware/
2. Create __init__.py with exports:

```python
"""Middleware package for cross-cutting concerns."""
from app.middleware.logging_middleware import LoggingMiddleware

__all__ = ["LoggingMiddleware"]
```

This follows the pattern used by other packages in the codebase (services, routes).
  </action>
  <verify>
Run: python -c "from app.middleware import LoggingMiddleware" (will fail until Task 2)
Directory exists: backend/app/middleware/__init__.py
  </verify>
  <done>Middleware package created with __init__.py exporting LoggingMiddleware</done>
</task>

<task type="auto">
  <name>Task 2: Create LoggingMiddleware with correlation ID support</name>
  <files>backend/app/middleware/logging_middleware.py</files>
  <action>
Create LoggingMiddleware as ASGI middleware with these capabilities:

1. Generate or extract correlation ID from X-Correlation-ID header
2. Store correlation ID in contextvars for access throughout request
3. Log request start (method, path, correlation ID, user ID if available)
4. Log response (status code, duration)
5. Add X-Correlation-ID to response headers

Implementation:
```python
"""
HTTP request/response logging middleware with correlation ID propagation.

Generates or extracts correlation ID for each request, stores in contextvars,
and logs request/response with timing information.
"""
import time
import uuid
from contextvars import ContextVar
from typing import Callable, Optional

from starlette.middleware.base import BaseHTTPMiddleware
from starlette.requests import Request
from starlette.responses import Response

from app.services.logging_service import get_logging_service

# Context variable for correlation ID - accessible throughout request lifecycle
correlation_id_var: ContextVar[Optional[str]] = ContextVar("correlation_id", default=None)


def get_correlation_id() -> Optional[str]:
    """Get current request's correlation ID from context."""
    return correlation_id_var.get()


class LoggingMiddleware(BaseHTTPMiddleware):
    """
    ASGI middleware for HTTP request/response logging.

    Features:
    - Generates UUID correlation ID if not provided in X-Correlation-ID header
    - Stores correlation ID in contextvars for request-scoped access
    - Logs request start and response completion with timing
    - Adds X-Correlation-ID to response headers for client correlation
    """

    async def dispatch(self, request: Request, call_next: Callable) -> Response:
        """Process request with logging and correlation ID tracking."""
        logging_service = get_logging_service()

        # Extract or generate correlation ID
        correlation_id = request.headers.get("X-Correlation-ID")
        if not correlation_id:
            correlation_id = str(uuid.uuid4())

        # Store in contextvars for access by other code
        correlation_id_var.set(correlation_id)

        # Extract user ID if available (from JWT auth - may be None)
        user_id = getattr(request.state, "user_id", None)

        # Log request start
        start_time = time.perf_counter()
        logging_service.log(
            level="INFO",
            message="HTTP request started",
            category="api",
            correlation_id=correlation_id,
            method=request.method,
            path=str(request.url.path),
            query=str(request.url.query) if request.url.query else None,
            user_id=user_id,
        )

        # Process request
        try:
            response = await call_next(request)
        except Exception as e:
            # Log error and re-raise
            duration_ms = (time.perf_counter() - start_time) * 1000
            logging_service.log(
                level="ERROR",
                message="HTTP request failed",
                category="api",
                correlation_id=correlation_id,
                method=request.method,
                path=str(request.url.path),
                duration_ms=round(duration_ms, 2),
                error=str(e),
                error_type=type(e).__name__,
            )
            raise

        # Calculate duration
        duration_ms = (time.perf_counter() - start_time) * 1000

        # Log response
        logging_service.log(
            level="INFO" if response.status_code < 400 else "WARNING",
            message="HTTP request completed",
            category="api",
            correlation_id=correlation_id,
            method=request.method,
            path=str(request.url.path),
            status_code=response.status_code,
            duration_ms=round(duration_ms, 2),
            user_id=user_id,
        )

        # Add correlation ID to response headers
        response.headers["X-Correlation-ID"] = correlation_id

        return response
```

Key design decisions:
- BaseHTTPMiddleware: Standard Starlette pattern, works with FastAPI
- contextvars: Async-safe request-scoped storage (P-06 prevention)
- time.perf_counter(): High-resolution timing for accurate duration
- Log level varies: INFO for success, WARNING for 4xx/5xx
- Response header: Enables frontend to log with same correlation ID
  </action>
  <verify>
Run:
```bash
cd backend && python -c "
from app.middleware.logging_middleware import LoggingMiddleware, get_correlation_id
print('LoggingMiddleware imported successfully')
"
```
  </verify>
  <done>LoggingMiddleware logs requests/responses with correlation ID propagation via contextvars</done>
</task>

<task type="auto">
  <name>Task 3: Integrate LoggingMiddleware into main.py</name>
  <files>backend/main.py</files>
  <action>
Update main.py to add LoggingMiddleware:

1. Add import: `from app.middleware import LoggingMiddleware`
2. Add middleware AFTER CORSMiddleware but BEFORE route registration
3. Add logging service shutdown in lifespan shutdown handler

The order matters: LoggingMiddleware should be added after CORS so it can log all requests (including CORS preflight).

Update the lifespan function to shutdown logging cleanly:
```python
@asynccontextmanager
async def lifespan(app: FastAPI):
    # Startup: Initialize database
    await init_db()
    print("Database initialized")

    yield

    # Shutdown: Cleanup
    from app.services.logging_service import get_logging_service
    get_logging_service().shutdown()
    print("Logging service stopped")

    await close_db()
    print("Database connection closed")
```

Add middleware registration after CORSMiddleware:
```python
# Configure CORS middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=settings.cors_origins_list,
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Add logging middleware (after CORS to log all requests)
app.add_middleware(LoggingMiddleware)
```

Note: P-12 prevention - We're not reconfiguring uvicorn loggers here; the LoggingService configures structlog independently.
  </action>
  <verify>
Run backend and make a request:
```bash
cd backend && timeout 5 python -c "
import asyncio
from httpx import AsyncClient
from main import app

async def test():
    async with AsyncClient(app=app, base_url='http://test') as client:
        response = await client.get('/health')
        print('Status:', response.status_code)
        print('X-Correlation-ID:', response.headers.get('X-Correlation-ID'))

asyncio.run(test())
" || true

# Check log was written
cat logs/app.log | tail -2
```
Expected: Response has X-Correlation-ID header, log file shows request entries
  </verify>
  <done>LoggingMiddleware integrated into FastAPI app, logs all HTTP requests</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Start backend and make a test request:
   ```bash
   cd backend
   # Start server in background
   python -m uvicorn main:app --port 8999 &
   sleep 2

   # Make request with curl
   curl -s -I http://localhost:8999/health | grep -i x-correlation-id

   # Check logs
   tail -5 logs/app.log

   # Cleanup
   kill %1
   ```

2. Verify correlation ID propagation:
   ```bash
   cd backend && python -c "
   import asyncio
   from httpx import AsyncClient
   from main import app

   async def test():
       async with AsyncClient(app=app, base_url='http://test') as client:
           # Request with custom correlation ID
           response = await client.get('/health', headers={'X-Correlation-ID': 'test-corr-123'})
           assert response.headers.get('X-Correlation-ID') == 'test-corr-123'
           print('Correlation ID preserved: PASS')

           # Request without correlation ID (should be generated)
           response = await client.get('/health')
           assert response.headers.get('X-Correlation-ID') is not None
           print('Correlation ID generated: PASS')

   asyncio.run(test())
   "
   ```

3. Verify log entry schema:
   ```bash
   cd backend && python -c "
   import json
   with open('logs/app.log') as f:
       for line in f:
           entry = json.loads(line)
           if 'api' in str(entry):
               print('Entry:', json.dumps(entry, indent=2))
               assert 'category' in entry
               assert 'correlationId' in entry or 'correlation_id' in str(entry).lower()
               break
   print('Schema validation: PASS')
   "
   ```
</verification>

<success_criteria>
- LoggingMiddleware logs request start and completion with timing
- Correlation ID is generated if not provided in X-Correlation-ID header
- Correlation ID is added to response headers
- Correlation ID is accessible via get_correlation_id() from contextvars
- Middleware is integrated into main.py after CORSMiddleware
</success_criteria>

<output>
After completion, create `.planning/phases/43-backend-logging-foundation/43-02-SUMMARY.md`
</output>
