---
phase: 41-structural-history-filtering
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/services/conversation_service.py
  - backend/tests/unit/services/test_conversation_service.py
  - backend/tests/unit/services/test_conversation_service_db.py
autonomous: true

must_haves:
  truths:
    - "Fulfilled artifact request message pairs (user + assistant) are excluded from conversation context sent to the model"
    - "Unfulfilled requests (no artifact record in DB) remain in context for user retry"
    - "Existing conversation truncation behavior is unchanged (filter first, truncate second)"
    - "Original messages remain untouched in database — filtering is read-time only"
    - "Detection works for all prompt types (preset buttons and custom freeform)"
  artifacts:
    - path: "backend/app/services/conversation_service.py"
      provides: "_identify_fulfilled_pairs helper and updated build_conversation_context"
      contains: "_identify_fulfilled_pairs"
    - path: "backend/tests/unit/services/test_conversation_service.py"
      provides: "Pure function tests for _identify_fulfilled_pairs"
      contains: "TestIdentifyFulfilledPairs"
  key_links:
    - from: "backend/app/services/conversation_service.py"
      to: "app.models.Artifact"
      via: "import and SELECT query"
      pattern: "select\\(Artifact\\)"
    - from: "_identify_fulfilled_pairs"
      to: "build_conversation_context"
      via: "called before truncation"
      pattern: "_identify_fulfilled_pairs.*artifacts"
---

<objective>
Add structural history filtering to `build_conversation_context()` so fulfilled artifact generation request pairs (user message + assistant response) are completely removed from the conversation context before it reaches the AI model. Detection uses database correlation: query the artifacts table and match artifact creation timestamps to assistant message timestamps within a 5-second window.

Purpose: Layer 3 of the 4-layer deduplication defense. The model never sees completed generation requests, eliminating structural re-execution. Combined with Phase 40's prompt rules, the artifact multiplication bug (BUG-016) is ~99%+ eliminated.

Output: Modified `conversation_service.py` with filtering logic, plus comprehensive unit tests for the detection algorithm.
</objective>

<execution_context>
@/Users/a1testingmac/.claude/get-shit-done/workflows/execute-plan.md
@/Users/a1testingmac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/41-structural-history-filtering/41-CONTEXT.md
@.planning/phases/41-structural-history-filtering/41-RESEARCH.md
@.planning/phases/40-prompt-engineering-fixes/40-01-SUMMARY.md
@backend/app/services/conversation_service.py
@backend/app/models.py
@backend/tests/unit/services/test_conversation_service.py
@backend/tests/unit/services/test_conversation_service_db.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add artifact-aware filtering to build_conversation_context</name>
  <files>backend/app/services/conversation_service.py</files>
  <action>
Modify `conversation_service.py` to filter fulfilled artifact message pairs from conversation context.

**1. Add imports:**
- Add `Artifact` to the existing `from app.models import` line
- Add `from datetime import timedelta` (datetime is already imported locally in save_message; move to module-level)

**2. Add constant:**
```python
ARTIFACT_CORRELATION_WINDOW = timedelta(seconds=5)
```
Place after the existing `CHARS_PER_TOKEN` constant.

**3. Create `_identify_fulfilled_pairs()` pure function:**
```python
def _identify_fulfilled_pairs(
    messages: list,
    artifacts: list
) -> set:
```
Algorithm:
- Iterate through messages by index
- For each assistant message, check if any artifact was created within 0 to 5 seconds AFTER the message's `created_at` timestamp
- If match found: add the assistant message ID to fulfilled set, AND add the preceding user message ID if it exists (index - 1, role == "user")
- Break after first artifact match per assistant message (one artifact per message)
- Return set of message IDs to exclude

Use `timedelta` comparison: `timedelta(0) <= (artifact.created_at - msg.created_at) <= ARTIFACT_CORRELATION_WINDOW`

IMPORTANT: Handle timezone-aware vs naive datetime comparison. Both Message.created_at and Artifact.created_at use `DateTime(timezone=True)` in the model, but SQLite may store them as naive. Use `.replace(tzinfo=None)` on both timestamps before comparison to be safe, OR compare using `.total_seconds()` on the timedelta result. The safest approach is:
```python
time_diff = (artifact.created_at - msg.created_at).total_seconds()
if 0 <= time_diff <= 5:
```

**4. Modify `build_conversation_context()`:**
- After fetching messages (existing query), add a second query to fetch artifacts for the same thread_id, ordered by created_at
- Call `_identify_fulfilled_pairs(messages, artifacts)` to get the set of IDs to exclude
- When building the `conversation` list, skip messages whose `msg.id` is in the fulfilled set
- Truncation logic remains UNCHANGED and runs on the already-filtered conversation list

The function signature stays the same: `async def build_conversation_context(db, thread_id) -> List[Dict[str, Any]]`

**What NOT to do:**
- Do NOT modify `save_message()` — filtering is read-time only per user decision
- Do NOT add markers/annotations to message content — user decided on removal, not annotation
- Do NOT scan message content for tool result text — tool results are NOT saved in assistant message content (PITFALL-01)
- Do NOT use the ARTIFACT_CREATED marker from BUG-019 — it is dead code
- Do NOT change the truncation logic — filter FIRST, truncate SECOND (HIST-06)
  </action>
  <verify>
Run grep to confirm:
1. `grep -c "_identify_fulfilled_pairs" backend/app/services/conversation_service.py` returns 2+ (definition + call)
2. `grep -c "select(Artifact)" backend/app/services/conversation_service.py` returns 1 (artifact query)
3. `grep -c "ARTIFACT_CORRELATION_WINDOW" backend/app/services/conversation_service.py` returns 2 (definition + usage)
4. `grep "from app.models import" backend/app/services/conversation_service.py` includes "Artifact"
5. The truncate_conversation call still exists and runs AFTER the filtering logic
  </verify>
  <done>
`build_conversation_context()` queries both messages and artifacts tables, identifies fulfilled message pairs via timestamp correlation, excludes them from the conversation list, then applies existing truncation. The `_identify_fulfilled_pairs()` helper is a pure function testable without database.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add unit tests for fulfilled pair detection and filtered context building</name>
  <files>
    backend/tests/unit/services/test_conversation_service.py
    backend/tests/unit/services/test_conversation_service_db.py
  </files>
  <action>
**In `test_conversation_service.py` (pure function tests):**

Add a new test class `TestIdentifyFulfilledPairs` that tests `_identify_fulfilled_pairs` with mock message/artifact objects.

Create a simple mock/dataclass to simulate Message and Artifact objects with `id`, `role`, `created_at` attributes. Use `types.SimpleNamespace` or a small helper class — do NOT add new dependencies.

Test cases (minimum 7):

1. **test_no_artifacts_returns_empty_set** — Messages exist but no artifacts, returns empty set (nothing filtered)
2. **test_single_fulfilled_pair_detected** — One user msg + one assistant msg + one artifact created 2 seconds after assistant msg. Returns set with both message IDs.
3. **test_unfulfilled_request_not_filtered** — User msg + assistant msg but NO artifact. Returns empty set (HIST-04).
4. **test_multiple_fulfilled_pairs** — Thread with 3 user/assistant pairs, 2 have artifacts. Only the 2 fulfilled pairs' IDs returned.
5. **test_artifact_before_message_not_matched** — Artifact created BEFORE assistant message (negative time_diff). Not matched. Returns empty set.
6. **test_artifact_outside_window_not_matched** — Artifact created 10 seconds after assistant message (outside 5s window). Not matched.
7. **test_no_preceding_user_message** — Assistant message is first in list (no preceding user message). Only assistant ID returned, no index error.

Import `_identify_fulfilled_pairs` and `ARTIFACT_CORRELATION_WINDOW` from `app.services.conversation_service`.

**In `test_conversation_service_db.py` (database integration tests):**

Add one integration test to the existing `TestBuildConversationContext` class (or create it if it doesn't exist):

1. **test_build_context_excludes_fulfilled_artifact_pairs** — Create a thread with:
   - user msg "Generate a BRD" at T+0
   - assistant msg "I've created..." at T+1
   - artifact record at T+2 (within 5s window)
   - user msg "What about edge cases?" at T+10
   - assistant msg "Good question..." at T+11
   Call `build_conversation_context()` and verify the result contains only the 2 non-artifact messages (the edge case discussion), NOT the BRD generation pair.

Follow existing test patterns in the file (pytest.mark.asyncio, db_session fixture, user fixture).

**What NOT to do:**
- Do NOT install new test dependencies — use stdlib (SimpleNamespace, datetime)
- Do NOT test truncation behavior changes — truncation is UNCHANGED (HIST-06)
  </action>
  <verify>
Run the test suite:
```bash
cd backend && python -m pytest tests/unit/services/test_conversation_service.py -v -k "FulfilledPairs" 2>&1 | tail -20
cd backend && python -m pytest tests/unit/services/test_conversation_service_db.py -v -k "excludes_fulfilled" 2>&1 | tail -20
```
All new tests pass. Existing tests in both files continue to pass.
  </verify>
  <done>
7+ pure function tests for `_identify_fulfilled_pairs` cover: no artifacts, single pair, multiple pairs, unfulfilled requests, out-of-window artifacts, negative time diff, and missing preceding user message. 1 database integration test confirms `build_conversation_context` end-to-end filtering with real DB records.
  </done>
</task>

</tasks>

<verification>
1. `grep -c "_identify_fulfilled_pairs" backend/app/services/conversation_service.py` >= 2
2. `grep -c "select(Artifact)" backend/app/services/conversation_service.py` == 1
3. `grep "ARTIFACT_CORRELATION_WINDOW" backend/app/services/conversation_service.py` shows timedelta(seconds=5)
4. `grep "from app.models import" backend/app/services/conversation_service.py` includes Artifact
5. Truncation logic is unchanged (truncate_conversation call still present, runs after filtering)
6. `python -m pytest tests/unit/services/test_conversation_service.py -v` — all tests pass including new TestIdentifyFulfilledPairs
7. `python -m pytest tests/unit/services/test_conversation_service_db.py -v` — all tests pass including new filtering integration test
8. No changes to save_message (read-time only filtering confirmed)
</verification>

<success_criteria>
- build_conversation_context() excludes fulfilled artifact message pairs from the returned conversation list
- _identify_fulfilled_pairs() correctly detects pairs using 5-second timestamp correlation window
- Unfulfilled requests (no artifact in DB) remain in context untouched
- Truncation runs AFTER filtering, behavior unchanged
- 8+ new tests pass covering detection algorithm edge cases and end-to-end DB integration
- No new dependencies added
</success_criteria>

<output>
After completion, create `.planning/phases/41-structural-history-filtering/41-01-SUMMARY.md`
</output>
