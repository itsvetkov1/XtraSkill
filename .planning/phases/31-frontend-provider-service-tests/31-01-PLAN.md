---
phase: 31-frontend-provider-service-tests
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/test/unit/providers/auth_provider_test.dart
  - frontend/test/unit/providers/auth_provider_test.mocks.dart
  - frontend/test/unit/providers/project_provider_test.dart
  - frontend/test/unit/providers/project_provider_test.mocks.dart
autonomous: true

must_haves:
  truths:
    - "AuthProvider tests verify state transitions for all auth flows"
    - "ProjectProvider tests verify CRUD operations and optimistic delete"
    - "Tests use @GenerateNiceMocks pattern from existing chats_provider_test.dart"
  artifacts:
    - path: "frontend/test/unit/providers/auth_provider_test.dart"
      provides: "AuthProvider unit tests"
      min_lines: 150
    - path: "frontend/test/unit/providers/project_provider_test.dart"
      provides: "ProjectProvider unit tests"
      min_lines: 200
  key_links:
    - from: "auth_provider_test.dart"
      to: "AuthProvider"
      via: "MockAuthService injection"
      pattern: "MockAuthService"
    - from: "project_provider_test.dart"
      to: "ProjectProvider"
      via: "MockProjectService injection"
      pattern: "MockProjectService"
---

<objective>
Create unit tests for AuthProvider and ProjectProvider.

Purpose: Cover FPROV-01 (AuthProvider) and FPROV-02 (ProjectProvider) requirements with isolated unit tests that verify state management logic.

Output: Two test files with mocks that verify state transitions, error handling, and notifyListeners() behavior.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/31-frontend-provider-service-tests/31-RESEARCH.md

# Template for testing pattern
@frontend/test/unit/chats_provider_test.dart

# Source files under test
@frontend/lib/providers/auth_provider.dart
@frontend/lib/providers/project_provider.dart
@frontend/lib/services/auth_service.dart
@frontend/lib/services/project_service.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: AuthProvider unit tests</name>
  <files>
    frontend/test/unit/providers/auth_provider_test.dart
  </files>
  <action>
Create comprehensive unit tests for AuthProvider following the established pattern from chats_provider_test.dart.

Use @GenerateNiceMocks([MockSpec<AuthService>()]) annotation.

Test groups to implement:
1. **Initial State** - starts in loading state, null user fields
2. **checkAuthStatus** - sets authenticated when token valid, sets unauthenticated when invalid, handles getCurrentUser() errors
3. **loginWithGoogle/loginWithMicrosoft** - sets loading during call, sets error on failure
4. **handleCallback** - stores token, fetches user info, sets authenticated on success, sets error on failure
5. **logout** - clears user state, sets unauthenticated, handles service errors gracefully

Test patterns:
- Verify state transitions using expect(provider.state, equals(AuthState.xxx))
- Use when().thenAnswer() for async service methods
- Use when().thenThrow() for error scenarios
- Test that errorMessage is set correctly on failures
- Test that user fields (userId, email, displayName, authProvider) are populated/cleared correctly

Note: For Future.microtask() in handleCallback/logout, the test will need to use await with expectLater or use pump() if using WidgetTester. For pure unit tests, the microtask will complete before test assertions due to await on provider methods.
  </action>
  <verify>
Run: `cd frontend && flutter test test/unit/providers/auth_provider_test.dart -v`
All tests pass without errors.
  </verify>
  <done>
AuthProvider has unit test coverage for all public methods with both success and error paths tested.
  </done>
</task>

<task type="auto">
  <name>Task 2: ProjectProvider unit tests</name>
  <files>
    frontend/test/unit/providers/project_provider_test.dart
  </files>
  <action>
Create comprehensive unit tests for ProjectProvider following the established pattern.

Use @GenerateNiceMocks([MockSpec<ProjectService>()]) annotation.

Test groups to implement:
1. **Initial State** - empty projects list, no selected project, loading false, no error
2. **loadProjects** - sets loading during call, updates projects on success, sets error on failure, clears error on success
3. **createProject** - adds project to beginning of list, returns project on success, sets error on failure
4. **selectProject** - loads project details on success, sets isNotFound on 404 error, sets error on other errors, clears isNotFound on new selection
5. **updateProject** - updates project in list, updates selectedProject if same, returns project on success, sets error on failure
6. **clearSelection** - sets selectedProject to null
7. **clearError** - clears error and isNotFound

For optimistic delete (deleteProject):
- Do NOT test the full timer-based flow (10 second timer is impractical)
- Instead, test the immediate state changes:
  - Project is removed from list immediately
  - selectedProject is cleared if it was the deleted project
  - Total count decreases
- Skip testing _undoDelete and _commitPendingDelete internals (they require BuildContext and timers)

Test patterns:
- Create mock Project objects with required fields (id, name, createdAt, updatedAt)
- Verify list mutations (insert, indexWhere, removeAt)
- Verify loading state transitions
  </action>
  <verify>
Run: `cd frontend && flutter test test/unit/providers/project_provider_test.dart -v`
All tests pass without errors.
  </verify>
  <done>
ProjectProvider has unit test coverage for all public methods except timer-based delete internals, with both success and error paths tested.
  </done>
</task>

<task type="auto">
  <name>Task 3: Generate mocks and verify</name>
  <files>
    frontend/test/unit/providers/auth_provider_test.mocks.dart
    frontend/test/unit/providers/project_provider_test.mocks.dart
  </files>
  <action>
Run build_runner to generate mock files:

```bash
cd frontend
flutter pub run build_runner build --delete-conflicting-outputs
```

This generates the .mocks.dart files required by the @GenerateNiceMocks annotations.

Verify:
1. auth_provider_test.mocks.dart exists and contains MockAuthService class
2. project_provider_test.mocks.dart exists and contains MockProjectService class
3. Run all tests to confirm mocks work correctly
  </action>
  <verify>
Run: `cd frontend && flutter test test/unit/providers/ -v`
All provider tests pass (including existing chats_provider_test.dart).
  </verify>
  <done>
Mock files are generated and all provider tests in test/unit/providers/ pass.
  </done>
</task>

</tasks>

<verification>
1. `cd frontend && flutter test test/unit/providers/auth_provider_test.dart` - AuthProvider tests pass
2. `cd frontend && flutter test test/unit/providers/project_provider_test.dart` - ProjectProvider tests pass
3. Test files follow established patterns from chats_provider_test.dart
4. Tests cover FPROV-01 and FPROV-02 requirements
</verification>

<success_criteria>
- AuthProvider has unit test coverage with 10+ test cases covering all public methods
- ProjectProvider has unit test coverage with 15+ test cases covering all public methods
- Both test files use @GenerateNiceMocks pattern
- Both success and error paths are tested for each method
- All tests pass with `flutter test test/unit/providers/`
</success_criteria>

<output>
After completion, create `.planning/phases/31-frontend-provider-service-tests/31-01-SUMMARY.md`
</output>
