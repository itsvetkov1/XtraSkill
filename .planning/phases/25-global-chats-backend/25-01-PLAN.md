---
phase: 25-global-chats-backend
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models.py
  - backend/app/database.py
  - backend/app/routes/threads.py
  - backend/app/routes/conversations.py
autonomous: true

must_haves:
  truths:
    - "Thread can be created without project_id"
    - "API returns all user's threads sorted by last activity"
    - "Each thread in list includes project_name (or null)"
    - "Ownership validation works for both project-based and project-less threads"
  artifacts:
    - path: "backend/app/models.py"
      provides: "Thread model with nullable project_id, user_id, last_activity_at"
      contains: "nullable=True"
    - path: "backend/app/routes/threads.py"
      provides: "GET /threads and POST /threads endpoints"
      exports: ["router"]
    - path: "backend/app/database.py"
      provides: "Migration for new Thread columns"
      contains: "last_activity_at"
  key_links:
    - from: "GET /threads"
      to: "Thread model"
      via: "SQLAlchemy query with outerjoin to Project"
      pattern: "outerjoin.*Project"
    - from: "POST /threads"
      to: "Thread model"
      via: "Creates thread with or without project_id"
      pattern: "project_id.*Optional"
---

<objective>
Backend support for project-less threads and global chats listing.

Purpose: Enable users to start conversations without selecting a project first, and provide API for listing all threads across projects.

Output:
- Thread model updated with nullable project_id, user_id, last_activity_at
- GET /threads endpoint returning all user threads with project info
- POST /threads endpoint for creating project-less threads
- Updated ownership validation for dual ownership model
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/25-global-chats-backend/25-CONTEXT.md
@.planning/phases/25-global-chats-backend/25-RESEARCH.md
@backend/app/models.py
@backend/app/routes/threads.py
@backend/app/routes/conversations.py
@backend/app/database.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Thread model and database migration</name>
  <files>
    backend/app/models.py
    backend/app/database.py
  </files>
  <action>
Update Thread model in backend/app/models.py:

1. Make project_id nullable with SET NULL on delete:
   ```python
   project_id: Mapped[Optional[str]] = mapped_column(
       String(36),
       ForeignKey("projects.id", ondelete="SET NULL"),  # Changed from CASCADE
       nullable=True,  # Changed from nullable=False
       index=True
   )
   ```

2. Add user_id column for direct ownership of project-less threads:
   ```python
   user_id: Mapped[Optional[str]] = mapped_column(
       String(36),
       ForeignKey("users.id", ondelete="CASCADE"),
       nullable=True,  # Only set when project_id is None
       index=True
   )
   ```

3. Add last_activity_at column for activity-based sorting:
   ```python
   last_activity_at: Mapped[datetime] = mapped_column(
       DateTime(timezone=True),
       default=datetime.utcnow,
       nullable=False,
       index=True  # For efficient sorting
   )
   ```

4. Update Project.threads relationship to handle nullable FK:
   - Change cascade from "all, delete-orphan" to just "all" since orphan threads (project-less) are intentional
   - Keep passive_deletes=True

5. Add User.threads relationship for direct ownership:
   ```python
   # In User class
   threads: Mapped[List["Thread"]] = relationship(
       back_populates="user",
       cascade="all, delete-orphan",
       passive_deletes=True,
       foreign_keys="[Thread.user_id]"
   )
   ```

6. Add Thread.user relationship:
   ```python
   user: Mapped[Optional["User"]] = relationship(
       back_populates="threads",
       foreign_keys=[user_id]
   )
   ```

Update database.py _run_migrations():

Add migration checks for new columns:
```python
# Check and add user_id column to threads
result = await conn.execute(text("PRAGMA table_info(threads)"))
columns = [row[1] for row in result]

if "user_id" not in columns:
    await conn.execute(
        text("ALTER TABLE threads ADD COLUMN user_id VARCHAR(36) REFERENCES users(id)")
    )

if "last_activity_at" not in columns:
    # Add with default of updated_at for existing rows
    await conn.execute(
        text("ALTER TABLE threads ADD COLUMN last_activity_at DATETIME DEFAULT CURRENT_TIMESTAMP")
    )
    # Backfill existing rows
    await conn.execute(
        text("UPDATE threads SET last_activity_at = updated_at WHERE last_activity_at IS NULL")
    )
```

Note: SQLite allows adding nullable columns. The foreign key to users uses SQLite's partial FK support.
  </action>
  <verify>
Run backend and check database schema:
```bash
cd backend && python -c "from app.models import Thread; print(Thread.__table__.columns.keys())"
```
Should show: id, project_id, user_id, title, model_provider, created_at, updated_at, last_activity_at
  </verify>
  <done>
Thread model has nullable project_id, user_id, and last_activity_at columns. Migration adds columns to existing database without breaking existing threads.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add global thread endpoints and update ownership validation</name>
  <files>
    backend/app/routes/threads.py
    backend/app/routes/conversations.py
  </files>
  <action>
Update backend/app/routes/threads.py:

1. Add new Pydantic models for global threads:
   ```python
   class GlobalThreadCreate(BaseModel):
       """Request model for creating a thread (project optional)."""
       title: Optional[str] = Field(None, max_length=255)
       project_id: Optional[str] = None  # Null = project-less thread
       model_provider: Optional[str] = Field(None, max_length=20)

   class GlobalThreadListResponse(BaseModel):
       """Response model for thread in global list."""
       id: str
       title: Optional[str]
       updated_at: str
       last_activity_at: str
       project_id: Optional[str]
       project_name: Optional[str]
       message_count: int
       model_provider: str

       class Config:
           from_attributes = True

   class PaginatedThreadsResponse(BaseModel):
       """Paginated threads response."""
       threads: List[GlobalThreadListResponse]
       total: int
       page: int
       page_size: int
       has_more: bool
   ```

2. Add GET /threads endpoint for global listing:
   ```python
   @router.get("/threads", response_model=PaginatedThreadsResponse)
   async def list_all_threads(
       page: int = Query(1, ge=1),
       page_size: int = Query(25, ge=1, le=50),
       current_user: dict = Depends(get_current_user),
       db: AsyncSession = Depends(get_db),
   ):
       """
       List all threads for current user across all projects.
       Includes project-less threads. Sorted by last_activity_at DESC.
       """
       user_id = current_user["user_id"]

       # Query: threads owned directly OR via project
       base_query = (
           select(Thread)
           .outerjoin(Project, Thread.project_id == Project.id)
           .where(
               (Thread.user_id == user_id) |
               (Project.user_id == user_id)
           )
           .options(selectinload(Thread.project), selectinload(Thread.messages))
           .order_by(Thread.last_activity_at.desc())
       )

       # Count total
       from sqlalchemy import func
       count_subquery = (
           select(Thread.id)
           .outerjoin(Project, Thread.project_id == Project.id)
           .where((Thread.user_id == user_id) | (Project.user_id == user_id))
       ).subquery()
       count_stmt = select(func.count()).select_from(count_subquery)
       total_result = await db.execute(count_stmt)
       total = total_result.scalar()

       # Paginate
       offset = (page - 1) * page_size
       paginated = base_query.offset(offset).limit(page_size)
       result = await db.execute(paginated)
       threads = result.scalars().unique().all()

       return PaginatedThreadsResponse(
           threads=[
               GlobalThreadListResponse(
                   id=t.id,
                   title=t.title,
                   updated_at=t.updated_at.isoformat(),
                   last_activity_at=t.last_activity_at.isoformat() if t.last_activity_at else t.updated_at.isoformat(),
                   project_id=t.project_id,
                   project_name=t.project.name if t.project else None,
                   message_count=len(t.messages),
                   model_provider=t.model_provider or "anthropic",
               )
               for t in threads
           ],
           total=total,
           page=page,
           page_size=page_size,
           has_more=(offset + len(threads)) < total,
       )
   ```

3. Add POST /threads endpoint for global creation:
   ```python
   @router.post("/threads", response_model=ThreadResponse, status_code=status.HTTP_201_CREATED)
   async def create_global_thread(
       thread_data: GlobalThreadCreate,
       current_user: dict = Depends(get_current_user),
       db: AsyncSession = Depends(get_db),
   ):
       """
       Create thread, optionally within a project.
       If project_id is null, creates a project-less thread owned directly by user.
       """
       user_id = current_user["user_id"]

       # Validate project if provided
       if thread_data.project_id:
           stmt = select(Project).where(
               Project.id == thread_data.project_id,
               Project.user_id == user_id
           )
           result = await db.execute(stmt)
           if not result.scalar_one_or_none():
               raise HTTPException(status_code=404, detail="Project not found")

       # Validate provider
       if thread_data.model_provider and thread_data.model_provider not in VALID_PROVIDERS:
           raise HTTPException(
               status_code=400,
               detail=f"Invalid provider. Valid options: {', '.join(VALID_PROVIDERS)}"
           )

       # Create thread
       from datetime import datetime
       thread = Thread(
           project_id=thread_data.project_id,
           user_id=user_id if thread_data.project_id is None else None,
           title=thread_data.title or "New Chat",
           model_provider=thread_data.model_provider or "anthropic",
           last_activity_at=datetime.utcnow()
       )

       db.add(thread)
       await db.commit()
       await db.refresh(thread)

       return ThreadResponse(
           id=thread.id,
           project_id=thread.project_id or "",  # Empty string for null
           title=thread.title,
           model_provider=thread.model_provider or "anthropic",
           created_at=thread.created_at.isoformat(),
           updated_at=thread.updated_at.isoformat(),
       )
   ```

4. Update ThreadResponse to handle optional project_id:
   Change `project_id: str` to `project_id: Optional[str]` in ThreadResponse class.

Update backend/app/routes/conversations.py:

1. Update validate_thread_access to handle dual ownership:
   ```python
   async def validate_thread_access(
       db: AsyncSession,
       thread_id: str,
       user_id: str
   ) -> Thread:
       """
       Validate thread exists and belongs to user (directly or via project).
       Returns Thread with project loaded, or raises 404.
       """
       stmt = (
           select(Thread)
           .where(Thread.id == thread_id)
           .options(selectinload(Thread.project))
       )
       result = await db.execute(stmt)
       thread = result.scalar_one_or_none()

       if not thread:
           raise HTTPException(status_code=404, detail="Thread not found")

       # Project-less thread: check direct ownership
       if thread.project_id is None:
           if thread.user_id != user_id:
               raise HTTPException(status_code=404, detail="Thread not found")
       # Project thread: check project ownership
       else:
           if thread.project.user_id != user_id:
               raise HTTPException(status_code=404, detail="Thread not found")

       return thread
   ```

2. Update stream_chat to update last_activity_at:
   After saving user message, add:
   ```python
   # Update thread activity timestamp
   from datetime import datetime
   thread.last_activity_at = datetime.utcnow()
   await db.commit()
   ```
  </action>
  <verify>
Test endpoints with curl:
```bash
# Test global thread listing
curl -X GET "http://localhost:8000/api/threads?page=1&page_size=10" -H "Authorization: Bearer $TOKEN"

# Test creating project-less thread
curl -X POST "http://localhost:8000/api/threads" -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d '{"title": "Test Chat"}'
```
Both should return 200/201 with expected JSON structure.
  </verify>
  <done>
GET /threads returns paginated list of all user threads with project info. POST /threads creates thread with or without project_id. Ownership validation works for both ownership models.
  </done>
</task>

</tasks>

<verification>
1. Model changes:
   - Thread.project_id is nullable
   - Thread.user_id exists and indexes correctly
   - Thread.last_activity_at exists and updates on activity
   - Existing threads still work (project-based ownership)

2. GET /threads endpoint:
   - Returns threads owned directly (user_id match)
   - Returns threads owned via project (project.user_id match)
   - Includes project_name (null for project-less)
   - Sorted by last_activity_at DESC
   - Pagination works correctly

3. POST /threads endpoint:
   - Creates project-less thread when project_id is null
   - Creates project thread when project_id provided (validates ownership)
   - Sets user_id only for project-less threads
   - Sets last_activity_at on creation

4. Ownership validation:
   - Project-less threads: thread.user_id == current_user
   - Project threads: thread.project.user_id == current_user
   - Both paths return 404 for unauthorized access
</verification>

<success_criteria>
- Thread can be created without project_id (CHATS-05, CHATS-06 backend support)
- GET /threads returns all user threads sorted by activity (CHATS-02, CHATS-04)
- Response includes project_name or null (CHATS-03)
- Existing project-based thread operations unchanged
- Chat continues to work for both thread types
</success_criteria>

<output>
After completion, create `.planning/phases/25-global-chats-backend/25-01-SUMMARY.md`
</output>
