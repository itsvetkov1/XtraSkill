---
phase: 04.1-agent-sdk-skill-integration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/requirements.txt
  - backend/app/services/skill_loader.py
  - backend/app/config.py
autonomous: true

must_haves:
  truths:
    - "claude-agent-sdk package is installed and importable"
    - "Skill loader reads SKILL.md and all reference files"
    - "Combined prompt includes all skill content for Claude"
    - "Skill path is configurable via environment variable"
  artifacts:
    - path: "backend/app/services/skill_loader.py"
      provides: "Skill content loading and prompt construction"
      exports: ["load_skill_prompt", "get_skill_references"]
    - path: "backend/requirements.txt"
      provides: "claude-agent-sdk dependency"
      contains: "claude-agent-sdk"
  key_links:
    - from: "backend/app/services/skill_loader.py"
      to: ".claude/business-analyst/SKILL.md"
      via: "Path.read_text()"
      pattern: "read_text"
    - from: "backend/app/services/skill_loader.py"
      to: ".claude/business-analyst/references/*.md"
      via: "glob and read"
      pattern: "glob.*\\.md"
---

<objective>
Install Claude Agent SDK and create skill loader service.

Purpose: Prepare foundation for Agent SDK integration by installing the SDK package and creating a service that loads the business-analyst skill content (SKILL.md + all reference files) into a combined system prompt.

Output: Working skill loader that can construct the full business-analyst prompt from filesystem skill files.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04.1-agent-sdk-skill-integration/04.1-RESEARCH.md

# Existing skill files to load
@.claude/business-analyst/SKILL.md
@.claude/business-analyst/references/discovery-framework.md
@.claude/business-analyst/references/brd-template.md
@.claude/business-analyst/references/tone-guidelines.md
@.claude/business-analyst/references/error-protocols.md

# Existing config pattern
@backend/app/config.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install Claude Agent SDK</name>
  <files>
    backend/requirements.txt
  </files>
  <action>
Add claude-agent-sdk to backend/requirements.txt.

1. Open backend/requirements.txt
2. Add at the end (after existing dependencies):

```
# Agent SDK for structured skill integration
claude-agent-sdk>=0.1.0
```

Note: The SDK requires Python 3.10+ which is already satisfied (project uses Python 3.11+).

After adding, run:
```bash
cd backend && pip install -r requirements.txt
```

Verify installation:
```bash
python -c "from claude_agent_sdk import query, ClaudeAgentOptions, tool; print('SDK installed successfully')"
```
  </action>
  <verify>
Run: `cd backend && python -c "from claude_agent_sdk import query, ClaudeAgentOptions, tool; print('OK')"`
Should print "OK" without import errors.
  </verify>
  <done>
claude-agent-sdk package is installed and all core imports (query, ClaudeAgentOptions, tool) work.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add skill path configuration</name>
  <files>
    backend/app/config.py
  </files>
  <action>
Add skill path configuration to backend/app/config.py.

1. Open backend/app/config.py
2. Find the Settings class
3. Add new field for skill path:

```python
# Add to Settings class:
    skill_path: str = Field(
        default=".claude/business-analyst",
        description="Path to business-analyst skill directory relative to project root"
    )
```

This allows the skill location to be overridden via SKILL_PATH environment variable if needed (e.g., for testing or different deployments).
  </action>
  <verify>
Run: `cd backend && python -c "from app.config import settings; print(f'Skill path: {settings.skill_path}')"`
Should print "Skill path: .claude/business-analyst"
  </verify>
  <done>
Settings class has skill_path field with default value, configurable via environment variable.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create skill loader service</name>
  <files>
    backend/app/services/skill_loader.py
  </files>
  <action>
Create backend/app/services/skill_loader.py:

```python
"""
Skill Loader Service for Business-Analyst Skill.

Loads SKILL.md and all reference files to construct a complete
system prompt for Claude Agent SDK integration.
"""
from pathlib import Path
from typing import Dict, Optional
from functools import lru_cache
import logging

from app.config import settings

logger = logging.getLogger(__name__)


class SkillLoadError(Exception):
    """Raised when skill files cannot be loaded."""
    pass


def get_skill_directory() -> Path:
    """
    Get the skill directory path.

    Resolves skill_path relative to the project root (parent of backend/).

    Returns:
        Path to skill directory

    Raises:
        SkillLoadError: If directory doesn't exist
    """
    # Backend is in project_root/backend, skill is in project_root/.claude/...
    backend_dir = Path(__file__).parent.parent.parent  # backend/
    project_root = backend_dir.parent  # project root
    skill_dir = project_root / settings.skill_path

    if not skill_dir.exists():
        raise SkillLoadError(f"Skill directory not found: {skill_dir}")

    return skill_dir


def get_skill_references(skill_dir: Optional[Path] = None) -> Dict[str, str]:
    """
    Load all reference files from skill's references directory.

    Args:
        skill_dir: Optional skill directory path (uses config if not provided)

    Returns:
        Dict mapping filename (without .md) to file contents

    Raises:
        SkillLoadError: If references directory doesn't exist
    """
    if skill_dir is None:
        skill_dir = get_skill_directory()

    refs_dir = skill_dir / "references"

    if not refs_dir.exists():
        logger.warning(f"References directory not found: {refs_dir}")
        return {}

    references = {}
    for ref_file in refs_dir.glob("*.md"):
        try:
            content = ref_file.read_text(encoding="utf-8")
            # Use stem (filename without extension) as key
            references[ref_file.stem] = content
            logger.debug(f"Loaded reference: {ref_file.stem} ({len(content)} chars)")
        except Exception as e:
            logger.error(f"Failed to load reference {ref_file}: {e}")
            raise SkillLoadError(f"Failed to load reference {ref_file}: {e}")

    return references


@lru_cache(maxsize=1)
def load_skill_prompt() -> str:
    """
    Load complete skill prompt including SKILL.md and all references.

    Constructs a single prompt string that includes:
    1. Main SKILL.md content
    2. All reference files from references/ directory

    The result is cached since skill files don't change at runtime.

    Returns:
        Complete skill prompt string

    Raises:
        SkillLoadError: If skill files cannot be loaded
    """
    skill_dir = get_skill_directory()

    # Load main SKILL.md
    skill_file = skill_dir / "SKILL.md"
    if not skill_file.exists():
        raise SkillLoadError(f"SKILL.md not found: {skill_file}")

    try:
        skill_content = skill_file.read_text(encoding="utf-8")
        logger.info(f"Loaded SKILL.md ({len(skill_content)} chars)")
    except Exception as e:
        raise SkillLoadError(f"Failed to load SKILL.md: {e}")

    # Load all references
    references = get_skill_references(skill_dir)

    # Construct combined prompt
    combined_parts = [skill_content]

    # Add each reference with a header
    for ref_name, ref_content in references.items():
        combined_parts.append(f"\n\n---\n\n# Reference: {ref_name}\n\n{ref_content}")

    combined_prompt = "".join(combined_parts)

    logger.info(
        f"Constructed skill prompt: {len(combined_prompt)} chars, "
        f"{len(references)} references"
    )

    return combined_prompt


def clear_skill_cache():
    """
    Clear the cached skill prompt.

    Useful for testing or if skill files are updated at runtime.
    """
    load_skill_prompt.cache_clear()
    logger.info("Skill cache cleared")
```

This service:
- Reads SKILL.md from the configured skill path
- Loads all .md files from the references/ subdirectory
- Combines them into a single prompt string with clear section markers
- Caches the result since skill files don't change during runtime
- Provides clear error handling with SkillLoadError
  </action>
  <verify>
Run the following test:
```bash
cd backend && python -c "
from app.services.skill_loader import load_skill_prompt, get_skill_references

# Test references loading
refs = get_skill_references()
print(f'Loaded {len(refs)} references: {list(refs.keys())}')

# Test full prompt loading
prompt = load_skill_prompt()
print(f'Full prompt length: {len(prompt)} chars')

# Verify key content is present
assert 'business-analyst' in prompt.lower(), 'Missing skill name'
assert 'one question at a time' in prompt.lower(), 'Missing core protocol'
assert 'brd' in prompt.lower(), 'Missing BRD reference'
print('All checks passed!')
"
```
  </verify>
  <done>
Skill loader service can read SKILL.md and all 4 reference files, combining them into a complete prompt (~2000+ lines). Cache mechanism prevents repeated file I/O.
  </done>
</task>

</tasks>

<verification>
1. `pip list | grep claude-agent-sdk` shows package installed
2. `from claude_agent_sdk import query, ClaudeAgentOptions, tool` imports without error
3. `from app.services.skill_loader import load_skill_prompt` imports without error
4. `load_skill_prompt()` returns string containing skill content
5. All 4 reference files (discovery-framework, brd-template, tone-guidelines, error-protocols) are included
</verification>

<success_criteria>
- claude-agent-sdk>=0.1.0 in requirements.txt and installed
- settings.skill_path configurable with default ".claude/business-analyst"
- skill_loader.py exports load_skill_prompt() and get_skill_references()
- load_skill_prompt() returns combined SKILL.md + all references
- SkillLoadError raised for missing files with clear messages
- Cache mechanism via @lru_cache for performance
</success_criteria>

<output>
After completion, create `.planning/phases/04.1-agent-sdk-skill-integration/04.1-01-SUMMARY.md`
</output>
