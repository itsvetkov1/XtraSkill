---
phase: 45-frontend-logging-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - frontend/pubspec.yaml
  - frontend/lib/services/logging_service.dart
  - frontend/lib/services/session_service.dart
  - frontend/lib/utils/logging_observer.dart
  - frontend/lib/main.dart
autonomous: true
user_setup: []

must_haves:
  truths:
    - "User navigation events (screen views, route changes) are logged"
    - "User actions (button clicks, form submits) can be logged via LoggingService.logAction()"
    - "Errors are captured with exception type and stack trace"
    - "All frontend logs include session ID and category tags"
    - "Network state changes (connectivity, timeouts) are logged"
  artifacts:
    - path: "frontend/lib/services/logging_service.dart"
      provides: "Singleton LoggingService with buffer, log methods, connectivity monitoring"
      exports: ["LoggingService"]
      min_lines: 100
    - path: "frontend/lib/services/session_service.dart"
      provides: "Singleton SessionService with UUID v4 session ID"
      exports: ["SessionService"]
      min_lines: 20
    - path: "frontend/lib/utils/logging_observer.dart"
      provides: "NavigatorObserver for go_router route tracking"
      exports: ["LoggingNavigatorObserver"]
      min_lines: 30
    - path: "frontend/lib/main.dart"
      provides: "Error handlers wired to LoggingService"
      contains: "loggingService.logError"
  key_links:
    - from: "frontend/lib/main.dart"
      to: "LoggingService"
      via: "FlutterError.onError calls loggingService.logError"
      pattern: "loggingService\\.logError"
    - from: "frontend/lib/utils/logging_observer.dart"
      to: "LoggingService"
      via: "didPush/didPop calls loggingService.logNavigation"
      pattern: "loggingService\\.logNavigation"
    - from: "frontend/lib/main.dart"
      to: "LoggingNavigatorObserver"
      via: "GoRouter observers array"
      pattern: "observers:.*LoggingNavigatorObserver"
    - from: "frontend/lib/services/logging_service.dart"
      to: "SessionService"
      via: "session_id from SessionService"
      pattern: "SessionService\\(\\)\\.sessionId"
---

<objective>
Create the frontend logging foundation with LoggingService, SessionService, navigation observer, error handlers, and network connectivity monitoring.

Purpose: Enable comprehensive frontend logging that captures user actions, navigation, errors, and network state with session grouping for debugging and analysis.

Output:
- LoggingService singleton with buffer (max 1000 entries per SLOG-04), log methods, and connectivity monitoring
- SessionService singleton for UUID v4 session IDs
- LoggingNavigatorObserver for go_router route tracking
- Error handlers in main.dart wired to LoggingService
- Network state change logging via connectivity_plus
</objective>

<execution_context>
@G:\git_repos\BA_assistant\.claude\get-shit-done\workflows\execute-plan.md
@G:\git_repos\BA_assistant\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@G:\git_repos\BA_assistant\.planning\PROJECT.md
@G:\git_repos\BA_assistant\.planning\ROADMAP.md
@G:\git_repos\BA_assistant\.planning\STATE.md
@G:\git_repos\BA_assistant\.planning\phases\45-frontend-logging-foundation\45-RESEARCH.md

# Key backend contract (from Phase 44):
@G:\git_repos\BA_assistant\backend\app\routes\logs.py

# Existing patterns to follow:
@G:\git_repos\BA_assistant\frontend\lib\services\auth_service.dart
@G:\git_repos\BA_assistant\frontend\lib\providers\theme_provider.dart
@G:\git_repos\BA_assistant\frontend\lib\main.dart
@G:\git_repos\BA_assistant\frontend\lib\core\config.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add dependencies and create core logging services</name>
  <files>
    frontend/pubspec.yaml
    frontend/lib/services/logging_service.dart
    frontend/lib/services/session_service.dart
  </files>
  <action>
1. Add dependencies to pubspec.yaml:
   - logger: ^2.5.0 (structured logging with level filtering)
   - uuid: ^4.5.1 (RFC-compliant UUID generation for session IDs)
   - connectivity_plus: ^6.1.2 (network state monitoring)

   Run `flutter pub get` after adding dependencies.

2. Create SessionService (frontend/lib/services/session_service.dart):
   - Singleton pattern (private constructor, factory returning instance)
   - Generate UUID v4 on creation via uuid package
   - Expose sessionId getter (late final String)
   - Add regenerateSession() method for logout/login transitions
   - Import from 'package:uuid/uuid.dart'

3. Create LoggingService (frontend/lib/services/logging_service.dart):
   - Singleton pattern (private constructor, factory returning instance)
   - Use logger package with PrettyPrinter (methodCount: 0)
   - Use ProductionFilter to enable INFO/WARNING/ERROR in release mode
   - Buffer: List<Map<String, dynamic>> with max 1000 entries (SLOG-04)
   - Fields per log entry (matches backend LogEntry model):
     - timestamp (DateTime.now().toUtc().toIso8601String())
     - level (DEBUG/INFO/WARNING/ERROR)
     - message (string)
     - category (navigation/action/error/network/api)
     - session_id (from SessionService)
     - correlation_id (null for now, set in Phase 46)

   - Public methods:
     - init(): Initialize connectivity monitoring, start flush timer (for Phase 48)
     - logNavigation(String routeName): Log navigation with category 'navigation'
     - logAction(String action, {Map<String, dynamic>? metadata}): Log user action with category 'action'
     - logError(dynamic error, StackTrace? stackTrace, {String? context}): Log error with category 'error', include error.runtimeType and stack trace
     - logNetworkStateChange(bool isConnected): Log connectivity with category 'network'
     - dispose(): Cancel subscriptions (connectivity), cancel timer (for Phase 48)

   - Private _log() method that:
     - Logs to console via logger package
     - Adds structured entry to buffer
     - Auto-trims buffer if exceeds max (drop oldest)

   - Getter for buffer (List<Map<String, dynamic>> get buffer) for Phase 48 flush
   - clearBuffer() method for Phase 48 after successful flush

4. Add connectivity monitoring in LoggingService:
   - Import from 'package:connectivity_plus/connectivity_plus.dart'
   - StreamSubscription<List<ConnectivityResult>>? _connectivitySubscription
   - In init(): Listen to Connectivity().onConnectivityChanged
   - Determine isConnected: results.isNotEmpty && !results.contains(ConnectivityResult.none)
   - Call logNetworkStateChange(isConnected) on each change
   - Cancel subscription in dispose()

NOTE: Do NOT implement flush to backend in this phase - that's Phase 48. Just buffer logs in memory.
  </action>
  <verify>
Run `flutter pub get` in frontend directory - should complete without errors.
Run `flutter analyze frontend` - no errors in new files.
Check pubspec.yaml contains logger, uuid, and connectivity_plus.
  </verify>
  <done>
SessionService generates UUID v4 session ID on creation.
LoggingService is a singleton with buffer (max 1000), log methods for navigation/action/error/network.
Connectivity monitoring starts on init() and logs network state changes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create navigation observer and wire error handlers</name>
  <files>
    frontend/lib/utils/logging_observer.dart
    frontend/lib/main.dart
  </files>
  <action>
1. Create LoggingNavigatorObserver (frontend/lib/utils/logging_observer.dart):
   - Import NavigatorObserver from 'package:flutter/material.dart'
   - Import LoggingService from '../services/logging_service.dart'
   - Extend NavigatorObserver
   - Get LoggingService instance in constructor (final LoggingService _loggingService = LoggingService())

   Override methods:
   - didPush(Route route, Route? previousRoute):
     - Call super.didPush()
     - If route.settings.name != null, call _loggingService.logNavigation('Navigated to ${route.settings.name}')

   - didPop(Route route, Route? previousRoute):
     - Call super.didPop()
     - If previousRoute?.settings.name != null, call _loggingService.logNavigation('Returned to ${previousRoute!.settings.name}')

   - didReplace({Route? newRoute, Route? oldRoute}):
     - Call super.didReplace()
     - If newRoute?.settings.name != null, call _loggingService.logNavigation('Replaced with ${newRoute!.settings.name}')

2. Update main.dart to integrate logging:

   a. Add imports at top:
      - import 'services/logging_service.dart';
      - import 'utils/logging_observer.dart';

   b. In main() function, after WidgetsFlutterBinding.ensureInitialized():
      - Create loggingService instance: final loggingService = LoggingService();
      - Call loggingService.init(); to start connectivity monitoring

   c. Update FlutterError.onError (replace existing):
      FlutterError.onError = (FlutterErrorDetails details) {
        FlutterError.presentError(details); // Still show in console
        loggingService.logError(
          details.exception,
          details.stack,
          context: 'FlutterError: ${details.context}',
        );
        if (kReleaseMode) {
          // Existing print statements can be removed - now logged to service
        }
      };

   d. Update PlatformDispatcher.instance.onError (replace existing):
      PlatformDispatcher.instance.onError = (error, stack) {
        loggingService.logError(error, stack, context: 'PlatformError');
        return true; // Mark error as handled
      };

   e. Add LoggingNavigatorObserver to GoRouter:
      In _createRouter(), find the GoRouter constructor and add:
      observers: [LoggingNavigatorObserver()],

      (Add this after initialLocation: '/splash',)

3. Remove old print() statements in error handlers - they're now logged via LoggingService.
  </action>
  <verify>
Run `flutter analyze frontend` - no errors.
Run app with `flutter run -d chrome` in frontend directory.
Navigate between screens (Home -> Projects -> Settings) and check console for navigation logs.
Force an error by temporarily adding `throw Exception('Test')` in a button handler - verify error is logged.
  </verify>
  <done>
LoggingNavigatorObserver logs all go_router navigation events (push, pop, replace).
FlutterError.onError sends errors to LoggingService.
PlatformDispatcher.instance.onError sends async errors to LoggingService.
GoRouter includes LoggingNavigatorObserver in observers array.
  </done>
</task>

<task type="auto">
  <name>Task 3: Verify end-to-end logging functionality</name>
  <files>
    frontend/lib/screens/home_screen.dart
  </files>
  <action>
1. Add a test action log to verify logAction() works:
   - In home_screen.dart, import LoggingService
   - In the HomeScreen's initState or build method, find any button handler
   - Add a temporary logAction call to prove the pipeline works:
     LoggingService().logAction('home_screen_loaded');

   This is just to verify the logging chain works. The call can remain as it's useful.

2. Manual verification steps (document for testing):
   - Launch app: `flutter run -d chrome`
   - Check console output shows:
     a. "Network connected/disconnected" on app start (connectivity initial state)
     b. "Navigated to /splash" (or similar) on initial route
     c. "Navigated to /home" (or /login depending on auth state)
   - Navigate to Projects, Settings, back to Home
   - Verify each navigation appears in console logs with category 'navigation'

3. Verify buffer is working:
   - Add a debug print in LoggingService._log() temporarily:
     print('Buffer size: ${_buffer.length}');
   - Confirm buffer grows with each log
   - Confirm buffer never exceeds 1000 entries (add 1001 logs if needed to test trimming)

4. Clean up:
   - Remove temporary debug prints after verification
   - Keep the logAction('home_screen_loaded') as it's useful for pilot debugging
  </action>
  <verify>
Console shows structured log output with navigation events, action events, and network state.
Buffer grows but never exceeds 1000 entries.
No Flutter analyzer errors.
App runs without crashes.
  </verify>
  <done>
LoggingService captures navigation events from go_router.
LoggingService captures user actions via logAction().
LoggingService captures errors via FlutterError.onError and PlatformDispatcher.onError.
LoggingService captures network state changes via connectivity_plus.
All logs include session_id and category tags.
Buffer is bounded to 1000 entries.
  </done>
</task>

</tasks>

<verification>
After all tasks complete, verify:

1. **Dependencies installed:**
   - `flutter pub deps` shows logger, uuid, connectivity_plus

2. **Files created:**
   - frontend/lib/services/logging_service.dart exists and exports LoggingService
   - frontend/lib/services/session_service.dart exists and exports SessionService
   - frontend/lib/utils/logging_observer.dart exists and exports LoggingNavigatorObserver

3. **Integration working:**
   - main.dart imports and initializes LoggingService
   - main.dart uses LoggingNavigatorObserver in GoRouter observers
   - Error handlers call loggingService.logError()

4. **No regressions:**
   - `flutter analyze frontend` passes
   - App starts and navigates without errors
   - Existing functionality (auth, projects, threads) still works
</verification>

<success_criteria>
- [ ] LoggingService singleton created with buffer (max 1000 entries)
- [ ] SessionService singleton created with UUID v4 session ID
- [ ] LoggingNavigatorObserver attached to GoRouter
- [ ] FlutterError.onError wired to LoggingService.logError()
- [ ] PlatformDispatcher.instance.onError wired to LoggingService.logError()
- [ ] Connectivity monitoring logs network state changes
- [ ] All log entries include timestamp, level, message, category, session_id
- [ ] Console shows navigation logs when switching screens
- [ ] `flutter analyze frontend` passes with no errors
- [ ] App runs without crashes
</success_criteria>

<output>
After completion, create `.planning/phases/45-frontend-logging-foundation/45-01-SUMMARY.md`
</output>
