# Phase 60: Frontend Integration - Research

**Researched:** 2026-02-15
**Domain:** Flutter UI integration for Claude Code provider selection and streaming display
**Confidence:** HIGH

## Summary

Phase 60 integrates Claude Code providers (SDK and CLI) into the Flutter frontend by extending the existing provider selection system, adding two new provider entries, and ensuring streaming display works identically across all providers. The backend adapter pattern (Phases 58-59) already handles differences between providers, so the frontend treats Claude Code providers as equals to direct API providers with only minor UX enhancements (experimental badges, model name display).

**Primary recommendation:** Extend the existing ProviderConfigs pattern with two new entries (claude-code-sdk and claude-code-cli), add experimental badges to settings dropdown items, display underlying model names, and rely on backend's StreamChunk normalization to keep streaming UI unchanged.

**Key findings:**
1. Provider system is already architected for extensibility - adding two new providers requires minimal changes
2. Thread model already stores `model_provider` field - provider is bound at thread creation and persists
3. Streaming display uses generic ChatEvent classes that work identically for all providers
4. Backend routes based on `thread.model_provider` and uses `is_agent_provider` flag to route streaming logic
5. Existing error display patterns (retry button, expandable details) can be reused for Claude Code provider errors

<user_constraints>
## User Constraints (from CONTEXT.md)

### Locked Decisions

**Provider selection UX:**
- Flat list in settings dropdown: all providers listed equally (Anthropic, OpenAI, Claude Code (SDK), Claude Code (CLI))
- Show "Experimental" badge/tag next to Claude Code provider names
- Display the underlying model name (e.g., "Claude Code (SDK) — Claude Sonnet 4") so user knows what runs underneath
- Provider selection is Settings-only — all new threads use the globally selected provider, no per-thread choice

**Streaming display:**
- Thinking blocks use the same display as the current direct API provider (existing collapsible thinking UI)
- Tool execution (search_documents, save_artifact) shows a subtle/generic indicator (spinner or "Working...") — no detailed tool-by-tool display
- Artifacts generated by Claude Code providers appear identically to direct API artifacts — no distinction
- No visual difference in chat bubbles between providers — all AI responses look the same regardless of source

**Provider switching:**
- Changing provider in Settings only affects new threads — existing threads keep the provider they were created with
- Thread info/details panel shows which provider was used to create the thread (useful for Phase 61 comparison)
- If Claude Code provider is unavailable (not installed, can't start), allow selection but show clear error when user tries to send a message
- Provider selection persists across sessions — app remembers last-used provider

**Error & status feedback:**
- CLI subprocess startup delay uses the existing typing/loading indicator — no special treatment
- Provider errors (subprocess crash, SDK failure) display inline in chat as an error bubble where the response would have been
- Error messages are user-friendly with an expandable "Show details" toggle for technical info (exit codes, stack traces)
- Retry button on error bubbles — same pattern as existing retry behavior for direct API failures

### Claude's Discretion

- Exact wording of experimental badge
- Loading indicator implementation details
- Error message copy and formatting
- How thread info panel displays provider (fits existing thread info patterns)

### Deferred Ideas (OUT OF SCOPE)

None — discussion stayed within phase scope

</user_constraints>

## Standard Stack

### Core Libraries (Already in Project)

| Library | Version | Purpose | Why Standard |
|---------|---------|---------|--------------|
| provider | 6.1.5+ | State management | Already used for ProviderProvider, ThemeProvider, ConversationProvider |
| shared_preferences | 2.5.4+ | Provider persistence | Already used for theme and provider selection persistence |
| flutter_client_sse | 2.0.0+ | SSE streaming | Already used for AI chat streaming (AIService) |
| go_router | 17.0.1+ | Navigation | Already used for all app routing |

### Supporting Widgets (Already in Project)

| Pattern | File | Purpose | When to Use |
|---------|------|---------|-------------|
| ProviderConfigs | core/constants.dart | Provider display config (name, icon, color) | Add new configs for claude-code-sdk/cli |
| ProviderProvider | providers/provider_provider.dart | Provider selection state management | Extend _availableProviders list |
| StreamingMessage | screens/conversation/widgets/streaming_message.dart | AI response streaming display | Already supports statusMessage for tool execution |
| GenerationErrorState | screens/conversation/widgets/generation_error_state.dart | Error display with retry | Pattern for provider error bubbles |
| ModeBadge | screens/conversation/widgets/mode_badge.dart | Chip/badge pattern | Reference for experimental badge styling |

### No New Dependencies Required

All UI components needed for Phase 60 are already available in the project. No new packages needed.

## Architecture Patterns

### Current Provider System Architecture

```
Frontend Provider Flow:
1. User selects provider in Settings → ProviderProvider.setProvider()
2. Provider saved to SharedPreferences immediately (crash-safe persistence)
3. User creates new thread → ThreadProvider.createThread(provider: selectedProvider)
4. Backend creates Thread with model_provider field set
5. User sends message → AIService(provider: thread.model_provider)
6. Backend routes to correct adapter based on provider string
7. Adapter streams ChatEvents → Frontend displays via StreamingMessage
```

**Key insight:** Provider is bound at thread creation, not at message send. Existing threads never change provider.

### Pattern 1: Adding New Provider Configs

**What:** Extend ProviderConfigs with claude-code-sdk and claude-code-cli entries

**When to use:** In core/constants.dart

**Example:**
```dart
// Source: Existing pattern in core/constants.dart
class ProviderConfigs {
  static const anthropic = ProviderConfig(
    id: 'anthropic',
    displayName: 'Claude',
    color: Color(0xFFD97706),
    icon: Icons.smart_toy_outlined,
  );

  // NEW: Claude Code SDK provider
  static const claudeCodeSdk = ProviderConfig(
    id: 'claude-code-sdk',
    displayName: 'Claude Code (SDK)',
    color: Color(0xFFD97706), // Same Anthropic orange
    icon: Icons.code_outlined,
    isExperimental: true,
    modelName: 'Claude Sonnet 4.5',
  );

  // NEW: Claude Code CLI provider
  static const claudeCodeCli = ProviderConfig(
    id: 'claude-code-cli',
    displayName: 'Claude Code (CLI)',
    color: Color(0xFFD97706), // Same Anthropic orange
    icon: Icons.terminal_outlined,
    isExperimental: true,
    modelName: 'Claude Sonnet 4.5',
  );

  static ProviderConfig getConfig(String? providerId) {
    switch (providerId) {
      case 'claude-code-sdk':
        return claudeCodeSdk;
      case 'claude-code-cli':
        return claudeCodeCli;
      // ... existing cases
    }
  }

  static const List<ProviderConfig> all = [
    anthropic,
    google,
    deepseek,
    claudeCodeSdk,
    claudeCodeCli,
  ];
}
```

**Note:** ProviderConfig class needs two new optional fields: `isExperimental` and `modelName`.

### Pattern 2: Settings Dropdown with Experimental Badges

**What:** Extend settings dropdown to show experimental badge and model name for Claude Code providers

**When to use:** In settings_screen.dart provider dropdown

**Example:**
```dart
// Source: Existing dropdown pattern in settings_screen.dart
DropdownButton<String>(
  value: providerProvider.selectedProvider,
  items: ProviderConfigs.all.map((config) {
    return DropdownMenuItem<String>(
      value: config.id,
      child: Row(
        mainAxisSize: MainAxisSize.min,
        children: [
          Icon(config.icon, color: config.color, size: 20),
          const SizedBox(width: 8),
          Text(config.displayName),
          // NEW: Experimental badge for Claude Code providers
          if (config.isExperimental) ...[
            const SizedBox(width: 8),
            Container(
              padding: const EdgeInsets.symmetric(horizontal: 6, vertical: 2),
              decoration: BoxDecoration(
                color: Theme.of(context).colorScheme.secondaryContainer,
                borderRadius: BorderRadius.circular(4),
              ),
              child: Text(
                'EXPERIMENTAL',
                style: TextStyle(
                  fontSize: 10,
                  fontWeight: FontWeight.w600,
                  color: Theme.of(context).colorScheme.onSecondaryContainer,
                ),
              ),
            ),
          ],
          // NEW: Model name display for Claude Code providers
          if (config.modelName != null) ...[
            const SizedBox(width: 8),
            Text(
              '— ${config.modelName}',
              style: Theme.of(context).textTheme.bodySmall?.copyWith(
                color: Theme.of(context).colorScheme.onSurfaceVariant,
              ),
            ),
          ],
        ],
      ),
    );
  }).toList(),
  onChanged: (value) {
    if (value != null) {
      providerProvider.setProvider(value);
    }
  },
);
```

### Pattern 3: Thread Info Panel Provider Display

**What:** Show which provider was used to create the thread (useful for Phase 61 comparison)

**When to use:** In conversation screen AppBar or thread details panel

**Example:**
```dart
// NEW: Thread info panel showing provider
class ThreadInfoPanel extends StatelessWidget {
  final Thread thread;

  Widget build(BuildContext context) {
    final providerConfig = ProviderConfigs.getConfig(thread.modelProvider);

    return ListTile(
      leading: Icon(providerConfig.icon, color: providerConfig.color),
      title: Text('Provider'),
      subtitle: Row(
        children: [
          Text(providerConfig.displayName),
          if (providerConfig.isExperimental) ...[
            const SizedBox(width: 8),
            Text(
              'EXPERIMENTAL',
              style: TextStyle(
                fontSize: 10,
                fontWeight: FontWeight.w600,
                color: Theme.of(context).colorScheme.secondary,
              ),
            ),
          ],
        ],
      ),
    );
  }
}
```

### Pattern 4: Provider Error Display with Expandable Details

**What:** Show provider errors inline as error bubbles with expandable technical details

**When to use:** When ErrorEvent received from streaming

**Example:**
```dart
// Source: Existing GenerationErrorState pattern
class ProviderErrorBubble extends StatefulWidget {
  final String userMessage;
  final String technicalDetails;
  final VoidCallback onRetry;

  State<ProviderErrorBubble> createState() => _ProviderErrorBubbleState();
}

class _ProviderErrorBubbleState extends State<ProviderErrorBubble> {
  bool _showDetails = false;

  Widget build(BuildContext context) {
    return Container(
      margin: const EdgeInsets.symmetric(horizontal: 16, vertical: 8),
      padding: const EdgeInsets.all(16),
      decoration: BoxDecoration(
        color: Theme.of(context).colorScheme.errorContainer,
        borderRadius: BorderRadius.circular(12),
      ),
      child: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: [
          Row(
            children: [
              Icon(Icons.error_outline,
                color: Theme.of(context).colorScheme.onErrorContainer),
              const SizedBox(width: 12),
              Expanded(
                child: Text(widget.userMessage,
                  style: TextStyle(
                    color: Theme.of(context).colorScheme.onErrorContainer)),
              ),
            ],
          ),
          const SizedBox(height: 8),
          TextButton.icon(
            onPressed: () => setState(() => _showDetails = !_showDetails),
            icon: Icon(_showDetails ? Icons.expand_less : Icons.expand_more),
            label: Text(_showDetails ? 'Hide details' : 'Show details'),
          ),
          if (_showDetails) ...[
            const Divider(),
            SelectableText(
              widget.technicalDetails,
              style: TextStyle(
                fontFamily: 'monospace',
                fontSize: 12,
                color: Theme.of(context).colorScheme.onErrorContainer,
              ),
            ),
          ],
          const SizedBox(height: 8),
          Align(
            alignment: Alignment.centerRight,
            child: FilledButton.tonal(
              onPressed: widget.onRetry,
              child: const Text('Retry'),
            ),
          ),
        ],
      ),
    );
  }
}
```

## Don't Hand-Roll

| Problem | Don't Build | Use Instead | Why |
|---------|-------------|-------------|-----|
| Provider persistence | Custom storage logic | shared_preferences (already used) | SharedPreferences handles platform differences, atomic writes, corruption recovery |
| Streaming display state | Custom event parsing | Existing ChatEvent classes (TextDeltaEvent, ToolExecutingEvent, etc.) | Backend already normalizes all providers to same event types |
| Error retry logic | Custom retry state machine | Existing ConversationProvider.canRetry pattern | Already handles retry for direct API failures, reuse for Claude Code providers |
| Experimental badges | Custom badge widgets | Container with padding + styled Text (established pattern) | Project doesn't use external badge libraries, keeps UI consistent |

**Key insight:** The backend adapter pattern means frontend treats all providers identically. Don't add provider-specific streaming logic — StreamChunk normalization handles that.

## Common Pitfalls

### Pitfall 1: Provider-Specific Streaming UI

**What goes wrong:** Adding special UI for Claude Code provider streaming (different bubbles, different loading indicators)

**Why it happens:** Assumption that agent providers need different display because they work differently internally

**How to avoid:** Trust the adapter pattern. Backend normalizes all providers to ChatEvent types (TextDeltaEvent, ToolExecutingEvent, MessageCompleteEvent, ErrorEvent). Frontend displays these identically regardless of source.

**Warning signs:**
- Code checking `if (provider == 'claude-code-sdk')` in streaming display logic
- Creating separate message bubble widgets for Claude Code providers
- Different loading indicators based on provider

### Pitfall 2: Forgetting Provider Persistence

**What goes wrong:** Adding new providers to dropdown but forgetting to update ProviderProvider validation

**Why it happens:** ProviderProvider validates against `_availableProviders` list. If new IDs not added, validation fails.

**How to avoid:** Update TWO places when adding providers:
1. `ProviderConfigs.all` (for display)
2. `ProviderProvider._availableProviders` (for validation)

**Warning signs:**
- "Invalid provider" error when selecting Claude Code provider
- Provider selection appears to work but doesn't persist after app restart

### Pitfall 3: Changing Provider Mid-Conversation

**What goes wrong:** Allowing user to change provider for existing thread, causing backend to use wrong adapter

**Why it happens:** Misunderstanding that provider is bound at thread creation, not at message send

**How to avoid:** Provider selection in Settings ONLY affects NEW threads. Existing threads use `thread.model_provider` from database, which never changes.

**Warning signs:**
- User reports "provider changed but still using old model"
- Backend errors about missing adapter for provider mismatch

### Pitfall 4: Not Handling Provider Unavailability

**What goes wrong:** App crashes or shows confusing errors when Claude Code CLI not installed

**Why it happens:** Assuming if provider is selectable, it's available

**How to avoid:** Backend returns clear error message when provider unavailable (RuntimeError in ClaudeCLIAdapter.__init__). Frontend displays this as inline error bubble with retry button.

**Warning signs:**
- App crashes when sending first message with claude-code-cli
- User sees generic "something went wrong" instead of "CLI not installed"

### Pitfall 5: Inconsistent Thread Info Display

**What goes wrong:** Thread info panel doesn't show provider, making Phase 61 comparison testing difficult

**Why it happens:** Provider info considered "internal detail" not relevant to user

**How to avoid:** Provider selection is a user-facing feature (Settings dropdown). Thread info panel should reflect user's choice for transparency and Phase 61 testing.

**Warning signs:**
- User can't tell which provider was used for a conversation
- QA team struggles to compare SDK vs CLI quality in Phase 61

## Code Examples

Verified patterns from existing codebase:

### Provider Selection Persistence (Already Working)

```dart
// Source: providers/provider_provider.dart
Future<void> setProvider(String provider) async {
  if (!_availableProviders.contains(provider)) {
    throw ArgumentError(
      'Invalid provider: $provider. Must be one of: ${_availableProviders.join(", ")}',
    );
  }

  _selectedProvider = provider;

  try {
    // Persist immediately before notifying listeners (critical for crash survival)
    await _prefs.setString(_providerKey, provider);
  } catch (e) {
    debugPrint('Failed to persist provider preference: $e');
  }

  notifyListeners();
}
```

**Key insight:** Persistence happens BEFORE notifyListeners() to ensure preference survives crashes.

### Thread Creation with Provider Binding (Already Working)

```dart
// Source: screens/threads/thread_create_dialog.dart
final providerProvider = context.read<ProviderProvider>();
await threadProvider.createThread(
  widget.projectId,
  title.isEmpty ? null : title,
  provider: providerProvider.selectedProvider, // Provider bound at creation
);
```

**Key insight:** `selectedProvider` at thread creation time becomes immutable `thread.model_provider`.

### Backend Provider Routing (Already Working)

```python
# Source: backend/app/routes/conversations.py
provider = thread.model_provider or "anthropic"
ai_service = AIService(provider=provider)

# AIService.__init__ uses LLMFactory to get correct adapter:
# - anthropic → AnthropicAdapter
# - claude-code-sdk → ClaudeAgentAdapter
# - claude-code-cli → ClaudeCLIAdapter
```

**Key insight:** Backend routes based on `thread.model_provider`, not user's current Settings selection.

### Streaming Display (Already Provider-Agnostic)

```dart
// Source: providers/conversation_provider.dart
await for (final event in _aiService.streamChat(_thread!.id, content)) {
  if (event is TextDeltaEvent) {
    _streamingText += event.text;
    notifyListeners();
  } else if (event is ToolExecutingEvent) {
    _statusMessage = event.status;
    notifyListeners();
  } else if (event is MessageCompleteEvent) {
    // Add assistant message with sources
    final assistantMessage = Message(
      id: 'temp-assistant-${DateTime.now().millisecondsSinceEpoch}',
      role: MessageRole.assistant,
      content: _streamingText.isNotEmpty ? _streamingText : event.content,
      createdAt: DateTime.now(),
      documentsUsed: event.documentsUsed,
    );
    _messages.add(assistantMessage);
  }
}
```

**Key insight:** No provider checks. All providers emit same ChatEvent types.

## State of the Art

| Old Approach | Current Approach | When Changed | Impact |
|--------------|------------------|--------------|--------|
| Per-message provider selection | Per-thread provider binding | Phase 57 (Nov 2024) | Provider consistency across conversation, simpler UX |
| Manual provider string validation | Enum-based validation (LLMProvider) | Phase 57 | Type safety in backend, prevents typos |
| Provider-specific streaming UI | Normalized ChatEvent display | Phase 58 (Feb 2026) | Provider-agnostic frontend, easier to add providers |
| Hardcoded provider lists | ProviderConfigs pattern | Phase 6 (2026) | Centralized provider display config |

**Deprecated/outdated:**
- Direct Anthropic SDK imports in frontend (removed in Phase 57, now backend-only)
- Per-message model selection in chat UI (never implemented, per-thread only)

## Open Questions

1. **Should experimental badge be permanent or remove after testing phase?**
   - What we know: CONTEXT.md specifies badge for Claude Code providers
   - What's unclear: Whether badge persists in production or removed after Phase 61
   - Recommendation: Add `isExperimental` flag to ProviderConfig, easy to toggle when stabilized

2. **Should we show actual model IDs or friendly names?**
   - What we know: Backend uses `claude-sonnet-4-5-20250514` (SDK) and `claude-sonnet-4-5-20250929` (CLI)
   - What's unclear: Whether to show full ID or "Claude Sonnet 4.5" in dropdown
   - Recommendation: Show friendly name "Claude Sonnet 4.5" in UI, full ID only in thread info/debug panel

3. **Should thread info panel be always visible or on-demand?**
   - What we know: User wants to compare providers in Phase 61, needs to know which provider was used
   - What's unclear: Whether panel is always visible, in AppBar, or accessible via info button
   - Recommendation: Add info icon to AppBar that shows bottom sheet with thread details (title, provider, created date, mode)

## Sources

### Primary (HIGH confidence)

- **Existing codebase:**
  - `frontend/lib/providers/provider_provider.dart` - Provider state management pattern
  - `frontend/lib/core/constants.dart` - ProviderConfigs pattern
  - `frontend/lib/screens/settings_screen.dart` - Settings dropdown pattern
  - `frontend/lib/models/thread.dart` - Thread.modelProvider field
  - `frontend/lib/services/ai_service.dart` - ChatEvent streaming classes
  - `frontend/lib/screens/conversation/widgets/` - Streaming display widgets
  - `backend/app/services/llm/base.py` - LLMProvider enum, StreamChunk
  - `backend/app/services/llm/claude_agent_adapter.py` - is_agent_provider pattern
  - `backend/app/routes/threads.py` - VALID_PROVIDERS, thread creation
  - `backend/app/routes/conversations.py` - Provider routing in stream_chat

- **Flutter official docs:**
  - Material Design 3 badges: https://m3.material.io/components/badges/overview
  - DropdownButton customization: https://api.flutter.dev/flutter/material/DropdownButton-class.html

### Secondary (MEDIUM confidence)

- Phase 58 and 59 research documents (adapter pattern established)
- CONTEXT.md user decisions (experimental badge, model name display)

### Tertiary (LOW confidence)

None - all findings verified against existing code

## Metadata

**Confidence breakdown:**
- Standard stack: HIGH - All dependencies already in project, no new packages needed
- Architecture patterns: HIGH - Extending proven patterns from existing code
- Pitfalls: HIGH - Identified from code review and Phase 58/59 learnings
- UI patterns: HIGH - Reusing established ModeBadge, GenerationErrorState, ProviderConfigs patterns

**Research date:** 2026-02-15
**Valid until:** 2026-03-15 (30 days - stable patterns, unlikely to change)

**Files requiring changes:**
- `frontend/lib/core/constants.dart` - Add ProviderConfig fields, new provider configs
- `frontend/lib/providers/provider_provider.dart` - Add to _availableProviders list
- `frontend/lib/screens/settings_screen.dart` - Update dropdown to show badges/model names
- `frontend/lib/screens/conversation/conversation_screen.dart` - Add thread info panel (optional)
- `backend/app/routes/threads.py` - Add to VALID_PROVIDERS list

**No backend streaming changes needed** - StreamChunk normalization already handles Claude Code providers
