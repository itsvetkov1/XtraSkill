---
phase: 44-backend-admin-api
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models.py
  - backend/app/utils/jwt.py
  - backend/app/routes/logs.py
  - backend/app/__init__.py
autonomous: true

must_haves:
  truths:
    - "Admin can list available log files via GET /api/logs"
    - "Admin can download specific log file via GET /api/logs/download"
    - "Authenticated users can send frontend logs via POST /api/logs/ingest"
    - "Non-admin users receive 403 when accessing admin endpoints"
    - "Path traversal attempts are blocked (e.g., ../../../etc/passwd)"

  artifacts:
    - path: "backend/app/models.py"
      provides: "User.is_admin boolean field"
      contains: "is_admin"

    - path: "backend/app/utils/jwt.py"
      provides: "get_admin_user dependency"
      exports: ["get_admin_user"]

    - path: "backend/app/routes/logs.py"
      provides: "Log management endpoints"
      exports: ["router"]
      min_lines: 150

  key_links:
    - from: "backend/app/routes/logs.py"
      to: "backend/app/utils/jwt.py"
      via: "Depends(get_admin_user)"
      pattern: "Depends\\(get_admin_user\\)"

    - from: "backend/app/routes/logs.py"
      to: "backend/app/config.py"
      via: "settings.log_dir_path"
      pattern: "settings\\.log_dir_path"

    - from: "backend/app/utils/jwt.py"
      to: "backend/app/models.py"
      via: "User.is_admin check"
      pattern: "user_obj\\.is_admin"
---

<objective>
Enable administrators to list, download, and manage log files through authenticated API endpoints with secure path validation.

**Purpose:** Implements LOG-07 requirement (Admin can download logs via authenticated API endpoint) to support pilot testing debugging workflows.

**Output:** Complete log management API with admin role enforcement, path traversal protection, and frontend log ingestion capability.
</objective>

<execution_context>
@G:\git_repos\BA_assistant\.claude\get-shit-done\workflows\execute-plan.md
@G:\git_repos\BA_assistant\.claude\get-shit-done\templates\summary.md
</execution_context>

<context>
@G:\git_repos\BA_assistant\.planning\PROJECT.md
@G:\git_repos\BA_assistant\.planning\ROADMAP.md
@G:\git_repos\BA_assistant\.planning\STATE.md
@G:\git_repos\BA_assistant\.planning\REQUIREMENTS.md

# Phase 44 research findings
@G:\git_repos\BA_assistant\.planning\phases\44-backend-admin-api\44-RESEARCH.md

# Phase 43 outputs (backend logging foundation)
@G:\git_repos\BA_assistant\.planning\phases\43-backend-logging-foundation\43-03-SUMMARY.md

# Current codebase files
@G:\git_repos\BA_assistant\backend\app\models.py
@G:\git_repos\BA_assistant\backend\app\utils\jwt.py
@G:\git_repos\BA_assistant\backend\app\config.py
@G:\git_repos\BA_assistant\backend\app\services\logging_service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add is_admin field to User model and create get_admin_user dependency</name>

  <files>
    backend/app/models.py
    backend/app/utils/jwt.py
  </files>

  <action>
Add admin role capability to support admin-only endpoints.

**backend/app/models.py:**
Add `is_admin: Mapped[bool]` field to User model after `oauth_id` field:
```python
is_admin: Mapped[bool] = mapped_column(
    default=False,
    nullable=False,
    server_default="0"  # SQLite compatibility (boolean stored as integer)
)
```

**backend/app/utils/jwt.py:**
Add new `get_admin_user` dependency after `get_current_user` function:
```python
from sqlalchemy import select
from sqlalchemy.ext.asyncio import AsyncSession
from app.database import get_db
from app.models import User

async def get_admin_user(
    user: dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db),
) -> User:
    """
    FastAPI dependency to verify current user has admin privileges.

    Usage:
        @router.get("/admin/logs")
        async def list_logs(admin: User = Depends(get_admin_user)):
            # Only admins reach here

    Args:
        user: Current authenticated user dict from get_current_user
        db: Database session

    Returns:
        User object with admin privileges

    Raises:
        HTTPException 403: If user lacks admin privileges
        HTTPException 404: If user not found in database
    """
    stmt = select(User).where(User.id == user["user_id"])
    result = await db.execute(stmt)
    user_obj = result.scalar_one_or_none()

    if not user_obj:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="User not found"
        )

    if not user_obj.is_admin:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Admin privileges required"
        )

    return user_obj
```

**Why this approach:**
- Boolean flag sufficient for single admin role (RESEARCH.md: RBAC library overkill for pilot)
- Dependency injection pattern matches existing `get_current_user` (consistency)
- Returns User object (not dict) so routes can access user properties if needed
- 403 Forbidden for non-admin (standard HTTP semantics)
- 404 for missing user (shouldn't happen with valid JWT, but defensive)
  </action>

  <verify>
Run backend tests to ensure imports work:
```bash
cd backend
python -c "from app.utils.jwt import get_admin_user; from app.models import User; print('Imports successful')"
```

Manual verification (after starting backend):
```bash
# 1. Get JWT token for non-admin user via login
# 2. Try accessing admin endpoint:
curl -X GET http://localhost:8000/api/logs \
  -H "Authorization: Bearer {token}"
# Expected: 403 Forbidden with "Admin privileges required"
```
  </verify>

  <done>
- User model has `is_admin` boolean field with default False
- `get_admin_user` dependency exists in app/utils/jwt.py
- Dependency checks user exists and has is_admin=True
- Non-admin users receive 403 Forbidden
- Imports succeed without errors
  </done>
</task>

<task type="auto">
  <name>Task 2: Create log management routes with secure file validation</name>

  <files>
    backend/app/routes/logs.py
  </files>

  <action>
Create new routes/logs.py module implementing three log endpoints with path traversal protection.

**File structure:**
```python
"""
Log management API endpoints.

Admin endpoints for listing and downloading log files.
Authenticated user endpoint for frontend log ingestion.
"""
from pathlib import Path
from typing import List

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.responses import FileResponse
from pydantic import BaseModel, Field, field_validator

from app.config import settings
from app.models import User
from app.services.logging_service import get_logging_service
from app.middleware.logging_middleware import get_correlation_id
from app.utils.jwt import get_admin_user, get_current_user

router = APIRouter(prefix="/api/logs", tags=["logs"])


# --- Path Validation Utility ---

def validate_log_file_path(filename: str, log_dir: Path) -> Path:
    """
    Validate that requested filename is within log directory.

    Prevents path traversal attacks like "../../../etc/passwd".

    Args:
        filename: User-provided filename (e.g., "app.log.2026-02-07")
        log_dir: Trusted base directory for logs

    Returns:
        Resolved absolute path if valid

    Raises:
        HTTPException 400: If path traversal detected
        HTTPException 404: If file not found
    """
    try:
        # Resolve to canonical absolute path (follows symlinks)
        base_dir = log_dir.resolve()
        requested_path = (base_dir / filename).resolve()

        # Ensure resolved path is within base directory
        if not requested_path.is_relative_to(base_dir):
            raise HTTPException(
                status_code=status.HTTP_400_BAD_REQUEST,
                detail="Invalid file path"
            )

        # Ensure file exists
        if not requested_path.exists() or not requested_path.is_file():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail="Log file not found"
            )

        return requested_path

    except (RuntimeError, ValueError):
        # RuntimeError: Infinite symlink loop
        # ValueError: Path manipulation issues
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Invalid file path"
        )


# --- Pydantic Models for Log Ingestion ---

class LogEntry(BaseModel):
    """Single frontend log entry."""
    timestamp: str
    level: str
    message: str
    category: str
    correlation_id: str | None = None
    session_id: str
    # Additional frontend-specific fields can be added as needed

    @field_validator('level')
    @classmethod
    def validate_level(cls, v: str) -> str:
        allowed = {'DEBUG', 'INFO', 'WARNING', 'ERROR', 'CRITICAL'}
        if v.upper() not in allowed:
            raise ValueError(f'Level must be one of {allowed}')
        return v.upper()


class LogBatch(BaseModel):
    """Batch of frontend logs."""
    logs: List[LogEntry] = Field(..., max_length=1000)

    @field_validator('logs')
    @classmethod
    def validate_not_empty(cls, v: List[LogEntry]) -> List[LogEntry]:
        if not v:
            raise ValueError('Log batch cannot be empty')
        return v


# --- Endpoints ---

@router.get("", response_model=List[str])
async def list_log_files(
    admin: User = Depends(get_admin_user),
):
    """
    List available log files for download.

    Returns filenames only (not absolute paths) for security.
    Files are sorted by modification time (most recent first).

    Security:
        - Requires admin authentication

    Returns:
        List of log filenames (e.g., ["app.log", "app.log.2026-02-07"])
    """
    log_dir = settings.log_dir_path

    # Glob for log files (app.log, app.log.2026-02-07, etc.)
    log_files = sorted(
        log_dir.glob("app.log*"),
        key=lambda p: p.stat().st_mtime,
        reverse=True  # Most recent first
    )

    # Return only filenames, not full paths
    return [f.name for f in log_files if f.is_file()]


@router.get("/download")
async def download_log_file(
    filename: str,
    admin: User = Depends(get_admin_user),
):
    """
    Download a specific log file.

    Query params:
        filename: Name of log file (e.g., "app.log", "app.log.2026-02-07")

    Returns:
        File stream as application/json attachment

    Security:
        - Requires admin authentication
        - Validates path to prevent traversal attacks
        - Only serves files from configured log directory

    Raises:
        HTTPException 400: Invalid filename or path traversal attempt
        HTTPException 404: File not found
    """
    log_dir = settings.log_dir_path
    file_path = validate_log_file_path(filename, log_dir)

    return FileResponse(
        path=str(file_path),
        filename=filename,
        media_type="application/json",
        headers={
            "Content-Disposition": f'attachment; filename="{filename}"'
        }
    )


@router.post("/ingest")
async def ingest_frontend_logs(
    batch: LogBatch,
    user: dict = Depends(get_current_user),
):
    """
    Ingest batched logs from frontend.

    Frontend sends logs periodically (every 5 minutes or on app pause).
    Logs are written to same log file with [FRONTEND] prefix for filtering.

    Request body:
        {
          "logs": [
            {
              "timestamp": "2026-02-08T12:34:56.789Z",
              "level": "INFO",
              "message": "User navigated to Projects screen",
              "category": "navigation",
              "session_id": "uuid",
              "correlation_id": "uuid"  // optional
            }
          ]
        }

    Security:
        - Requires authentication (any user can send their own logs)
        - Batch size limited to 1000 entries (prevents memory exhaustion)
        - Logs include user_id for attribution

    Returns:
        {"status": "success", "ingested": N}
    """
    logging_service = get_logging_service()

    # Write each log entry to structured log with [FRONTEND] prefix
    for entry in batch.logs:
        logging_service.log(
            level=entry.level,
            message=f"[FRONTEND] {entry.message}",
            category=f"frontend.{entry.category}",
            user_id=user["user_id"],
            session_id=entry.session_id,
            correlation_id=entry.correlation_id or get_correlation_id(),
            # Frontend timestamp included in message for reference
            frontend_timestamp=entry.timestamp,
        )

    return {
        "status": "success",
        "ingested": len(batch.logs)
    }
```

**Why this implementation:**
- pathlib.resolve() + is_relative_to() prevents path traversal (RESEARCH.md Pattern 2)
- FileResponse streams efficiently without memory bloat (RESEARCH.md Pattern 3)
- Pydantic max_length=1000 prevents memory exhaustion (RESEARCH.md Pitfall 5)
- Frontend logs written to same file with prefix (simpler than separate files)
- Admin required for list/download, any user for ingest (LOG-07 scope clarified)
  </action>

  <verify>
Import verification:
```bash
cd backend
python -c "from app.routes.logs import router; print('Logs router imported successfully')"
```

Path traversal test (manual, after registering routes):
```bash
# Test 1: Normal file (should work for admin)
curl -X GET "http://localhost:8000/api/logs/download?filename=app.log" \
  -H "Authorization: Bearer {admin_token}"
# Expected: 200 with file download

# Test 2: Path traversal attempt (should be blocked)
curl -X GET "http://localhost:8000/api/logs/download?filename=../../../etc/passwd" \
  -H "Authorization: Bearer {admin_token}"
# Expected: 400 Bad Request with "Invalid file path"

# Test 3: Non-existent file
curl -X GET "http://localhost:8000/api/logs/download?filename=fake.log" \
  -H "Authorization: Bearer {admin_token}"
# Expected: 404 Not Found
```
  </verify>

  <done>
- backend/app/routes/logs.py exists with router exported
- GET /api/logs endpoint lists log files (admin only)
- GET /api/logs/download endpoint serves files securely (admin only)
- POST /api/logs/ingest endpoint accepts frontend logs (authenticated users)
- Path traversal attempts return 400 Bad Request
- Non-existent files return 404 Not Found
- FileResponse used for efficient streaming
  </done>
</task>

<task type="auto">
  <name>Task 3: Register logs router in main application</name>

  <files>
    backend/app/__init__.py
  </files>

  <action>
Register the new logs router in the FastAPI application.

**backend/app/__init__.py:**
Add import and include_router call alongside existing route registrations:

Find the section with existing router imports and registrations (likely after other route imports like `from app.routes import auth, conversations, documents, projects, threads, artifacts`).

Add:
```python
from app.routes import logs
```

Then in the app initialization section (after existing `app.include_router()` calls):
```python
app.include_router(logs.router)
```

**Why this approach:**
- Follows existing pattern in codebase (consistent with other routes)
- Registers under /api/logs prefix (defined in router)
- No special middleware needed (admin check in dependencies)
  </action>

  <verify>
Start backend and verify endpoints appear in OpenAPI docs:
```bash
cd backend
python run.py
# Then visit http://localhost:8000/docs
# Verify three new endpoints appear under "logs" tag:
# - GET /api/logs
# - GET /api/logs/download
# - POST /api/logs/ingest
```

Test endpoint availability:
```bash
# Without auth (should fail with 401)
curl -X GET http://localhost:8000/api/logs
# Expected: 401 Unauthorized

# With valid JWT (non-admin, should fail with 403)
curl -X GET http://localhost:8000/api/logs \
  -H "Authorization: Bearer {non_admin_token}"
# Expected: 403 Forbidden
```
  </verify>

  <done>
- logs.router registered in backend/app/__init__.py
- All three endpoints appear in OpenAPI docs (/docs)
- Endpoints respond to requests (401 without auth, 403 for non-admin)
- Backend starts without import errors
  </done>
</task>

</tasks>

<verification>
**Overall phase verification:**

1. **Admin role enforcement:**
   - Create test admin user (manually set is_admin=1 in database)
   - Verify admin can list logs: `GET /api/logs` returns 200
   - Verify non-admin gets 403: `GET /api/logs` with non-admin token returns 403

2. **Log file listing:**
   - Admin calls `GET /api/logs`
   - Receives array of filenames like `["app.log", "app.log.2026-02-07"]`
   - Most recent file appears first

3. **Log file download:**
   - Admin calls `GET /api/logs/download?filename=app.log`
   - Receives file as JSON attachment with proper Content-Disposition header
   - File content is valid JSON lines (structured logs)

4. **Path traversal protection:**
   - Admin attempts `GET /api/logs/download?filename=../../../etc/passwd`
   - Receives 400 Bad Request
   - No file system access outside log directory

5. **Frontend log ingestion:**
   - Authenticated user POSTs to `/api/logs/ingest` with valid LogBatch
   - Receives `{"status": "success", "ingested": N}`
   - Logs appear in backend/logs/app.log with [FRONTEND] prefix

6. **Database migration:**
   - User table has is_admin column (check with sqlite3 or DB tool)
   - Existing users have is_admin=0 (default False)
   - New users created after migration have is_admin=0

**Success criteria:** All six verification points pass.
</verification>

<success_criteria>
**Phase complete when:**

1. ✅ User model has `is_admin` boolean field
2. ✅ `get_admin_user` dependency exists and enforces admin check
3. ✅ Non-admin users receive 403 on admin endpoints
4. ✅ `GET /api/logs` lists available log files (admin only)
5. ✅ `GET /api/logs/download` serves files securely (admin only)
6. ✅ `POST /api/logs/ingest` accepts frontend logs (any authenticated user)
7. ✅ Path traversal attacks blocked (400 Bad Request)
8. ✅ All endpoints registered and appear in OpenAPI docs
9. ✅ Backend starts without errors
10. ✅ LOG-07 requirement satisfied (Admin can download logs via authenticated API endpoint)

**Measurable outcomes:**
- 3 new API endpoints operational
- 1 new dependency function (get_admin_user)
- 1 new model field (User.is_admin)
- 0 path traversal vulnerabilities
</success_criteria>

<output>
After completion, create `.planning/phases/44-backend-admin-api/44-01-SUMMARY.md` following the standard summary template.

Include:
- Security verification results (path traversal tests)
- Admin role enforcement tests
- Example API responses
- Integration with Phase 43 logging infrastructure
</output>
