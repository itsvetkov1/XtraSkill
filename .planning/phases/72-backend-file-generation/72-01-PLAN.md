---
phase: 72-backend-file-generation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/app/models.py
  - backend/alembic/versions/xxxx_add_generated_file_artifact_type.py
  - backend/app/mcp_server.py
  - backend/main.py
autonomous: true
requirements: [GEN-03, GEN-04]

must_haves:
  truths:
    - "The ArtifactType enum includes a 'generated_file' value usable in Artifact creation"
    - "An Alembic migration checkpoint exists for the generated_file enum addition"
    - "A FastMCP HTTP server is mounted at /mcp in the FastAPI app"
    - "The save_artifact MCP tool persists artifacts to the database via a session registry"
  artifacts:
    - path: "backend/app/models.py"
      provides: "GENERATED_FILE enum value in ArtifactType"
      contains: "GENERATED_FILE = \"generated_file\""
    - path: "backend/app/mcp_server.py"
      provides: "FastMCP server with save_artifact tool and session registry"
      exports: ["mcp_app", "register_mcp_session", "unregister_mcp_session"]
    - path: "backend/main.py"
      provides: "MCP server mounted at /mcp sub-path"
      contains: "app.mount(\"/mcp\""
  key_links:
    - from: "backend/app/mcp_server.py"
      to: "backend/app/models.py"
      via: "Artifact model + ArtifactType.GENERATED_FILE import"
      pattern: "ArtifactType\\.GENERATED_FILE"
    - from: "backend/main.py"
      to: "backend/app/mcp_server.py"
      via: "ASGI sub-app mount"
      pattern: "from app.mcp_server import"
---

<objective>
Create the data model addition (generated_file ArtifactType) and the FastMCP HTTP server that the Claude CLI subprocess will connect to for file generation.

Purpose: Provides the infrastructure layer that Plan 02 will wire into the request flow. The MCP server must be mounted before the process pool starts (lifespan event), and the enum value must exist before any artifact can be persisted.

Output: `models.py` with new enum value, Alembic checkpoint migration, `mcp_server.py` with save_artifact tool, and `main.py` mounting the MCP sub-app.
</objective>

<execution_context>
@/Users/a1testingmac/.claude/get-shit-done/workflows/execute-plan.md
@/Users/a1testingmac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/REQUIREMENTS.md
@.planning/STATE.md
@.planning/phases/72-backend-file-generation/72-RESEARCH.md

@backend/app/models.py
@backend/main.py
@backend/app/services/mcp_tools.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add generated_file ArtifactType enum value and Alembic checkpoint migration</name>
  <files>backend/app/models.py, backend/alembic/versions/xxxx_add_generated_file_artifact_type.py</files>
  <action>
1. In `backend/app/models.py`, add `GENERATED_FILE = "generated_file"` to the `ArtifactType` enum class (after the existing `BRD = "brd"` line). Add a comment: `# Assistant thread file generation (Phase 72)`.

2. Generate an Alembic migration:
   ```bash
   cd backend && venv/bin/alembic revision --autogenerate -m "add_generated_file_artifact_type"
   ```

3. Edit the generated migration file so both `upgrade()` and `downgrade()` contain only `pass` with a docstring explaining that ArtifactType uses `native_enum=False` (VARCHAR storage in SQLite), so adding a new enum value only requires updating the Python enum class. No SQL DDL is needed. The `down_revision` should point to `e330b6621b90` (the current head).

4. Run the migration to stamp the database:
   ```bash
   cd backend && venv/bin/alembic upgrade head
   ```

Avoid: Do NOT add any SQL ALTER statements. SQLite with native_enum=False stores enum values as plain VARCHAR strings; the migration is purely a version checkpoint.
  </action>
  <verify>
Run: `cd backend && venv/bin/python -c "from app.models import ArtifactType; print(ArtifactType.GENERATED_FILE.value)"` -- should print `generated_file`.

Run: `cd backend && venv/bin/alembic current` -- should show the new migration as current head.
  </verify>
  <done>ArtifactType.GENERATED_FILE exists and returns "generated_file"; Alembic history includes the new checkpoint migration and database is at head.</done>
</task>

<task type="auto">
  <name>Task 2: Create FastMCP server with save_artifact tool and mount in FastAPI</name>
  <files>backend/app/mcp_server.py, backend/main.py</files>
  <action>
1. Create NEW file `backend/app/mcp_server.py` with:

   a. Import `FastMCP` from `mcp.server.fastmcp`. Import `Artifact`, `ArtifactType` from `app.models`. Import `json`, `logging`.

   b. Create module-level `mcp_app = FastMCP("assistant-tools")` instance.

   c. Create a session registry dict: `_session_registry: dict[str, dict] = {}` mapping session_token to `{"db": AsyncSession, "thread_id": str}`.

   d. Create `register_mcp_session(token: str, db, thread_id: str) -> None` that adds to the registry.

   e. Create `unregister_mcp_session(token: str) -> None` that removes from the registry (using `.pop(token, None)`).

   f. Create the `save_artifact` tool decorated with `@mcp_app.tool()`:
      ```python
      @mcp_app.tool()
      async def save_artifact(session_token: str, title: str, content_markdown: str) -> str:
          """Save a generated file artifact for the current Assistant thread.
          Call ONCE with the session_token from your system prompt, then stop."""
      ```
      - Look up `session_token` in `_session_registry`. If not found, return `"Error: session context not found"`.
      - Create an `Artifact` instance with `thread_id=ctx["thread_id"]`, `artifact_type=ArtifactType.GENERATED_FILE`, `title=title`, `content_markdown=content_markdown`.
      - `ctx["db"].add(artifact)`, `await ctx["db"].commit()`, `await ctx["db"].refresh(artifact)`.
      - Build `event_data = {"id": artifact.id, "artifact_type": "generated_file", "title": artifact.title}`.
      - Return `f"ARTIFACT_CREATED:{json.dumps(event_data)}|File generated successfully."` (this follows the existing ARTIFACT_CREATED marker protocol from `mcp_tools.py`).

2. In `backend/main.py`:
   - Add import: `from app.mcp_server import mcp_app`
   - Add mount BEFORE the lifespan function definition (at module level, after app creation, after router registration): `app.mount("/mcp", mcp_app.streamable_http_app())`
   - Place the mount after all `app.include_router(...)` calls but before the `@app.get("/")` root endpoint.

Important: The MCP sub-app mount MUST happen at module level (not inside the lifespan function) so routes are registered before the process pool warm-up in lifespan. This avoids Pitfall 4 from research (ECONNREFUSED on first request).

Naming: Use `mcp_app` as the variable name (not `mcp`) to avoid shadowing the `mcp` package import.
  </action>
  <verify>
Run: `cd backend && venv/bin/python -c "from app.mcp_server import mcp_app, register_mcp_session, unregister_mcp_session; print('MCP server imports OK')"` -- should print OK.

Run: `cd backend && venv/bin/python -c "from main import app; routes = [r.path for r in app.routes]; print('/mcp' in str(routes) or any('/mcp' in str(r) for r in app.routes))"` -- should confirm MCP mount exists.
  </verify>
  <done>mcp_server.py exists with save_artifact tool and session registry; main.py mounts the MCP sub-app at /mcp; both import without errors.</done>
</task>

</tasks>

<verification>
1. `cd backend && venv/bin/python -c "from app.models import ArtifactType; assert ArtifactType.GENERATED_FILE.value == 'generated_file'"` passes
2. `cd backend && venv/bin/python -c "from app.mcp_server import mcp_app, save_artifact, register_mcp_session"` imports successfully
3. `cd backend && venv/bin/alembic current` shows the new migration as head
4. `cd backend && venv/bin/python -c "from main import app; print([r for r in app.routes if hasattr(r, 'path') and 'mcp' in r.path])"` shows the MCP mount
</verification>

<success_criteria>
- ArtifactType.GENERATED_FILE exists with value "generated_file"
- Alembic migration for the checkpoint is applied
- mcp_server.py has save_artifact tool with session registry pattern
- FastAPI app has MCP sub-app mounted at /mcp
- All imports resolve without errors
</success_criteria>

<output>
After completion, create `.planning/phases/72-backend-file-generation/72-01-SUMMARY.md`
</output>
