---
phase: 29-backend-service-tests
plan: 03
type: execute
wave: 2
depends_on: [29-01]
files_modified:
  - backend/tests/unit/services/test_auth_service.py
autonomous: true

must_haves:
  truths:
    - "OAuth service can be tested with mocked HTTP clients"
    - "CSRF state validation prevents attacks"
    - "User upsert creates new users and updates existing ones"
    - "OAuth flow extracts correct user info from providers"
  artifacts:
    - path: "backend/tests/unit/services/test_auth_service.py"
      provides: "OAuth2Service tests with mocked providers"
      min_lines: 120
  key_links:
    - from: "test_auth_service.py"
      to: "app/services/auth_service.py"
      via: "direct import"
      pattern: "from app.services.auth_service import"
    - from: "test_auth_service.py"
      to: "unittest.mock"
      via: "AsyncMock for OAuth client"
      pattern: "AsyncMock|patch"
---

<objective>
Create unit tests for auth_service module covering OAuth2Service class methods.

Purpose: Fulfill BSVC-01 requirement. Test OAuth flow logic without making real HTTP requests by mocking authlib's AsyncOAuth2Client. Cover CSRF validation, token exchange, user info retrieval, and user upsert operations.

Output: Test file with 80%+ coverage on auth_service.py OAuth methods.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/29-backend-service-tests/29-RESEARCH.md
@backend/app/services/auth_service.py
@backend/tests/fixtures/db_fixtures.py
@backend/tests/fixtures/factories.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create auth_service tests with mocked OAuth clients</name>
  <files>backend/tests/unit/services/test_auth_service.py</files>
  <action>
Create comprehensive test file for auth_service:

```python
"""Unit tests for auth_service OAuth2Service."""

import pytest
from unittest.mock import AsyncMock, Mock, patch
from app.services.auth_service import OAuth2Service
from app.models import OAuthProvider, User


class TestGenerateState:
    """Tests for _generate_state method."""

    def test_generates_32_char_hex(self, db_session):
        """State is 32-character hex string."""
        service = OAuth2Service(db_session)
        state = service._generate_state()

        assert len(state) == 32
        assert all(c in "0123456789abcdef" for c in state)

    def test_generates_unique_states(self, db_session):
        """Each call generates unique state."""
        service = OAuth2Service(db_session)

        states = [service._generate_state() for _ in range(10)]

        assert len(set(states)) == 10  # All unique


class TestGetGoogleAuthUrl:
    """Tests for get_google_auth_url method."""

    @pytest.mark.asyncio
    async def test_returns_url_and_state(self, db_session):
        """Returns authorization URL and state parameter."""
        service = OAuth2Service(db_session)

        with patch.object(service, '_generate_state', return_value='test-state-123'):
            url, state = await service.get_google_auth_url("http://localhost/callback")

        assert state == "test-state-123"
        assert "accounts.google.com" in url
        assert "state=test-state-123" in url

    @pytest.mark.asyncio
    async def test_includes_scopes_in_url(self, db_session):
        """URL includes required OAuth scopes."""
        service = OAuth2Service(db_session)

        url, _ = await service.get_google_auth_url("http://localhost/callback")

        # URL should reference scopes (encoded)
        assert "scope=" in url


class TestGetMicrosoftAuthUrl:
    """Tests for get_microsoft_auth_url method."""

    @pytest.mark.asyncio
    async def test_returns_url_and_state(self, db_session):
        """Returns Microsoft authorization URL and state."""
        service = OAuth2Service(db_session)

        with patch.object(service, '_generate_state', return_value='ms-state-456'):
            url, state = await service.get_microsoft_auth_url("http://localhost/callback")

        assert state == "ms-state-456"
        assert "login.microsoftonline.com" in url


class TestProcessGoogleCallback:
    """Tests for process_google_callback method."""

    @pytest.mark.asyncio
    async def test_csrf_validation_fails_on_mismatch(self, db_session):
        """Raises ValueError when state doesn't match."""
        service = OAuth2Service(db_session)

        with pytest.raises(ValueError, match="CSRF"):
            await service.process_google_callback(
                code="auth-code",
                state="received-state",
                expected_state="different-state",
                redirect_uri="http://localhost/callback"
            )

    @pytest.mark.asyncio
    async def test_creates_new_user(self, db_session):
        """Creates new user when OAuth user doesn't exist."""
        service = OAuth2Service(db_session)

        # Mock the OAuth client
        mock_client = AsyncMock()
        mock_client.fetch_token = AsyncMock(return_value={"access_token": "token123"})
        mock_client.get = AsyncMock(return_value=Mock(json=lambda: {
            "id": "google-user-123",
            "email": "test@example.com",
            "name": "Test User"
        }))

        with patch('app.services.auth_service.AsyncOAuth2Client', return_value=mock_client):
            user = await service.process_google_callback(
                code="auth-code",
                state="same-state",
                expected_state="same-state",
                redirect_uri="http://localhost/callback"
            )

        assert user.email == "test@example.com"
        assert user.oauth_provider == OAuthProvider.GOOGLE
        assert user.oauth_id == "google-user-123"
        assert user.display_name == "Test User"

    @pytest.mark.asyncio
    async def test_updates_existing_user(self, db_session, user):
        """Updates existing user's email and display_name."""
        # Create existing user with Google OAuth
        user.oauth_provider = OAuthProvider.GOOGLE
        user.oauth_id = "google-existing-123"
        user.email = "old@example.com"
        user.display_name = "Old Name"
        db_session.add(user)
        await db_session.commit()

        service = OAuth2Service(db_session)

        mock_client = AsyncMock()
        mock_client.fetch_token = AsyncMock(return_value={"access_token": "token"})
        mock_client.get = AsyncMock(return_value=Mock(json=lambda: {
            "id": "google-existing-123",  # Same OAuth ID
            "email": "new@example.com",   # Updated email
            "name": "New Name"            # Updated name
        }))

        with patch('app.services.auth_service.AsyncOAuth2Client', return_value=mock_client):
            result = await service.process_google_callback(
                code="code",
                state="state",
                expected_state="state",
                redirect_uri="http://localhost/callback"
            )

        # Should be same user with updated info
        assert result.id == user.id
        assert result.email == "new@example.com"
        assert result.display_name == "New Name"


class TestProcessMicrosoftCallback:
    """Tests for process_microsoft_callback method."""

    @pytest.mark.asyncio
    async def test_csrf_validation_fails(self, db_session):
        """Raises ValueError on state mismatch."""
        service = OAuth2Service(db_session)

        with pytest.raises(ValueError, match="CSRF"):
            await service.process_microsoft_callback(
                code="code",
                state="wrong",
                expected_state="correct",
                redirect_uri="http://localhost/callback"
            )

    @pytest.mark.asyncio
    async def test_creates_user_from_microsoft(self, db_session):
        """Creates user from Microsoft Graph API response."""
        service = OAuth2Service(db_session)

        mock_client = AsyncMock()
        mock_client.fetch_token = AsyncMock(return_value={"access_token": "ms-token"})
        mock_client.get = AsyncMock(return_value=Mock(json=lambda: {
            "id": "ms-user-456",
            "mail": "msuser@company.com",
            "displayName": "MS User"
        }))

        with patch('app.services.auth_service.AsyncOAuth2Client', return_value=mock_client):
            user = await service.process_microsoft_callback(
                code="code",
                state="state",
                expected_state="state",
                redirect_uri="http://localhost/callback"
            )

        assert user.oauth_provider == OAuthProvider.MICROSOFT
        assert user.oauth_id == "ms-user-456"
        assert user.email == "msuser@company.com"

    @pytest.mark.asyncio
    async def test_uses_upn_when_mail_missing(self, db_session):
        """Uses userPrincipalName when mail is null."""
        service = OAuth2Service(db_session)

        mock_client = AsyncMock()
        mock_client.fetch_token = AsyncMock(return_value={"access_token": "token"})
        mock_client.get = AsyncMock(return_value=Mock(json=lambda: {
            "id": "ms-user-789",
            "mail": None,
            "userPrincipalName": "user@contoso.onmicrosoft.com",
            "displayName": "User"
        }))

        with patch('app.services.auth_service.AsyncOAuth2Client', return_value=mock_client):
            user = await service.process_microsoft_callback(
                code="code",
                state="s",
                expected_state="s",
                redirect_uri="http://localhost"
            )

        assert user.email == "user@contoso.onmicrosoft.com"


class TestUpsertUser:
    """Tests for _upsert_user method."""

    @pytest.mark.asyncio
    async def test_creates_new_user(self, db_session):
        """Creates new user when not found."""
        service = OAuth2Service(db_session)

        user = await service._upsert_user(
            oauth_provider=OAuthProvider.GOOGLE,
            oauth_id="new-user-id",
            email="new@test.com",
            display_name="New User"
        )

        assert user.oauth_id == "new-user-id"
        assert user.email == "new@test.com"

    @pytest.mark.asyncio
    async def test_updates_existing_user(self, db_session):
        """Updates existing user's info."""
        # Create existing user
        existing = User(
            oauth_provider=OAuthProvider.GOOGLE,
            oauth_id="existing-id",
            email="old@test.com",
            display_name="Old"
        )
        db_session.add(existing)
        await db_session.commit()
        user_id = existing.id

        service = OAuth2Service(db_session)

        # Upsert with same OAuth ID but different info
        user = await service._upsert_user(
            oauth_provider=OAuthProvider.GOOGLE,
            oauth_id="existing-id",
            email="updated@test.com",
            display_name="Updated"
        )

        assert user.id == user_id  # Same user
        assert user.email == "updated@test.com"
        assert user.display_name == "Updated"

    @pytest.mark.asyncio
    async def test_different_providers_different_users(self, db_session):
        """Same OAuth ID but different providers creates separate users."""
        service = OAuth2Service(db_session)

        google_user = await service._upsert_user(
            oauth_provider=OAuthProvider.GOOGLE,
            oauth_id="same-id",
            email="google@test.com"
        )

        ms_user = await service._upsert_user(
            oauth_provider=OAuthProvider.MICROSOFT,
            oauth_id="same-id",
            email="ms@test.com"
        )

        assert google_user.id != ms_user.id

    @pytest.mark.asyncio
    async def test_handles_none_display_name(self, db_session):
        """Handles None display_name gracefully."""
        service = OAuth2Service(db_session)

        user = await service._upsert_user(
            oauth_provider=OAuthProvider.GOOGLE,
            oauth_id="no-name-user",
            email="noname@test.com",
            display_name=None
        )

        assert user.display_name is None
```
  </action>
  <verify>
```bash
cd backend && python -m pytest tests/unit/services/test_auth_service.py -v
```
All tests pass.
  </verify>
  <done>20 tests pass for auth_service OAuth2Service</done>
</task>

<task type="auto">
  <name>Task 2: Verify auth_service coverage</name>
  <files>None (verification only)</files>
  <action>
Run coverage report specifically for auth_service:

```bash
cd backend && python -m pytest tests/unit/services/test_auth_service.py \
  --cov=app.services.auth_service \
  --cov-report=term-missing \
  --cov-fail-under=80
```

The report should show:
- _generate_state: 100% covered
- get_google_auth_url: covered
- process_google_callback: covered (except error paths we intentionally skip)
- get_microsoft_auth_url: covered
- process_microsoft_callback: covered
- _upsert_user: 100% covered

If coverage is below 80%, add tests for uncovered lines.
  </action>
  <verify>
Coverage report shows 80%+ line coverage for auth_service.py
  </verify>
  <done>auth_service achieves 80%+ test coverage</done>
</task>

</tasks>

<verification>
Run auth_service tests:
```bash
cd backend && python -m pytest tests/unit/services/test_auth_service.py -v
```
All 20 tests should pass.

Verify coverage target:
```bash
cd backend && python -m pytest tests/unit/services/test_auth_service.py --cov=app.services.auth_service --cov-report=term-missing
```
Should show 80%+ coverage.
</verification>

<success_criteria>
1. test_auth_service.py has 20 passing tests
2. CSRF validation tested (state mismatch raises ValueError)
3. User creation tested (new OAuth user)
4. User update tested (existing OAuth user)
5. Both Google and Microsoft flows covered
6. auth_service achieves 80%+ line coverage
7. No real HTTP requests made (all mocked)
</success_criteria>

<output>
After completion, create `.planning/phases/29-backend-service-tests/29-03-SUMMARY.md`
</output>
