---
phase: 04-artifact-generation-export
plan: 02
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - backend/requirements.txt
  - backend/app/services/export_service.py
  - backend/app/routes/artifacts.py
  - backend/app/templates/artifacts/base.html
  - backend/app/templates/artifacts/user_stories.html
  - backend/app/templates/artifacts/acceptance_criteria.html
  - backend/app/templates/artifacts/requirements_doc.html
autonomous: true

must_haves:
  truths:
    - "User can export artifact as Markdown file"
    - "User can export artifact as PDF file"
    - "User can export artifact as Word document"
    - "Exported files open correctly in respective applications"
  artifacts:
    - path: "backend/requirements.txt"
      provides: "python-docx, weasyprint, markdown dependencies"
      contains: "python-docx"
    - path: "backend/app/services/export_service.py"
      provides: "PDF, Word, Markdown export functions"
      exports: ["export_pdf", "export_docx", "export_markdown"]
    - path: "backend/app/routes/artifacts.py"
      provides: "GET export endpoint for three formats"
      contains: "/artifacts/{artifact_id}/export/{format}"
    - path: "backend/app/templates/artifacts/base.html"
      provides: "Base HTML template for PDF styling"
      contains: "<!doctype html>"
  key_links:
    - from: "backend/app/routes/artifacts.py"
      to: "backend/app/services/export_service.py"
      via: "import export functions"
      pattern: "from app.services.export_service import"
    - from: "backend/app/services/export_service.py"
      to: "backend/app/templates/artifacts/"
      via: "Jinja2 template rendering"
      pattern: "Environment.*loader.*FileSystemLoader"
---

<objective>
Create backend export service for PDF, Word, and Markdown formats with API endpoint.

Purpose: Enable users to download generated artifacts in professional document formats suitable for stakeholder delivery.

Output: Export service with format converters, HTML templates for PDF styling, and API endpoint returning file streams.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-artifact-generation-export/04-RESEARCH.md
@.planning/phases/04-artifact-generation-export/04-01-SUMMARY.md

# Existing patterns
@backend/app/routes/artifacts.py
@backend/requirements.txt
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install export dependencies and create HTML templates</name>
  <files>
    backend/requirements.txt
    backend/app/templates/artifacts/base.html
    backend/app/templates/artifacts/user_stories.html
    backend/app/templates/artifacts/acceptance_criteria.html
    backend/app/templates/artifacts/requirements_doc.html
  </files>
  <action>
1. Add dependencies to requirements.txt:
   ```
   python-docx==1.2.0
   weasyprint==68.0
   markdown>=3.5
   jinja2>=3.1.0
   ```

2. Create templates directory: backend/app/templates/artifacts/

3. Create base.html template with professional PDF styling:
   ```html
   <!doctype html>
   <html>
   <head>
       <meta charset="utf-8">
       <style>
           @page { margin: 2cm; size: A4; }
           body {
               font-family: 'Segoe UI', Tahoma, sans-serif;
               font-size: 11pt;
               line-height: 1.6;
               color: #333;
           }
           h1 {
               color: #1a73e8;
               border-bottom: 2px solid #1a73e8;
               padding-bottom: 0.5em;
               font-size: 24pt;
           }
           h2 {
               color: #34a853;
               margin-top: 1.5em;
               font-size: 16pt;
           }
           h3 {
               color: #666;
               font-size: 13pt;
           }
           .user-story {
               background: #f8f9fa;
               padding: 1em;
               margin: 1em 0;
               border-radius: 8px;
               border-left: 4px solid #1a73e8;
           }
           ul, ol { margin-left: 1.5em; }
           li { margin: 0.3em 0; }
           code {
               background: #f1f3f4;
               padding: 0.2em 0.4em;
               border-radius: 3px;
               font-family: 'Consolas', monospace;
           }
           table {
               border-collapse: collapse;
               width: 100%;
               margin: 1em 0;
           }
           th, td {
               border: 1px solid #ddd;
               padding: 8px;
               text-align: left;
           }
           th { background: #f8f9fa; }
           .metadata {
               color: #666;
               font-size: 9pt;
               margin-top: 2em;
               border-top: 1px solid #ddd;
               padding-top: 0.5em;
           }
       </style>
   </head>
   <body>
       {% block content %}{% endblock %}
       <div class="metadata">
           Generated by BA Assistant | {{ created_at.strftime('%Y-%m-%d %H:%M') }}
       </div>
   </body>
   </html>
   ```

4. Create user_stories.html extending base:
   ```html
   {% extends "base.html" %}
   {% block content %}
   {{ content | safe }}
   {% endblock %}
   ```

5. Create acceptance_criteria.html and requirements_doc.html with same pattern (can customize styling later).

Run pip install:
```bash
cd backend && pip install python-docx==1.2.0 weasyprint==68.0 markdown jinja2
```

Note: WeasyPrint requires GTK3 on Windows. If installation fails, document the requirement and proceed - PDF export can be tested on Linux/Mac or Docker.
  </action>
  <verify>
```bash
cd backend && python -c "import docx; import weasyprint; import markdown; import jinja2; print('All imports OK')"
ls backend/app/templates/artifacts/
```
  </verify>
  <done>Dependencies installed, HTML templates created for PDF styling</done>
</task>

<task type="auto">
  <name>Task 2: Create export service with format converters</name>
  <files>backend/app/services/export_service.py</files>
  <action>
Create export_service.py with three export functions:

```python
from io import BytesIO
from pathlib import Path
from typing import Literal
import markdown
from jinja2 import Environment, FileSystemLoader
from docx import Document
from docx.shared import Pt, Inches
from docx.enum.text import WD_ALIGN_PARAGRAPH

from app.models import Artifact

# Template directory
TEMPLATE_DIR = Path(__file__).parent.parent / "templates" / "artifacts"

def export_markdown(artifact: Artifact) -> BytesIO:
    """Export artifact as Markdown file."""
    buffer = BytesIO()
    content = f"# {artifact.title}\n\n{artifact.content_markdown}"
    buffer.write(content.encode('utf-8'))
    buffer.seek(0)
    return buffer

def export_pdf(artifact: Artifact) -> BytesIO:
    """Export artifact as PDF using WeasyPrint."""
    from weasyprint import HTML

    # Convert markdown to HTML
    md = markdown.Markdown(extensions=['tables', 'fenced_code'])
    html_content = md.convert(artifact.content_markdown)

    # Render with Jinja2 template
    env = Environment(loader=FileSystemLoader(str(TEMPLATE_DIR)))
    template_name = f"{artifact.artifact_type.value}.html"

    # Fall back to base template with content block
    try:
        template = env.get_template(template_name)
    except:
        template = env.get_template("user_stories.html")  # Use as default

    full_html = template.render(
        title=artifact.title,
        content=html_content,
        created_at=artifact.created_at
    )

    # Generate PDF
    buffer = BytesIO()
    HTML(string=full_html).write_pdf(buffer)
    buffer.seek(0)
    return buffer

def export_docx(artifact: Artifact) -> BytesIO:
    """Export artifact as Word document using python-docx."""
    doc = Document()

    # Title
    heading = doc.add_heading(artifact.title, level=0)
    heading.alignment = WD_ALIGN_PARAGRAPH.CENTER

    # Parse markdown content into sections
    lines = artifact.content_markdown.split('\n')
    current_list = None

    for line in lines:
        line = line.rstrip()

        if not line:
            current_list = None
            continue

        # Headings
        if line.startswith('### '):
            doc.add_heading(line[4:], level=3)
            current_list = None
        elif line.startswith('## '):
            doc.add_heading(line[3:], level=2)
            current_list = None
        elif line.startswith('# '):
            doc.add_heading(line[2:], level=1)
            current_list = None
        # Bullet points
        elif line.startswith('- ') or line.startswith('* '):
            doc.add_paragraph(line[2:], style='List Bullet')
        # Numbered list
        elif line.startswith('1. ') or (len(line) > 2 and line[0].isdigit() and line[1] == '.'):
            text = line.split('. ', 1)[1] if '. ' in line else line
            doc.add_paragraph(text, style='List Number')
        # Checkbox items (convert to bullet)
        elif line.startswith('- [ ] ') or line.startswith('- [x] '):
            checkbox = '[x]' if '[x]' in line else '[ ]'
            text = line[6:]
            doc.add_paragraph(f"{checkbox} {text}", style='List Bullet')
        # Bold/emphasis lines (Given/When/Then)
        elif line.startswith('**') and '**' in line[2:]:
            # Add as paragraph, Word will show the asterisks - acceptable for MVP
            doc.add_paragraph(line.replace('**', ''))
        # Regular paragraph
        else:
            doc.add_paragraph(line)

    # Metadata footer
    doc.add_paragraph()
    footer = doc.add_paragraph()
    footer.add_run(f"Generated by BA Assistant | {artifact.created_at.strftime('%Y-%m-%d %H:%M')}")
    footer.runs[0].font.size = Pt(9)
    footer.runs[0].font.italic = True

    buffer = BytesIO()
    doc.save(buffer)
    buffer.seek(0)
    return buffer

ExportFormat = Literal["md", "pdf", "docx"]

def get_content_type(format: ExportFormat) -> str:
    """Get MIME type for export format."""
    return {
        "md": "text/markdown",
        "pdf": "application/pdf",
        "docx": "application/vnd.openxmlformats-officedocument.wordprocessingml.document"
    }[format]

def get_file_extension(format: ExportFormat) -> str:
    """Get file extension for export format."""
    return format if format != "docx" else "docx"
```
  </action>
  <verify>
```bash
cd backend && python -c "from app.services.export_service import export_markdown, export_pdf, export_docx, get_content_type; print('Exports OK')"
```
  </verify>
  <done>export_service.py has export functions for all three formats</done>
</task>

<task type="auto">
  <name>Task 3: Add export endpoint to artifacts router</name>
  <files>backend/app/routes/artifacts.py</files>
  <action>
Add export endpoint to artifacts.py:

```python
from typing import Literal
from fastapi.responses import StreamingResponse
from app.services.export_service import (
    export_markdown,
    export_pdf,
    export_docx,
    get_content_type,
    ExportFormat
)

@router.get("/artifacts/{artifact_id}/export/{format}")
async def export_artifact(
    artifact_id: str,
    format: ExportFormat,
    current_user: dict = Depends(get_current_user),
    db: AsyncSession = Depends(get_db)
):
    """
    Export artifact in specified format.

    Formats:
    - md: Markdown text file
    - pdf: PDF document with styling
    - docx: Microsoft Word document

    Returns file as streaming response with appropriate headers.
    """
    # Load artifact with thread and project for auth
    stmt = (
        select(Artifact)
        .where(Artifact.id == artifact_id)
        .options(selectinload(Artifact.thread).selectinload(Thread.project))
    )
    result = await db.execute(stmt)
    artifact = result.scalar_one_or_none()

    if not artifact:
        raise HTTPException(status_code=404, detail="Artifact not found")

    if artifact.thread.project.user_id != current_user["user_id"]:
        raise HTTPException(status_code=404, detail="Artifact not found")

    # Generate export based on format
    if format == "md":
        buffer = export_markdown(artifact)
    elif format == "pdf":
        buffer = export_pdf(artifact)
    elif format == "docx":
        buffer = export_docx(artifact)
    else:
        raise HTTPException(status_code=400, detail=f"Unsupported format: {format}")

    # Sanitize filename for Content-Disposition
    safe_title = "".join(c for c in artifact.title if c.isalnum() or c in (' ', '-', '_')).strip()
    safe_title = safe_title[:50] or "artifact"

    return StreamingResponse(
        buffer,
        media_type=get_content_type(format),
        headers={
            "Content-Disposition": f'attachment; filename="{safe_title}.{format}"'
        }
    )
```

Add required imports at top:
```python
from sqlalchemy.orm import selectinload
from app.models import Artifact, Thread
```
  </action>
  <verify>
```bash
cd backend && python -c "from app.routes.artifacts import router; paths = [r.path for r in router.routes]; print(f'Has export: {any(\"export\" in p for p in paths)}')"
```
Test endpoint (requires running server):
```bash
curl -I http://localhost:8000/api/artifacts/test/export/md -H "Authorization: Bearer $TOKEN"
# Should return 404 (not found) confirming route registered
```
  </verify>
  <done>Export endpoint returns Markdown, PDF, or Word file with proper headers</done>
</task>

</tasks>

<verification>
1. python-docx, weasyprint, markdown in requirements.txt
2. Templates exist in backend/app/templates/artifacts/
3. export_service.py has export_markdown, export_pdf, export_docx functions
4. Export endpoint registered at /artifacts/{artifact_id}/export/{format}
5. Files download with correct Content-Type and Content-Disposition headers
</verification>

<success_criteria>
- Markdown export returns plain text with artifact content
- PDF export returns styled document (if WeasyPrint installed)
- Word export returns .docx that opens in Microsoft Word
- Export endpoint enforces authentication and ownership
</success_criteria>

<output>
After completion, create `.planning/phases/04-artifact-generation-export/04-02-SUMMARY.md`
</output>
