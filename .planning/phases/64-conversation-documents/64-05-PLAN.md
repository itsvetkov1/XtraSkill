---
phase: 64-conversation-documents
plan: 05
type: execute
wave: 3
depends_on: [64-01, 64-03]
files_modified:
  - frontend/pubspec.yaml
  - frontend/lib/screens/assistant/assistant_chat_screen.dart
  - frontend/lib/screens/assistant/widgets/assistant_drop_zone.dart
  - frontend/lib/providers/assistant_conversation_provider.dart
  - frontend/lib/services/document_service.dart
autonomous: true
requirements: [UI-04]

must_haves:
  truths:
    - "User can drag files onto the chat area and they appear as attachment chips"
    - "User can paste an image from clipboard and it appears as an attachment chip"
    - "Uploaded documents persist for the thread and are available as AI context in subsequent messages"
    - "After sending a message with attachments, inline card/thumbnail shows in the user's message bubble"
    - "Document upload works end-to-end: file picked â†’ uploaded to backend â†’ AI can reference content"
  artifacts:
    - path: "frontend/lib/screens/assistant/widgets/assistant_drop_zone.dart"
      provides: "Web-only drag-and-drop wrapper for chat area"
      contains: "AssistantDropZone"
    - path: "frontend/lib/services/document_service.dart"
      provides: "Thread document upload API client method"
      contains: "uploadThreadDocument"
  key_links:
    - from: "frontend/lib/screens/assistant/assistant_chat_screen.dart"
      to: "frontend/lib/screens/assistant/widgets/assistant_drop_zone.dart"
      via: "Wrapping message list with drag-and-drop zone"
      pattern: "AssistantDropZone"
    - from: "frontend/lib/providers/assistant_conversation_provider.dart"
      to: "frontend/lib/services/document_service.dart"
      via: "Uploading attached files before sending message"
      pattern: "uploadThreadDocument"
---

<objective>
Complete document upload flow with drag-and-drop, image paste, backend upload integration, and inline display of sent documents in message bubbles.

Purpose: Users need three ways to attach documents (button already in Plan 04, drag-and-drop, and paste) and documents must actually upload to the backend and persist for AI context. After sending, attached documents should appear visually in the user's message bubble.

Output: Drag-and-drop zone + paste detection + backend upload integration + message attachment display
</objective>

<execution_context>
@/Users/a1testingmac/.claude/get-shit-done/workflows/execute-plan.md
@/Users/a1testingmac/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/64-conversation-documents/64-RESEARCH.md
@.planning/phases/64-conversation-documents/64-03-SUMMARY.md
@.planning/phases/64-conversation-documents/64-04-SUMMARY.md
@frontend/lib/services/document_service.dart
@frontend/lib/providers/assistant_conversation_provider.dart
@frontend/lib/screens/assistant/assistant_chat_screen.dart
</context>

<tasks>

<task type="auto">
  <name>Task 1: Drag-and-Drop Zone and Image Paste Support</name>
  <files>
    frontend/pubspec.yaml
    frontend/lib/screens/assistant/widgets/assistant_drop_zone.dart
    frontend/lib/screens/assistant/assistant_chat_screen.dart
  </files>
  <action>
**1. Add flutter_dropzone dependency:**
Run `cd /Users/a1testingmac/projects/XtraSkill/frontend && flutter pub add flutter_dropzone`

Note: Do NOT add super_clipboard yet â€” image paste can be implemented with basic Dart clipboard APIs first. If that proves insufficient, add super_clipboard in a follow-up. For v1, focus on drag-and-drop (web) and file picker (all platforms). Image paste is a nice-to-have but lower priority than the other two methods.

**2. Create AssistantDropZone** (`frontend/lib/screens/assistant/widgets/assistant_drop_zone.dart`):

A web-only wrapper that adds drag-and-drop file support around its child:

```dart
class AssistantDropZone extends StatefulWidget {
  final Widget child;
  final Function(List<AttachedFile>) onFilesDropped;
  const AssistantDropZone({required this.child, required this.onFilesDropped});
}
```

**Implementation:**
- Use `kIsWeb` from `package:flutter/foundation.dart` to conditionally enable
- **Web path**: Wrap child in a `Stack` with:
  - `DropzoneView` (invisible, covers entire area) for drop detection
  - The actual child widget
  - A visual overlay when dragging (semi-transparent primary color with "Drop files here" text) â€” shown via `_isDragging` state
- **Non-web path**: Just return the child directly (no drag-drop on mobile â€” users use file picker)

**DropzoneView integration:**
```dart
if (kIsWeb) {
  return Stack(
    children: [
      // Invisible dropzone covering entire area
      Positioned.fill(
        child: DropzoneView(
          operation: DragOperation.copy,
          onCreated: (ctrl) => _dropzoneController = ctrl,
          onDrop: (event) async {
            setState(() => _isDragging = false);
            // Extract file data
            final name = event.name;
            final size = await _dropzoneController.getFileSize(event);
            final bytes = await _dropzoneController.getFileData(event);
            final mime = await _dropzoneController.getFileMIME(event);
            widget.onFilesDropped([
              AttachedFile(
                name: name,
                size: size,
                bytes: bytes,
                contentType: mime,
              ),
            ]);
          },
          onHover: () => setState(() => _isDragging = true),
          onLeave: () => setState(() => _isDragging = false),
        ),
      ),
      // Actual content
      widget.child,
      // Drag overlay
      if (_isDragging)
        Positioned.fill(
          child: Container(
            color: Theme.of(context).colorScheme.primary.withOpacity(0.1),
            child: Center(
              child: Column(
                mainAxisSize: MainAxisSize.min,
                children: [
                  Icon(Icons.cloud_upload_outlined, size: 48, color: primary),
                  SizedBox(height: 8),
                  Text('Drop files here', style: TextStyle(fontSize: 16, color: primary)),
                ],
              ),
            ),
          ),
        ),
    ],
  );
} else {
  return widget.child;
}
```

**3. Integrate DropZone into AssistantChatScreen:**

Wrap the message list area (the Expanded widget containing ListView) with AssistantDropZone:
```dart
AssistantDropZone(
  onFilesDropped: (files) {
    for (final file in files) {
      provider.addAttachedFile(file);
    }
  },
  child: ListView.builder(/* existing message list */),
)
```

**4. Image paste (basic implementation):**

In the AssistantChatInput (from Plan 04), add paste detection to the TextField's FocusNode:
- Listen for Ctrl+V / Cmd+V key events
- On paste, check clipboard for image data using `Clipboard.getData('text/plain')` â€” if null (no text), try to detect image paste
- For web: Use `dart:html`'s `document.onPaste` event to capture `ClipboardEvent` with `clipboardData.files`
- Actually, a simpler approach: Add a keyboard shortcut handler in the FocusNode's `onKeyEvent`:
  ```dart
  if ((event.logicalKey == LogicalKeyboardKey.keyV) &&
      (HardwareKeyboard.instance.isControlPressed || HardwareKeyboard.instance.isMetaPressed)) {
    // Ctrl+V / Cmd+V detected â€” check for image
    _handlePaste();
    return KeyEventResult.ignored; // Let text paste through normally
  }
  ```
- `_handlePaste()` attempts to read image from clipboard. On web, this requires listening to the paste event on the HTML document. A pragmatic v1 approach: don't block on image paste â€” the file picker and drag-and-drop cover the upload workflow. Document image paste as a "future enhancement" if `super_clipboard` is needed.
- For v1, focus on ensuring Ctrl+V for TEXT paste still works normally in the TextField. Do not break text paste.

IMPORTANT: Use `kIsWeb` guards around any dart:html or web-specific code to prevent mobile build errors (Pitfall 1 from research).
  </action>
  <verify>
Run: `cd /Users/a1testingmac/projects/XtraSkill/frontend && flutter analyze lib/screens/assistant/widgets/assistant_drop_zone.dart lib/screens/assistant/assistant_chat_screen.dart` â€” should pass with no errors.

Check: `grep 'DropzoneView\|kIsWeb\|onFilesDropped\|_isDragging' frontend/lib/screens/assistant/widgets/assistant_drop_zone.dart` â€” should show dropzone integration.

Check: `grep 'AssistantDropZone' frontend/lib/screens/assistant/assistant_chat_screen.dart` â€” should show the dropzone wrapping the message list.
  </verify>
  <done>AssistantDropZone wraps the chat area for web-only drag-and-drop with visual feedback. Dropped files appear as attachment chips. Mobile gracefully falls back to file picker only. flutter_dropzone dependency added.</done>
</task>

<task type="auto">
  <name>Task 2: Backend Upload Integration and Message Attachment Display</name>
  <files>
    frontend/lib/services/document_service.dart
    frontend/lib/providers/assistant_conversation_provider.dart
    frontend/lib/screens/assistant/widgets/assistant_message_bubble.dart
  </files>
  <action>
**1. Add thread document upload to DocumentService** (`frontend/lib/services/document_service.dart`):

Add a new method to the existing DocumentService:

```dart
/// Upload document to an Assistant thread (not a project)
Future<Map<String, dynamic>> uploadThreadDocument(
    String threadId, String filename, Uint8List bytes, String contentType) async {
  final formData = FormData.fromMap({
    'file': MultipartFile.fromBytes(
      bytes,
      filename: filename,
      contentType: DioMediaType.parse(contentType),
    ),
  });

  final response = await _dio.post(
    '/api/threads/$threadId/documents',
    data: formData,
  );
  return response.data;
}
```

Also add a method to list thread documents:
```dart
/// List documents uploaded to an Assistant thread
Future<List<Map<String, dynamic>>> getThreadDocuments(String threadId) async {
  final response = await _dio.get('/api/threads/$threadId/documents');
  return List<Map<String, dynamic>>.from(response.data);
}
```

Use the existing `_dio` instance from DocumentService (which uses ApiClient with auth headers).

**2. Wire upload into AssistantConversationProvider sendMessage flow:**

Update `sendMessage()` in `assistant_conversation_provider.dart`:

Before sending the chat message, upload any attached files:
```dart
Future<void> sendMessage(String content) async {
  // 1. Upload attached files first
  final filesToUpload = List<AttachedFile>.from(_attachedFiles);
  final uploadedDocNames = <String>[];
  if (filesToUpload.isNotEmpty && _thread != null) {
    for (final file in filesToUpload) {
      try {
        if (file.bytes != null) {
          await _documentService.uploadThreadDocument(
            _thread!.id, file.name, file.bytes!, file.contentType ?? 'application/octet-stream');
          uploadedDocNames.add(file.name);
        }
      } catch (e) {
        debugPrint('Failed to upload ${file.name}: $e');
        // Continue with other files â€” don't block message send
      }
    }
    _attachedFiles.clear();
    notifyListeners();
  }

  // 2. Prepend skill if selected
  String messageToSend = content;
  if (_selectedSkill != null) {
    messageToSend = '/skill ${_selectedSkill!.name}\n\n$content';
    _selectedSkill = null;
    notifyListeners();
  }

  // 3. If files were uploaded, append a note so the AI knows
  if (uploadedDocNames.isNotEmpty) {
    messageToSend = '$messageToSend\n\n[Attached files: ${uploadedDocNames.join(", ")}]';
  }

  // 4. Send via SSE streaming (rest of existing sendMessage logic)
  // ... existing streaming code ...
}
```

Add `DocumentService _documentService` to the constructor:
```dart
AssistantConversationProvider(this._aiService, this._threadService, this._documentService);
```

Update provider registration in `main.dart` to pass `DocumentService()`.

**3. Update AssistantMessageBubble to show attachment cards:**

In `assistant_message_bubble.dart`, for user messages that contain `[Attached files: ...]`:
- Parse the attachment note from the message content
- Display a small card/chip row below the message text showing filenames with appropriate icons:
  ```
  [ðŸ“„ report.pdf] [ðŸ“Š data.xlsx]
  ```
- Cards are compact (small font, icon + filename only)
- Cards are non-interactive in v1 (just visual indication that files were attached)
- Strip the `[Attached files: ...]` note from the displayed text (user shouldn't see it as raw text)

Alternatively, store attachment info in the Message model's metadata or a local map. The simpler approach: just parse from the message content string since that's what gets sent to the backend.

**4. Add DocumentService dependency injection:**

Update `AssistantConversationProvider` constructor and `main.dart` provider registration to include `DocumentService`:
```dart
ChangeNotifierProvider(
  create: (_) => AssistantConversationProvider(
    AIService(),
    ThreadService(),
    DocumentService(),
  ),
),
```

IMPORTANT: The AI will automatically have access to thread documents because the backend's document search includes all documents associated with a thread. No special wiring needed for the AI to "see" uploaded documents â€” the backend handles it.
  </action>
  <verify>
Run: `cd /Users/a1testingmac/projects/XtraSkill/frontend && flutter analyze lib/services/document_service.dart lib/providers/assistant_conversation_provider.dart lib/screens/assistant/widgets/assistant_message_bubble.dart` â€” should pass with no errors.

Check: `grep 'uploadThreadDocument\|getThreadDocuments' frontend/lib/services/document_service.dart` â€” should show the new thread document methods.

Check: `grep 'DocumentService\|uploadThreadDocument\|uploadedDocNames\|Attached files' frontend/lib/providers/assistant_conversation_provider.dart` â€” should show upload integration in send flow.
  </verify>
  <done>Documents upload to backend via POST /api/threads/{thread_id}/documents before message send. Uploaded documents persist for thread and are available as AI context. User messages show inline file cards. Skill prepend and file upload integrated into the send flow. Provider updated with DocumentService dependency.</done>
</task>

</tasks>

<verification>
1. Drag file onto chat area â†’ file appears as attachment chip above input
2. Pick file via button â†’ chip appears, send message â†’ file uploads to backend, AI can reference it
3. User message shows inline file cards after sending with attachments
4. Upload error doesn't block message send (graceful degradation)
5. AI response referencing uploaded document content works in subsequent messages
6. Web drag-and-drop shows visual overlay; mobile falls back to file picker only
7. Multiple files can be attached and uploaded at once
</verification>

<success_criteria>
- Three upload methods work: button (from 64-04), drag-and-drop (this plan), paste (basic/deferred)
- Documents upload to backend and persist for thread
- AI can reference uploaded documents in subsequent responses
- User messages display file cards inline
- Web-only drag-and-drop doesn't break mobile builds
- Upload errors handled gracefully (don't block message send)
</success_criteria>

<output>
After completion, create `.planning/phases/64-conversation-documents/64-05-SUMMARY.md`
</output>
